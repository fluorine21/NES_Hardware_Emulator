AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
-------------------------------------------------------- func_test_1.a65 ---------------------------------------------------------

6114 lines read, no errors in pass 1.
                        
                        
                        ;as65.exe -l ../func_test_1.a65 -m -h0 -l -w
                        
                        
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2020  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 05-jan-2020
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 written by Frank A. Kingswood
                        ; The assembler as65_142.zip can be obtained from my GitHub repository 
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        ;   05-jan-2020  fixed shifts not testing zero result and flag when last 1-bit
                        ;                is shifted out
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $52 (82) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
0000 =                  zero_page = $0  
                        
                        ;data_segment memory start address, $7B (123) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13.1kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
8000 =                  code_segment = $8000
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
0008 =                  ram_top = $08
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0001 =                  disable_decimal = 1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                        		endm
                        trap_ne macro
                                bne *         ;failed not equal (non zero)
                        		endm
                        trap_cs macro
                                bcs *           ;failed carry set
                        		endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                        		endm
                        trap_mi macro
                                bmi *         ;failed minus (bit 7 set)
                        		endm
                        trap_pl macro
                                bpl *          ;failed plus (bit 7 clear)
                        		endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                        		endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                        		endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;break test interrupt save
0000 : 00               irq_a   ds  1               ;a register
0001 : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0002 :                  zpt                         ;6 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0002 : 00               adfc    ds  1               ;carry flag before op
0003 : 00               ad1     ds  1               ;operand 1 - accumulator
0004 : 00               ad2     ds  1               ;operand 2 - memory / immediate
0005 : 00               adrl    ds  1               ;expected result bits 0-7
0006 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0007 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0008 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0009 :                  zp_bss
0009 : 8001             zps     db  $80,1           ;additional shift pattern to test zero result & flag
000b : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000f : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0010 : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0014 : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0018 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
001c : 1802             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
001e : 1902                     dw  abs1+1
0020 : 1a02                     dw  abs1+2
0022 : 1b02                     dw  abs1+3
0024 : 1c02                     dw  abs7f
0026 : 2001             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0028 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
002a : 0402                     dw  abst+1
002c : 0502                     dw  abst+2
002e : 0602                     dw  abst+3
0030 : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0032 : 5f02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0034 : 6002                     dw  absAN+1
0036 : 6102                     dw  absAN+2
0038 : 6202                     dw  absAN+3
003a : 6302             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
003c : 6402                     dw  absEO+1
003e : 6502                     dw  absEO+2
0040 : 6602                     dw  absEO+3
0042 : 5b02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0044 : 5c02                     dw  absOR+1
0046 : 5d02                     dw  absOR+2
0048 : 5e02                     dw  absOR+3
                        ;add/subtract indirect pointers
004a : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
004c : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
004e : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0050 : 0501             sbiy2   dw  sba2-$ff
0052 :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;6 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 00000000                 ds  4               ;fill remaining bytes
0209 :                  data_bss
                            if load_data_direct = 1
0209 : 2900             ex_andi and #0              ;execute immediate opcodes
020b : 60                       rts
020c : 4900             ex_eori eor #0              ;execute immediate opcodes
020e : 60                       rts
020f : 0900             ex_orai ora #0              ;execute immediate opcodes
0211 : 60                       rts
0212 : 6900             ex_adci adc #0              ;execute immediate opcodes
0214 : 60                       rts
0215 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0217 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
0218 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021c : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021d : 80800002         fLDx    db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
0221 :                  rASL                                ;expected result ASL & ROL -carry
0221 : 000286048200     rROL    db  0,2,$86,$04,$82,0
0227 : 010387058301     rROLc   db  1,3,$87,$05,$83,1       ;expected result ROL +carry
022d :                  rLSR                                ;expected result LSR & ROR -carry
022d : 400061412000     rROR    db  $40,0,$61,$41,$20,0
0233 : c080e1c1a080     rRORc   db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
0239 :                  fASL                                ;expected flags for shifts
0239 : 030081018002     fROL    db  fzc,0,fnc,fc,fn,fz      ;no carry in
023f : 010081018000     fROLc   db  fc,0,fnc,fc,fn,0        ;carry in 
0245 :                  fLSR 
0245 : 000301000102     fROR    db  0,fzc,fc,0,fc,fz        ;no carry in
024b : 808181808180     fRORc   db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
0251 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
0256 : 0080800200       fINC    db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
025b : 001f7180         absOR   db  0,$1f,$71,$80           ;test pattern for OR
025f : 0fff7f80         absAN   db  $0f,$ff,$7f,$80         ;test pattern for AND
0263 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
0267 : 00f11f00         absORa  db  0,$f1,$1f,0             ;test pattern for OR
026b : f0ffffff         absANa  db  $f0,$ff,$ff,$ff         ;test pattern for AND
026f : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
0273 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0277 : 02800080         absflo  db  fz,fn,0,fn
027b :                  data_bss_end
                        
                        
                                code
8000 =                          org code_segment
8000 : d8               start   cld
8001 : a2ff                     ldx #$ff
8003 : 9a                       txs
8004 : a900                     lda #0          ;*** test 0 = initialize
8006 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
8009 : a205                     ldx #5
800b : 4c3380                   jmp psb_test
800e :                  psb_bwok
800e : a005                     ldy #5
8010 : d008                     bne psb_forw
                                trap        ;branch should be taken
8012 : 4c1280          >        jmp *           ;failed anyway
                        
8015 : 88                       dey         ;forward landing zone
8016 : 88                       dey
8017 : 88                       dey
8018 : 88                       dey
8019 : 88                       dey
801a :                  psb_forw
801a : 88                       dey
801b : 88                       dey
801c : 88                       dey
801d : 88                       dey
801e : 88                       dey
801f : f017                     beq psb_fwok
                                trap        ;forward offset
8021 : 4c2180          >        jmp *           ;failed anyway
                        
                        
8024 : ca                       dex         ;backward landing zone
8025 : ca                       dex
8026 : ca                       dex
8027 : ca                       dex
8028 : ca                       dex
8029 :                  psb_back
8029 : ca                       dex
802a : ca                       dex
802b : ca                       dex
802c : ca                       dex
802d : ca                       dex
802e : f0de                     beq psb_bwok
                                trap        ;backward offset
8030 : 4c3080          >        jmp *           ;failed anyway
                        
8033 :                  psb_test
8033 : d0f4                     bne psb_back
                                trap        ;branch should be taken
8035 : 4c3580          >        jmp *           ;failed anyway
                        
8038 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
8038 : a900                     lda #0 
803a : 8502                     sta zpt         ;set low byte of indirect pointer
803c : 8d0202                   sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
803f : 8d1981                   sta range_adr   ;reset self modifying code
                              endif
8042 : 18                       clc
8043 : a209                     ldx #zp_bss-zero_page ;zeropage - write test area
8045 : 7500             gcs3    adc zero_page,x
8047 : 9004                     bcc gcs2
8049 : ee0202                   inc ram_chksm+1 ;carry to high byte
804c : 18                       clc
804d : e8               gcs2    inx
804e : d0f5                     bne gcs3
8050 : a202                     ldx #hi(abs1)   ;set high byte of indirect pointer
8052 : 8603                     stx zpt+1
8054 : a018                     ldy #lo(abs1)   ;data after write & execute test area
8056 : 7102             gcs5    adc (zpt),y
8058 : 9004                     bcc gcs4
805a : ee0202                   inc ram_chksm+1 ;carry to high byte
805d : 18                       clc
805e : c8               gcs4    iny
805f : d0f5                     bne gcs5
8061 : e8                       inx             ;advance RAM high address
8062 : 8603                     stx zpt+1
8064 : e008                     cpx #ram_top
8066 : d0ee                     bne gcs5
8068 : 8d0102                   sta ram_chksm   ;checksum complete
                            endif
                                next_test            
806b : ad0002          >            lda test_case   ;previous test
806e : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8070 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
8072 : a901            >            lda #test_num   ;*** next tests' number
8074 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
8077 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
8079 :                  range_loop
8079 : 88                       dey             ;next relative address
807a : 98                       tya
807b : aa                       tax             ;precharge count to end of loop
807c : 1008                     bpl range_fw    ;calculate relative address
807e : 18                       clc             ;avoid branch self or to relative address of branch
807f : 6902                     adc #2
8081 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
8082 : ea                       nop
8083 : ea                       nop
8084 : ea                       nop
8085 : ea                       nop
8086 :                  range_fw
8086 : ea                       nop
8087 : ea                       nop
8088 : ea                       nop
8089 : ea                       nop
808a : ea                       nop
808b : 497f                     eor #$7f        ;complement except sign
808d : 8d1981                   sta range_adr   ;load into test target
8090 : a900                     lda #0          ;should set zero flag in status register
8092 : 4c1881                   jmp range_op
                                
8095 : ca                       dex             ; offset landing zone - backward branch too far
8096 : ca                       dex
8097 : ca                       dex
8098 : ca                       dex
8099 : ca                       dex
                                ;relative address target field with branch under test in the middle
809a : ca                       dex             ;-128 - max backward
809b : ca                       dex
809c : ca                       dex
809d : ca                       dex
809e : ca                       dex
809f : ca                       dex
80a0 : ca                       dex
80a1 : ca                       dex
80a2 : ca                       dex             ;-120
80a3 : ca                       dex
80a4 : ca                       dex
80a5 : ca                       dex
80a6 : ca                       dex
80a7 : ca                       dex
80a8 : ca                       dex
80a9 : ca                       dex
80aa : ca                       dex
80ab : ca                       dex
80ac : ca                       dex             ;-110
80ad : ca                       dex
80ae : ca                       dex
80af : ca                       dex
80b0 : ca                       dex
80b1 : ca                       dex
80b2 : ca                       dex
80b3 : ca                       dex
80b4 : ca                       dex
80b5 : ca                       dex
80b6 : ca                       dex             ;-100
80b7 : ca                       dex
80b8 : ca                       dex
80b9 : ca                       dex
80ba : ca                       dex
80bb : ca                       dex
80bc : ca                       dex
80bd : ca                       dex
80be : ca                       dex
80bf : ca                       dex
80c0 : ca                       dex             ;-90
80c1 : ca                       dex
80c2 : ca                       dex
80c3 : ca                       dex
80c4 : ca                       dex
80c5 : ca                       dex
80c6 : ca                       dex
80c7 : ca                       dex
80c8 : ca                       dex
80c9 : ca                       dex
80ca : ca                       dex             ;-80
80cb : ca                       dex
80cc : ca                       dex
80cd : ca                       dex
80ce : ca                       dex
80cf : ca                       dex
80d0 : ca                       dex
80d1 : ca                       dex
80d2 : ca                       dex
80d3 : ca                       dex
80d4 : ca                       dex             ;-70
80d5 : ca                       dex
80d6 : ca                       dex
80d7 : ca                       dex
80d8 : ca                       dex
80d9 : ca                       dex
80da : ca                       dex
80db : ca                       dex
80dc : ca                       dex
80dd : ca                       dex
80de : ca                       dex             ;-60
80df : ca                       dex
80e0 : ca                       dex
80e1 : ca                       dex
80e2 : ca                       dex
80e3 : ca                       dex
80e4 : ca                       dex
80e5 : ca                       dex
80e6 : ca                       dex
80e7 : ca                       dex
80e8 : ca                       dex             ;-50
80e9 : ca                       dex
80ea : ca                       dex
80eb : ca                       dex
80ec : ca                       dex
80ed : ca                       dex
80ee : ca                       dex
80ef : ca                       dex
80f0 : ca                       dex
80f1 : ca                       dex
80f2 : ca                       dex             ;-40
80f3 : ca                       dex
80f4 : ca                       dex
80f5 : ca                       dex
80f6 : ca                       dex
80f7 : ca                       dex
80f8 : ca                       dex
80f9 : ca                       dex
80fa : ca                       dex
80fb : ca                       dex
80fc : ca                       dex             ;-30
80fd : ca                       dex
80fe : ca                       dex
80ff : ca                       dex
8100 : ca                       dex
8101 : ca                       dex
8102 : ca                       dex
8103 : ca                       dex
8104 : ca                       dex
8105 : ca                       dex
8106 : ca                       dex             ;-20
8107 : ca                       dex
8108 : ca                       dex
8109 : ca                       dex
810a : ca                       dex
810b : ca                       dex
810c : ca                       dex
810d : ca                       dex
810e : ca                       dex
810f : ca                       dex
8110 : ca                       dex             ;-10
8111 : ca                       dex
8112 : ca                       dex
8113 : ca                       dex
8114 : ca                       dex
8115 : ca                       dex
8116 : ca                       dex
8117 : ca                       dex             ;-3
8118 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
8119 =                  range_adr   = *+1       ;modifiable relative address
8118 : f03e                     beq *+64        ;+64 if called without modification
811a : ca                       dex             ;+0
811b : ca                       dex
811c : ca                       dex
811d : ca                       dex
811e : ca                       dex
811f : ca                       dex
8120 : ca                       dex
8121 : ca                       dex
8122 : ca                       dex
8123 : ca                       dex
8124 : ca                       dex             ;+10
8125 : ca                       dex
8126 : ca                       dex
8127 : ca                       dex
8128 : ca                       dex
8129 : ca                       dex
812a : ca                       dex
812b : ca                       dex
812c : ca                       dex
812d : ca                       dex
812e : ca                       dex             ;+20
812f : ca                       dex
8130 : ca                       dex
8131 : ca                       dex
8132 : ca                       dex
8133 : ca                       dex
8134 : ca                       dex
8135 : ca                       dex
8136 : ca                       dex
8137 : ca                       dex
8138 : ca                       dex             ;+30
8139 : ca                       dex
813a : ca                       dex
813b : ca                       dex
813c : ca                       dex
813d : ca                       dex
813e : ca                       dex
813f : ca                       dex
8140 : ca                       dex
8141 : ca                       dex
8142 : ca                       dex             ;+40
8143 : ca                       dex
8144 : ca                       dex
8145 : ca                       dex
8146 : ca                       dex
8147 : ca                       dex
8148 : ca                       dex
8149 : ca                       dex
814a : ca                       dex
814b : ca                       dex
814c : ca                       dex             ;+50
814d : ca                       dex
814e : ca                       dex
814f : ca                       dex
8150 : ca                       dex
8151 : ca                       dex
8152 : ca                       dex
8153 : ca                       dex
8154 : ca                       dex
8155 : ca                       dex
8156 : ca                       dex             ;+60
8157 : ca                       dex
8158 : ca                       dex
8159 : ca                       dex
815a : ca                       dex
815b : ca                       dex
815c : ca                       dex
815d : ca                       dex
815e : ca                       dex
815f : ca                       dex
8160 : ca                       dex             ;+70
8161 : ca                       dex
8162 : ca                       dex
8163 : ca                       dex
8164 : ca                       dex
8165 : ca                       dex
8166 : ca                       dex
8167 : ca                       dex
8168 : ca                       dex
8169 : ca                       dex
816a : ca                       dex             ;+80
816b : ca                       dex
816c : ca                       dex
816d : ca                       dex
816e : ca                       dex
816f : ca                       dex
8170 : ca                       dex
8171 : ca                       dex
8172 : ca                       dex
8173 : ca                       dex
8174 : ca                       dex             ;+90
8175 : ca                       dex
8176 : ca                       dex
8177 : ca                       dex
8178 : ca                       dex
8179 : ca                       dex
817a : ca                       dex
817b : ca                       dex
817c : ca                       dex
817d : ca                       dex
817e : ca                       dex             ;+100
817f : ca                       dex
8180 : ca                       dex
8181 : ca                       dex
8182 : ca                       dex
8183 : ca                       dex
8184 : ca                       dex
8185 : ca                       dex
8186 : ca                       dex
8187 : ca                       dex
8188 : ca                       dex             ;+110
8189 : ca                       dex
818a : ca                       dex
818b : ca                       dex
818c : ca                       dex
818d : ca                       dex
818e : ca                       dex
818f : ca                       dex
8190 : ca                       dex
8191 : ca                       dex
8192 : ca                       dex             ;+120
8193 : ca                       dex
8194 : ca                       dex
8195 : ca                       dex
8196 : ca                       dex
8197 : ca                       dex
8198 : ca                       dex
8199 : ea                       nop             ;offset landing zone - forward branch too far
819a : ea                       nop
819b : ea                       nop
819c : ea                       nop
819d : ea                       nop
819e : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
81a0 : 4ca081          >        jmp *           ;failed anyway
                        
81a3 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
81a4 : ea                       nop
81a5 : ea                       nop
81a6 : ea                       nop
81a7 : ea                       nop
81a8 :                  range_ok
81a8 : ea                       nop
81a9 : ea                       nop
81aa : ea                       nop
81ab : ea                       nop
81ac : ea                       nop
81ad : c000                     cpy #0
81af : f003                     beq range_end   
81b1 : 4c7980                   jmp range_loop
81b4 :                  range_end               ;range test successful
                            endif
                                next_test
81b4 : ad0002          >            lda test_case   ;previous test
81b7 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
81b9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
81bb : a902            >            lda #test_num   ;*** next tests' number
81bd : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
81c0 : c001                     cpy #1          ;testing BNE true
81c2 : d003                     bne test_bne
                                trap 
81c4 : 4cc481          >        jmp *           ;failed anyway
                        
81c7 :                  test_bne
81c7 : a900                     lda #0 
81c9 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
81cb : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
81cd : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
81cf : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
81d1 : c901                     cmp #1
                                trap_eq 
81d3 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
81d5 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
81d7 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
81d9 : aa                       tax 
81da : e000                     cpx #0          ;test compare x immediate
                                trap_ne
81dc : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
81de : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
81e0 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
81e2 : e001                     cpx #1
                                trap_eq 
81e4 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
81e6 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
81e8 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
81ea : a8                       tay 
81eb : c000                     cpy #0          ;test compare y immediate
                                trap_ne
81ed : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
81ef : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
81f1 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
81f3 : c001                     cpy #1
                                trap_eq 
81f5 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
81f7 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
81f9 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                next_test
81fb : ad0002          >            lda test_case   ;previous test
81fe : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8200 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
8202 : a903            >            lda #test_num   ;*** next tests' number
8204 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
8207 : a2ff                     ldx #$ff        ;initialize stack
8209 : 9a                       txs
820a : a955                     lda #$55
820c : 48                       pha
820d : a9aa                     lda #$aa
820f : 48                       pha
8210 : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
8213 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8215 : ba                       tsx
8216 : 8a                       txa             ;overwrite accu
8217 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
8219 : d0fe            >        bne *         ;failed not equal (non zero)
                        
821b : 68                       pla
821c : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
821e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8220 : 68                       pla
8221 : c955                     cmp #$55
                                trap_ne
8223 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8225 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
8228 : d0fe            >        bne *         ;failed not equal (non zero)
                        
822a : ba                       tsx
822b : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
822d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
822f : ad0002          >            lda test_case   ;previous test
8232 : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8234 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
8236 : a904            >            lda #test_num   ;*** next tests' number
8238 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
823b : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
823d : 48              >            pha         ;use stack to load status
823e : 28              >            plp
                        
823f : 101a                     bpl nbr1        ;branches should not be taken
8241 : 501b                     bvc nbr2
8243 : 901c                     bcc nbr3
8245 : d01d                     bne nbr4
8247 : 3003                     bmi br1         ;branches should be taken
                                trap 
8249 : 4c4982          >        jmp *           ;failed anyway
                        
824c : 7003             br1     bvs br2
                                trap 
824e : 4c4e82          >        jmp *           ;failed anyway
                        
8251 : b003             br2     bcs br3
                                trap 
8253 : 4c5382          >        jmp *           ;failed anyway
                        
8256 : f00f             br3     beq br4
                                trap 
8258 : 4c5882          >        jmp *           ;failed anyway
                        
825b :                  nbr1
                                trap            ;previous bpl taken 
825b : 4c5b82          >        jmp *           ;failed anyway
                        
825e :                  nbr2
                                trap            ;previous bvc taken
825e : 4c5e82          >        jmp *           ;failed anyway
                        
8261 :                  nbr3
                                trap            ;previous bcc taken
8261 : 4c6182          >        jmp *           ;failed anyway
                        
8264 :                  nbr4
                                trap            ;previous bne taken
8264 : 4c6482          >        jmp *           ;failed anyway
                        
8267 : 08               br4     php
8268 : ba                       tsx
8269 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
826b : d0fe            >        bne *         ;failed not equal (non zero)
                        
826d : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
826e : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8270 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8272 : ba                       tsx
8273 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
8275 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
8277 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
8279 : 48              >            pha         ;use stack to load status
827a : 28              >            plp
                        
827b : 301a                     bmi nbr11       ;branches should not be taken
827d : 701b                     bvs nbr12
827f : b01c                     bcs nbr13
8281 : f01d                     beq nbr14
8283 : 1003                     bpl br11        ;branches should be taken
                                trap 
8285 : 4c8582          >        jmp *           ;failed anyway
                        
8288 : 5003             br11    bvc br12
                                trap 
828a : 4c8a82          >        jmp *           ;failed anyway
                        
828d : 9003             br12    bcc br13
                                trap 
828f : 4c8f82          >        jmp *           ;failed anyway
                        
8292 : d00f             br13    bne br14
                                trap 
8294 : 4c9482          >        jmp *           ;failed anyway
                        
8297 :                  nbr11
                                trap            ;previous bmi taken 
8297 : 4c9782          >        jmp *           ;failed anyway
                        
829a :                  nbr12
                                trap            ;previous bvs taken 
829a : 4c9a82          >        jmp *           ;failed anyway
                        
829d :                  nbr13
                                trap            ;previous bcs taken 
829d : 4c9d82          >        jmp *           ;failed anyway
                        
82a0 :                  nbr14
                                trap            ;previous beq taken 
82a0 : 4ca082          >        jmp *           ;failed anyway
                        
82a3 : 08               br14    php
82a4 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
82a5 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                ;cmp #0
                        		trap_ne
82a7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
82a9 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
82ab : 48              >            pha         ;use stack to load status
82ac : 28              >            plp
                        
82ad : d002                     bne brzs1
82af : f003                     beq brzs2
82b1 :                  brzs1
                                trap            ;branch zero/non zero
82b1 : 4cb182          >        jmp *           ;failed anyway
                        
82b4 : b002             brzs2   bcs brzs3
82b6 : 9003                     bcc brzs4
82b8 :                  brzs3
                                trap            ;branch carry/no carry
82b8 : 4cb882          >        jmp *           ;failed anyway
                        
82bb : 3002             brzs4   bmi brzs5
82bd : 1003                     bpl brzs6
82bf :                  brzs5
                                trap            ;branch minus/plus
82bf : 4cbf82          >        jmp *           ;failed anyway
                        
82c2 : 7002             brzs6   bvs brzs7
82c4 : 5003                     bvc brzs8
82c6 :                  brzs7
                                trap            ;branch overflow/no overflow
82c6 : 4cc682          >        jmp *           ;failed anyway
                        
82c9 :                  brzs8
                                set_stat carry
                       >            load_flag carry
82c9 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
82cb : 48              >            pha         ;use stack to load status
82cc : 28              >            plp
                        
82cd : f002                     beq brcs1
82cf : d003                     bne brcs2
82d1 :                  brcs1
                                trap            ;branch zero/non zero
82d1 : 4cd182          >        jmp *           ;failed anyway
                        
82d4 : 9002             brcs2   bcc brcs3
82d6 : b003                     bcs brcs4
82d8 :                  brcs3
                                trap            ;branch carry/no carry
82d8 : 4cd882          >        jmp *           ;failed anyway
                        
82db : 3002             brcs4   bmi brcs5
82dd : 1003                     bpl brcs6
82df :                  brcs5
                                trap            ;branch minus/plus
82df : 4cdf82          >        jmp *           ;failed anyway
                        
82e2 : 7002             brcs6   bvs brcs7
82e4 : 5003                     bvc brcs8
82e6 :                  brcs7
                                trap            ;branch overflow/no overflow
82e6 : 4ce682          >        jmp *           ;failed anyway
                        
                        
82e9 :                  brcs8
                                set_stat minus
                       >            load_flag minus
82e9 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
82eb : 48              >            pha         ;use stack to load status
82ec : 28              >            plp
                        
82ed : f002                     beq brmi1
82ef : d003                     bne brmi2
82f1 :                  brmi1
                                trap            ;branch zero/non zero
82f1 : 4cf182          >        jmp *           ;failed anyway
                        
82f4 : b002             brmi2   bcs brmi3
82f6 : 9003                     bcc brmi4
82f8 :                  brmi3
                                trap            ;branch carry/no carry
82f8 : 4cf882          >        jmp *           ;failed anyway
                        
82fb : 1002             brmi4   bpl brmi5
82fd : 3003                     bmi brmi6
82ff :                  brmi5
                                trap            ;branch minus/plus
82ff : 4cff82          >        jmp *           ;failed anyway
                        
8302 : 7002             brmi6   bvs brmi7
8304 : 5003                     bvc brmi8
8306 :                  brmi7
                                trap            ;branch overflow/no overflow
8306 : 4c0683          >        jmp *           ;failed anyway
                        
8309 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
8309 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
830b : 48              >            pha         ;use stack to load status
830c : 28              >            plp
                        
830d : f002                     beq brvs1
830f : d003                     bne brvs2
8311 :                  brvs1
                                trap            ;branch zero/non zero
8311 : 4c1183          >        jmp *           ;failed anyway
                        
8314 : b002             brvs2   bcs brvs3
8316 : 9003                     bcc brvs4
8318 :                  brvs3
                                trap            ;branch carry/no carry
8318 : 4c1883          >        jmp *           ;failed anyway
                        
831b : 3002             brvs4   bmi brvs5
831d : 1003                     bpl brvs6
831f :                  brvs5
                                trap            ;branch minus/plus
831f : 4c1f83          >        jmp *           ;failed anyway
                        
8322 : 5002             brvs6   bvc brvs7
8324 : 7003                     bvs brvs8
8326 :                  brvs7
                                trap            ;branch overflow/no overflow
8326 : 4c2683          >        jmp *           ;failed anyway
                        
8329 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
8329 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
832b : 48              >            pha         ;use stack to load status
832c : 28              >            plp
                        
832d : f002                     beq brzc1
832f : d003                     bne brzc2
8331 :                  brzc1
                                trap            ;branch zero/non zero
8331 : 4c3183          >        jmp *           ;failed anyway
                        
8334 : 9002             brzc2   bcc brzc3
8336 : b003                     bcs brzc4
8338 :                  brzc3
                                trap            ;branch carry/no carry
8338 : 4c3883          >        jmp *           ;failed anyway
                        
833b : 1002             brzc4   bpl brzc5
833d : 3003                     bmi brzc6
833f :                  brzc5
                                trap            ;branch minus/plus
833f : 4c3f83          >        jmp *           ;failed anyway
                        
8342 : 5002             brzc6   bvc brzc7
8344 : 7003                     bvs brzc8
8346 :                  brzc7
                                trap            ;branch overflow/no overflow
8346 : 4c4683          >        jmp *           ;failed anyway
                        
8349 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
8349 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
834b : 48              >            pha         ;use stack to load status
834c : 28              >            plp
                        
834d : d002                     bne brcc1
834f : f003                     beq brcc2
8351 :                  brcc1
                                trap            ;branch zero/non zero
8351 : 4c5183          >        jmp *           ;failed anyway
                        
8354 : b002             brcc2   bcs brcc3
8356 : 9003                     bcc brcc4
8358 :                  brcc3
                                trap            ;branch carry/no carry
8358 : 4c5883          >        jmp *           ;failed anyway
                        
835b : 1002             brcc4   bpl brcc5
835d : 3003                     bmi brcc6
835f :                  brcc5
                                trap            ;branch minus/plus
835f : 4c5f83          >        jmp *           ;failed anyway
                        
8362 : 5002             brcc6   bvc brcc7
8364 : 7003                     bvs brcc8
8366 :                  brcc7
                                trap            ;branch overflow/no overflow
8366 : 4c6683          >        jmp *           ;failed anyway
                        
8369 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
8369 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
836b : 48              >            pha         ;use stack to load status
836c : 28              >            plp
                        
836d : d002                     bne brpl1
836f : f003                     beq brpl2
8371 :                  brpl1
                                trap            ;branch zero/non zero
8371 : 4c7183          >        jmp *           ;failed anyway
                        
8374 : 9002             brpl2   bcc brpl3
8376 : b003                     bcs brpl4
8378 :                  brpl3
                                trap            ;branch carry/no carry
8378 : 4c7883          >        jmp *           ;failed anyway
                        
837b : 3002             brpl4   bmi brpl5
837d : 1003                     bpl brpl6
837f :                  brpl5
                                trap            ;branch minus/plus
837f : 4c7f83          >        jmp *           ;failed anyway
                        
8382 : 5002             brpl6   bvc brpl7
8384 : 7003                     bvs brpl8
8386 :                  brpl7
                                trap            ;branch overflow/no overflow
8386 : 4c8683          >        jmp *           ;failed anyway
                        
8389 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
8389 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
838b : 48              >            pha         ;use stack to load status
838c : 28              >            plp
                        
838d : d002                     bne brvc1
838f : f003                     beq brvc2
8391 :                  brvc1
                                trap            ;branch zero/non zero
8391 : 4c9183          >        jmp *           ;failed anyway
                        
8394 : 9002             brvc2   bcc brvc3
8396 : b003                     bcs brvc4
8398 :                  brvc3
                                trap            ;branch carry/no carry
8398 : 4c9883          >        jmp *           ;failed anyway
                        
839b : 1002             brvc4   bpl brvc5
839d : 3003                     bmi brvc6
839f :                  brvc5
                                trap            ;branch minus/plus
839f : 4c9f83          >        jmp *           ;failed anyway
                        
83a2 : 7002             brvc6   bvs brvc7
83a4 : 5003                     bvc brvc8
83a6 :                  brvc7
                                trap            ;branch overflow/no overflow
83a6 : 4ca683          >        jmp *           ;failed anyway
                        
83a9 :                  brvc8
                                next_test
83a9 : ad0002          >            lda test_case   ;previous test
83ac : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
83ae : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
83b0 : a905            >            lda #test_num   ;*** next tests' number
83b2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
83b5 : a255                     ldx #$55        ;x & y protected
83b7 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
83b9 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
83bb : 48              >            pha         ;use stack to load status
83bc : a901            >            lda #1     ;precharge accu
83be : 28              >            plp
                        
83bf : 48                       pha
                                tst_a 1,$ff
83c0 : 08              >            php         ;save flags
83c1 : c901            >            cmp #1     ;test result
                       >            trap_ne
83c3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83c5 : 68              >            pla         ;load status
83c6 : 48              >            pha
                       >            cmp_flag $ff
83c7 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
83c9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83cb : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
83cc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
83ce : 48              >            pha         ;use stack to load status
83cf : a900            >            lda #0     ;precharge accu
83d1 : 28              >            plp
                        
83d2 : 48                       pha
                                tst_a 0,0
83d3 : 08              >            php         ;save flags
83d4 : c900            >            cmp #0     ;test result
                       >            trap_ne
83d6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83d8 : 68              >            pla         ;load status
83d9 : 48              >            pha
                       >            cmp_flag 0
83da : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
83dc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83de : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
83df : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
83e1 : 48              >            pha         ;use stack to load status
83e2 : a9ff            >            lda #$ff     ;precharge accu
83e4 : 28              >            plp
                        
83e5 : 48                       pha
                                tst_a $ff,$ff
83e6 : 08              >            php         ;save flags
83e7 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
83e9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83eb : 68              >            pla         ;load status
83ec : 48              >            pha
                       >            cmp_flag $ff
83ed : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
83ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83f1 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
83f2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
83f4 : 48              >            pha         ;use stack to load status
83f5 : a901            >            lda #1     ;precharge accu
83f7 : 28              >            plp
                        
83f8 : 48                       pha
                                tst_a 1,0
83f9 : 08              >            php         ;save flags
83fa : c901            >            cmp #1     ;test result
                       >            trap_ne
83fc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83fe : 68              >            pla         ;load status
83ff : 48              >            pha
                       >            cmp_flag 0
8400 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8402 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8404 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
8405 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8407 : 48              >            pha         ;use stack to load status
8408 : a900            >            lda #0     ;precharge accu
840a : 28              >            plp
                        
840b : 48                       pha
                                tst_a 0,$ff
840c : 08              >            php         ;save flags
840d : c900            >            cmp #0     ;test result
                       >            trap_ne
840f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8411 : 68              >            pla         ;load status
8412 : 48              >            pha
                       >            cmp_flag $ff
8413 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8415 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8417 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
8418 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
841a : 48              >            pha         ;use stack to load status
841b : a9ff            >            lda #$ff     ;precharge accu
841d : 28              >            plp
                        
841e : 48                       pha
                                tst_a $ff,0
841f : 08              >            php         ;save flags
8420 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
8422 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8424 : 68              >            pla         ;load status
8425 : 48              >            pha
                       >            cmp_flag 0
8426 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8428 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
842a : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
842b : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
842d : 48              >            pha         ;use stack to load status
842e : a900            >            lda #0     ;precharge accu
8430 : 28              >            plp
                        
8431 : 68                       pla
                                tst_a $ff,$ff-zero
8432 : 08              >            php         ;save flags
8433 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
8435 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8437 : 68              >            pla         ;load status
8438 : 48              >            pha
                       >            cmp_flag $ff-zero
8439 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
843b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
843d : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
843e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8440 : 48              >            pha         ;use stack to load status
8441 : a9ff            >            lda #$ff     ;precharge accu
8443 : 28              >            plp
                        
8444 : 68                       pla
                                tst_a 0,zero
8445 : 08              >            php         ;save flags
8446 : c900            >            cmp #0     ;test result
                       >            trap_ne
8448 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
844a : 68              >            pla         ;load status
844b : 48              >            pha
                       >            cmp_flag zero
844c : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
844e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8450 : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
8451 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8453 : 48              >            pha         ;use stack to load status
8454 : a9fe            >            lda #$fe     ;precharge accu
8456 : 28              >            plp
                        
8457 : 68                       pla
                                tst_a 1,$ff-zero-minus
8458 : 08              >            php         ;save flags
8459 : c901            >            cmp #1     ;test result
                       >            trap_ne
845b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
845d : 68              >            pla         ;load status
845e : 48              >            pha
                       >            cmp_flag $ff-zero-minus
845f : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8461 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8463 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
8464 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8466 : 48              >            pha         ;use stack to load status
8467 : a900            >            lda #0     ;precharge accu
8469 : 28              >            plp
                        
846a : 68                       pla
                                tst_a $ff,minus
846b : 08              >            php         ;save flags
846c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
846e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8470 : 68              >            pla         ;load status
8471 : 48              >            pha
                       >            cmp_flag minus
8472 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8474 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8476 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
8477 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8479 : 48              >            pha         ;use stack to load status
847a : a9ff            >            lda #$ff     ;precharge accu
847c : 28              >            plp
                        
847d : 68                       pla
                                tst_a 0,$ff-minus
847e : 08              >            php         ;save flags
847f : c900            >            cmp #0     ;test result
                       >            trap_ne
8481 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8483 : 68              >            pla         ;load status
8484 : 48              >            pha
                       >            cmp_flag $ff-minus
8485 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8487 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8489 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
848a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
848c : 48              >            pha         ;use stack to load status
848d : a9fe            >            lda #$fe     ;precharge accu
848f : 28              >            plp
                        
8490 : 68                       pla
                                tst_a 1,0
8491 : 08              >            php         ;save flags
8492 : c901            >            cmp #1     ;test result
                       >            trap_ne
8494 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8496 : 68              >            pla         ;load status
8497 : 48              >            pha
                       >            cmp_flag 0
8498 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
849a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
849c : 28              >            plp         ;restore status
                        
849d : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
849f : d0fe            >        bne *         ;failed not equal (non zero)
                        
84a1 : c0aa                     cpy #$aa
                                trap_ne
84a3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
84a5 : ad0002          >            lda test_case   ;previous test
84a8 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
84aa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
84ac : a906            >            lda #test_num   ;*** next tests' number
84ae : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
84b1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
84b3 : 48              >            pha         ;use stack to load status
84b4 : a93c            >            lda #$3c     ;precharge accu
84b6 : 28              >            plp
                        
84b7 : 49c3                     eor #$c3
                                tst_a $ff,fn
84b9 : 08              >            php         ;save flags
84ba : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
84bc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84be : 68              >            pla         ;load status
84bf : 48              >            pha
                       >            cmp_flag fn
84c0 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
84c2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84c4 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
84c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
84c7 : 48              >            pha         ;use stack to load status
84c8 : a9c3            >            lda #$c3     ;precharge accu
84ca : 28              >            plp
                        
84cb : 49c3                     eor #$c3
                                tst_a 0,fz
84cd : 08              >            php         ;save flags
84ce : c900            >            cmp #0     ;test result
                       >            trap_ne
84d0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84d2 : 68              >            pla         ;load status
84d3 : 48              >            pha
                       >            cmp_flag fz
84d4 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
84d6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84d8 : 28              >            plp         ;restore status
                        
                                next_test
84d9 : ad0002          >            lda test_case   ;previous test
84dc : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
84de : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
84e0 : a907            >            lda #test_num   ;*** next tests' number
84e2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
84e5 : a224                     ldx #$24
84e7 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
84e9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
84eb : 48              >            pha         ;use stack to load status
84ec : a918            >            lda #$18     ;precharge accu
84ee : 28              >            plp
                        
84ef : ea                       nop
                                tst_a $18,0
84f0 : 08              >            php         ;save flags
84f1 : c918            >            cmp #$18     ;test result
                       >            trap_ne
84f3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84f5 : 68              >            pla         ;load status
84f6 : 48              >            pha
                       >            cmp_flag 0
84f7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
84f9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84fb : 28              >            plp         ;restore status
                        
84fc : e024                     cpx #$24
                                trap_ne
84fe : d0fe            >        bne *         ;failed not equal (non zero)
                        
8500 : c042                     cpy #$42
                                trap_ne
8502 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8504 : a2db                     ldx #$db
8506 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
8508 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
850a : 48              >            pha         ;use stack to load status
850b : a9e7            >            lda #$e7     ;precharge accu
850d : 28              >            plp
                        
850e : ea                       nop
                                tst_a $e7,$ff
850f : 08              >            php         ;save flags
8510 : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
8512 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8514 : 68              >            pla         ;load status
8515 : 48              >            pha
                       >            cmp_flag $ff
8516 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8518 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
851a : 28              >            plp         ;restore status
                        
851b : e0db                     cpx #$db
                                trap_ne
851d : d0fe            >        bne *         ;failed not equal (non zero)
                        
851f : c0bd                     cpy #$bd
                                trap_ne
8521 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
8523 : ad0002          >            lda test_case   ;previous test
8526 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8528 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
852a : a908            >            lda #test_num   ;*** next tests' number
852c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
852f : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
8531 : 48              >            pha         ;use stack to load status
8532 : 28              >            plp
                        
8533 : a946                     lda #'F'
8535 : a241                     ldx #'A'
8537 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
8539 : 4c2fb1                   jmp test_far
853c : ea                       nop
853d : ea                       nop
                                trap_ne         ;runover protection
853e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8540 : e8                       inx
8541 : e8                       inx
8542 :                  far_ret 
                                trap_eq         ;returned flags OK?
8542 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
8544 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
8546 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
8548 : 50fe            >        bvc *           ;failed overflow clear
                        
854a : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
854c : d0fe            >        bne *         ;failed not equal (non zero)
                        
854e : e042                     cpx #('A'+1)
                                trap_ne
8550 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8552 : c04f                     cpy #('R'-3)
                                trap_ne
8554 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8556 : ca                       dex
8557 : c8                       iny
8558 : c8                       iny
8559 : c8                       iny
855a : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
855c : 4c6585                   jmp test_near
855f : ea                       nop
8560 : ea                       nop
                                trap_ne         ;runover protection
8561 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8563 : e8                       inx
8564 : e8                       inx
8565 :                  test_near
                                trap_eq         ;passed flags OK?
8565 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
8567 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_cc
8569 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
856b : 50fe            >        bvc *           ;failed overflow clear
                        
856d : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
856f : d0fe            >        bne *         ;failed not equal (non zero)
                        
8571 : e041                     cpx #'A'
                                trap_ne
8573 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8575 : c052                     cpy #'R'
                                trap_ne
8577 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
8579 : ad0002          >            lda test_case   ;previous test
857c : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
857e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
8580 : a909            >            lda #test_num   ;*** next tests' number
8582 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
8585 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8587 : 48              >            pha         ;use stack to load status
8588 : 28              >            plp
                        
8589 : a949                     lda #'I'
858b : a24e                     ldx #'N'
858d : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
858f : 6c5eb1                   jmp (ptr_tst_ind)
8592 : ea                       nop
                                trap_ne         ;runover protection
8593 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8595 : 88                       dey
8596 : 88                       dey
8597 :                  ind_ret 
8597 : 08                       php             ;either SP or Y count will fail, if we do not hit
8598 : 88                       dey
8599 : 88                       dey
859a : 88                       dey
859b : 28                       plp
                                trap_eq         ;returned flags OK?
859c : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
859e : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
85a0 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
85a2 : 50fe            >        bvc *           ;failed overflow clear
                        
85a4 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
85a6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
85a8 : e04f                     cpx #('N'+1)
                                trap_ne
85aa : d0fe            >        bne *         ;failed not equal (non zero)
                        
85ac : c03e                     cpy #('D'-6)
                                trap_ne
85ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
85b0 : ba                       tsx             ;SP check
85b1 : e0ff                     cpx #$ff
                                trap_ne
85b3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
85b5 : ad0002          >            lda test_case   ;previous test
85b8 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
85ba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
85bc : a90a            >            lda #test_num   ;*** next tests' number
85be : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
85c1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
85c3 : 48              >            pha         ;use stack to load status
85c4 : 28              >            plp
                        
85c5 : a94a                     lda #'J'
85c7 : a253                     ldx #'S'
85c9 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
85cb : 209db1                   jsr test_jsr
85cd =                  jsr_ret = *-1           ;last address of jsr = return address
85ce : 08                       php             ;either SP or Y count will fail, if we do not hit
85cf : 88                       dey
85d0 : 88                       dey
85d1 : 88                       dey
85d2 : 28                       plp
                                trap_eq         ;returned flags OK?
85d3 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
85d5 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
85d7 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
85d9 : 50fe            >        bvc *           ;failed overflow clear
                        
85db : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
85dd : d0fe            >        bne *         ;failed not equal (non zero)
                        
85df : e054                     cpx #('S'+1)
                                trap_ne
85e1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
85e3 : c04c                     cpy #('R'-6)
                                trap_ne
85e5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
85e7 : ba                       tsx             ;sp?
85e8 : e0ff                     cpx #$ff
                                trap_ne
85ea : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
85ec : ad0002          >            lda test_case   ;previous test
85ef : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
85f1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
85f3 : a90b            >            lda #test_num   ;*** next tests' number
85f5 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
85f8 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
85fa : 48                       pha
85fb : a942                     lda #'B'
85fd : a252                     ldx #'R'
85ff : a04b                     ldy #'K'
8601 : 28                       plp             ;N=0, V=0, Z=0, C=0
8602 : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
8603 : 88                       dey             ;should not be executed
8604 :                  brk_ret0                ;address of break return
8604 : 08                       php             ;either SP or Y count will fail, if we do not hit
8605 : 88                       dey
8606 : 88                       dey
8607 : 88                       dey
8608 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
860a : d0fe            >        bne *         ;failed not equal (non zero)
                        
860c : e053                     cpx #'R'+1
                                trap_ne
860e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8610 : c045                     cpy #'K'-6
                                trap_ne
8612 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8614 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
8615 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8617 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8619 : ba                       tsx             ;sp?
861a : e0ff                     cpx #$ff
                                trap_ne
861c : d0fe            >        bne *         ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
861e : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
8620 : 48                       pha
8621 : a9bd                     lda #$ff-'B'
8623 : a2ad                     ldx #$ff-'R'
8625 : a0b4                     ldy #$ff-'K'
8627 : 28                       plp             ;N=1, V=1, Z=1, C=1
8628 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
8629 : 88                       dey             ;should not be executed
862a :                  brk_ret1                ;address of break return
862a : 08                       php             ;either SP or Y count will fail, if we do not hit
862b : 88                       dey
862c : 88                       dey
862d : 88                       dey
862e : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
8630 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8632 : e0ae                     cpx #$ff-'R'+1
                                trap_ne
8634 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8636 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
8638 : d0fe            >        bne *         ;failed not equal (non zero)
                        
863a : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
863b : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
863d : d0fe            >        bne *         ;failed not equal (non zero)
                        
863f : ba                       tsx             ;sp?
8640 : e0ff                     cpx #$ff
                                trap_ne
8642 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
8644 : ad0002          >            lda test_case   ;previous test
8647 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8649 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
864b : a90c            >            lda #test_num   ;*** next tests' number
864d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
8650 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8652 : 48              >            pha         ;use stack to load status
8653 : 28              >            plp
                        
8654 : 18                       clc
                                tst_stat $ff-carry
8655 : 08              >            php         ;save status
8656 : 68              >            pla         ;use stack to retrieve status
8657 : 48              >            pha
                       >            cmp_flag $ff-carry
8658 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
865a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
865c : 28              >            plp         ;restore status
                        
865d : 38                       sec
                                tst_stat $ff
865e : 08              >            php         ;save status
865f : 68              >            pla         ;use stack to retrieve status
8660 : 48              >            pha
                       >            cmp_flag $ff
8661 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8663 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8665 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
8666 : 58                       cli
                                tst_stat $ff-intdis
8667 : 08              >            php         ;save status
8668 : 68              >            pla         ;use stack to retrieve status
8669 : 48              >            pha
                       >            cmp_flag $ff-intdis
866a : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
866c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
866e : 28              >            plp         ;restore status
                        
866f : 78                       sei
                                tst_stat $ff
8670 : 08              >            php         ;save status
8671 : 68              >            pla         ;use stack to retrieve status
8672 : 48              >            pha
                       >            cmp_flag $ff
8673 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8675 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8677 : 28              >            plp         ;restore status
                        
                            endif
8678 : d8                       cld
                                tst_stat $ff-decmode
8679 : 08              >            php         ;save status
867a : 68              >            pla         ;use stack to retrieve status
867b : 48              >            pha
                       >            cmp_flag $ff-decmode
867c : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
867e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8680 : 28              >            plp         ;restore status
                        
8681 : f8                       sed
                                tst_stat $ff
8682 : 08              >            php         ;save status
8683 : 68              >            pla         ;use stack to retrieve status
8684 : 48              >            pha
                       >            cmp_flag $ff
8685 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8687 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8689 : 28              >            plp         ;restore status
                        
868a : b8                       clv
                                tst_stat $ff-overfl
868b : 08              >            php         ;save status
868c : 68              >            pla         ;use stack to retrieve status
868d : 48              >            pha
                       >            cmp_flag $ff-overfl
868e : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8690 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8692 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
8693 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8695 : 48              >            pha         ;use stack to load status
8696 : 28              >            plp
                        
                                tst_stat 0
8697 : 08              >            php         ;save status
8698 : 68              >            pla         ;use stack to retrieve status
8699 : 48              >            pha
                       >            cmp_flag 0
869a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
869c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
869e : 28              >            plp         ;restore status
                        
869f : 38                       sec
                                tst_stat carry
86a0 : 08              >            php         ;save status
86a1 : 68              >            pla         ;use stack to retrieve status
86a2 : 48              >            pha
                       >            cmp_flag carry
86a3 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86a5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86a7 : 28              >            plp         ;restore status
                        
86a8 : 18                       clc
                                tst_stat 0  
86a9 : 08              >            php         ;save status
86aa : 68              >            pla         ;use stack to retrieve status
86ab : 48              >            pha
                       >            cmp_flag 0  
86ac : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86ae : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86b0 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
86b1 : 78                       sei
                                tst_stat intdis
86b2 : 08              >            php         ;save status
86b3 : 68              >            pla         ;use stack to retrieve status
86b4 : 48              >            pha
                       >            cmp_flag intdis
86b5 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86b7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86b9 : 28              >            plp         ;restore status
                        
86ba : 58                       cli
                                tst_stat 0
86bb : 08              >            php         ;save status
86bc : 68              >            pla         ;use stack to retrieve status
86bd : 48              >            pha
                       >            cmp_flag 0
86be : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86c0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86c2 : 28              >            plp         ;restore status
                        
                            endif  
86c3 : f8                       sed
                                tst_stat decmode
86c4 : 08              >            php         ;save status
86c5 : 68              >            pla         ;use stack to retrieve status
86c6 : 48              >            pha
                       >            cmp_flag decmode
86c7 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86c9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86cb : 28              >            plp         ;restore status
                        
86cc : d8                       cld
                                tst_stat 0  
86cd : 08              >            php         ;save status
86ce : 68              >            pla         ;use stack to retrieve status
86cf : 48              >            pha
                       >            cmp_flag 0  
86d0 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86d2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86d4 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
86d5 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
86d7 : 48              >            pha         ;use stack to load status
86d8 : 28              >            plp
                        
                                tst_stat overfl
86d9 : 08              >            php         ;save status
86da : 68              >            pla         ;use stack to retrieve status
86db : 48              >            pha
                       >            cmp_flag overfl
86dc : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86de : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86e0 : 28              >            plp         ;restore status
                        
86e1 : b8                       clv
                                tst_stat 0
86e2 : 08              >            php         ;save status
86e3 : 68              >            pla         ;use stack to retrieve status
86e4 : 48              >            pha
                       >            cmp_flag 0
86e5 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86e9 : 28              >            plp         ;restore status
                        
                                next_test
86ea : ad0002          >            lda test_case   ;previous test
86ed : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
86ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
86f1 : a90d            >            lda #test_num   ;*** next tests' number
86f3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
86f6 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
86f8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
86fa : 48              >            pha         ;use stack to load status
86fb : 28              >            plp
                        
86fc : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
86fd : 08              >            php         ;save flags
86fe : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
8700 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8702 : 68              >            pla         ;load status
8703 : 48              >            pha
                       >            cmp_flag $ff-zero
8704 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8706 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8708 : 28              >            plp         ;restore status
                        
8709 : e8                       inx             ;00
                                tst_x 0,$ff-minus
870a : 08              >            php         ;save flags
870b : e000            >            cpx #0     ;test result
                       >            trap_ne
870d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
870f : 68              >            pla         ;load status
8710 : 48              >            pha
                       >            cmp_flag $ff-minus
8711 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8713 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8715 : 28              >            plp         ;restore status
                        
8716 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
8717 : 08              >            php         ;save flags
8718 : e001            >            cpx #1     ;test result
                       >            trap_ne
871a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
871c : 68              >            pla         ;load status
871d : 48              >            pha
                       >            cmp_flag $ff-minus-zero
871e : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8720 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8722 : 28              >            plp         ;restore status
                        
8723 : ca                       dex             ;00
                                tst_x 0,$ff-minus
8724 : 08              >            php         ;save flags
8725 : e000            >            cpx #0     ;test result
                       >            trap_ne
8727 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8729 : 68              >            pla         ;load status
872a : 48              >            pha
                       >            cmp_flag $ff-minus
872b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
872d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
872f : 28              >            plp         ;restore status
                        
8730 : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
8731 : 08              >            php         ;save flags
8732 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
8734 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8736 : 68              >            pla         ;load status
8737 : 48              >            pha
                       >            cmp_flag $ff-zero
8738 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
873a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
873c : 28              >            plp         ;restore status
                        
873d : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
873e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8740 : 48              >            pha         ;use stack to load status
8741 : 28              >            plp
                        
8742 : e8                       inx             ;ff
                                tst_x $ff,minus
8743 : 08              >            php         ;save flags
8744 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
8746 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8748 : 68              >            pla         ;load status
8749 : 48              >            pha
                       >            cmp_flag minus
874a : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
874c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
874e : 28              >            plp         ;restore status
                        
874f : e8                       inx             ;00
                                tst_x 0,zero
8750 : 08              >            php         ;save flags
8751 : e000            >            cpx #0     ;test result
                       >            trap_ne
8753 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8755 : 68              >            pla         ;load status
8756 : 48              >            pha
                       >            cmp_flag zero
8757 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8759 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
875b : 28              >            plp         ;restore status
                        
875c : e8                       inx             ;01
                                tst_x 1,0
875d : 08              >            php         ;save flags
875e : e001            >            cpx #1     ;test result
                       >            trap_ne
8760 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8762 : 68              >            pla         ;load status
8763 : 48              >            pha
                       >            cmp_flag 0
8764 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8766 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8768 : 28              >            plp         ;restore status
                        
8769 : ca                       dex             ;00
                                tst_x 0,zero
876a : 08              >            php         ;save flags
876b : e000            >            cpx #0     ;test result
                       >            trap_ne
876d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
876f : 68              >            pla         ;load status
8770 : 48              >            pha
                       >            cmp_flag zero
8771 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8773 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8775 : 28              >            plp         ;restore status
                        
8776 : ca                       dex             ;ff
                                tst_x $ff,minus
8777 : 08              >            php         ;save flags
8778 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
877a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
877c : 68              >            pla         ;load status
877d : 48              >            pha
                       >            cmp_flag minus
877e : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8780 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8782 : 28              >            plp         ;restore status
                        
                        
8783 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
8785 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8787 : 48              >            pha         ;use stack to load status
8788 : 28              >            plp
                        
8789 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
878a : 08              >            php         ;save flags
878b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
878d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
878f : 68              >            pla         ;load status
8790 : 48              >            pha
                       >            cmp_flag $ff-zero
8791 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8793 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8795 : 28              >            plp         ;restore status
                        
8796 : c8                       iny             ;00
                                tst_y 0,$ff-minus
8797 : 08              >            php         ;save flags
8798 : c000            >            cpy #0     ;test result
                       >            trap_ne
879a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
879c : 68              >            pla         ;load status
879d : 48              >            pha
                       >            cmp_flag $ff-minus
879e : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87a0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87a2 : 28              >            plp         ;restore status
                        
87a3 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
87a4 : 08              >            php         ;save flags
87a5 : c001            >            cpy #1     ;test result
                       >            trap_ne
87a7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87a9 : 68              >            pla         ;load status
87aa : 48              >            pha
                       >            cmp_flag $ff-minus-zero
87ab : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87ad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87af : 28              >            plp         ;restore status
                        
87b0 : 88                       dey             ;00
                                tst_y 0,$ff-minus
87b1 : 08              >            php         ;save flags
87b2 : c000            >            cpy #0     ;test result
                       >            trap_ne
87b4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87b6 : 68              >            pla         ;load status
87b7 : 48              >            pha
                       >            cmp_flag $ff-minus
87b8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87ba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87bc : 28              >            plp         ;restore status
                        
87bd : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
87be : 08              >            php         ;save flags
87bf : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
87c1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87c3 : 68              >            pla         ;load status
87c4 : 48              >            pha
                       >            cmp_flag $ff-zero
87c5 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87c7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87c9 : 28              >            plp         ;restore status
                        
87ca : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
87cb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
87cd : 48              >            pha         ;use stack to load status
87ce : 28              >            plp
                        
87cf : c8                       iny             ;ff
                                tst_y $ff,0+minus
87d0 : 08              >            php         ;save flags
87d1 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
87d3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87d5 : 68              >            pla         ;load status
87d6 : 48              >            pha
                       >            cmp_flag 0+minus
87d7 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87d9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87db : 28              >            plp         ;restore status
                        
87dc : c8                       iny             ;00
                                tst_y 0,zero
87dd : 08              >            php         ;save flags
87de : c000            >            cpy #0     ;test result
                       >            trap_ne
87e0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87e2 : 68              >            pla         ;load status
87e3 : 48              >            pha
                       >            cmp_flag zero
87e4 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87e6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87e8 : 28              >            plp         ;restore status
                        
87e9 : c8                       iny             ;01
                                tst_y 1,0
87ea : 08              >            php         ;save flags
87eb : c001            >            cpy #1     ;test result
                       >            trap_ne
87ed : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87ef : 68              >            pla         ;load status
87f0 : 48              >            pha
                       >            cmp_flag 0
87f1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87f3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87f5 : 28              >            plp         ;restore status
                        
87f6 : 88                       dey             ;00
                                tst_y 0,zero
87f7 : 08              >            php         ;save flags
87f8 : c000            >            cpy #0     ;test result
                       >            trap_ne
87fa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87fc : 68              >            pla         ;load status
87fd : 48              >            pha
                       >            cmp_flag zero
87fe : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8800 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8802 : 28              >            plp         ;restore status
                        
8803 : 88                       dey             ;ff
                                tst_y $ff,minus
8804 : 08              >            php         ;save flags
8805 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
8807 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8809 : 68              >            pla         ;load status
880a : 48              >            pha
                       >            cmp_flag minus
880b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
880d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
880f : 28              >            plp         ;restore status
                        
                                        
8810 : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
8812 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8814 : 48              >            pha         ;use stack to load status
8815 : 28              >            plp
                        
8816 : 8a                       txa
                                tst_a $ff,$ff-zero
8817 : 08              >            php         ;save flags
8818 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
881a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
881c : 68              >            pla         ;load status
881d : 48              >            pha
                       >            cmp_flag $ff-zero
881e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8820 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8822 : 28              >            plp         ;restore status
                        
8823 : 08                       php
8824 : e8                       inx             ;00
8825 : 28                       plp
8826 : 8a                       txa
                                tst_a 0,$ff-minus
8827 : 08              >            php         ;save flags
8828 : c900            >            cmp #0     ;test result
                       >            trap_ne
882a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
882c : 68              >            pla         ;load status
882d : 48              >            pha
                       >            cmp_flag $ff-minus
882e : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8830 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8832 : 28              >            plp         ;restore status
                        
8833 : 08                       php
8834 : e8                       inx             ;01
8835 : 28                       plp
8836 : 8a                       txa
                                tst_a 1,$ff-minus-zero
8837 : 08              >            php         ;save flags
8838 : c901            >            cmp #1     ;test result
                       >            trap_ne
883a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
883c : 68              >            pla         ;load status
883d : 48              >            pha
                       >            cmp_flag $ff-minus-zero
883e : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8840 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8842 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
8843 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8845 : 48              >            pha         ;use stack to load status
8846 : 28              >            plp
                        
8847 : 8a                       txa
                                tst_a 1,0
8848 : 08              >            php         ;save flags
8849 : c901            >            cmp #1     ;test result
                       >            trap_ne
884b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
884d : 68              >            pla         ;load status
884e : 48              >            pha
                       >            cmp_flag 0
884f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8851 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8853 : 28              >            plp         ;restore status
                        
8854 : 08                       php
8855 : ca                       dex             ;00
8856 : 28                       plp
8857 : 8a                       txa
                                tst_a 0,zero
8858 : 08              >            php         ;save flags
8859 : c900            >            cmp #0     ;test result
                       >            trap_ne
885b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
885d : 68              >            pla         ;load status
885e : 48              >            pha
                       >            cmp_flag zero
885f : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8861 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8863 : 28              >            plp         ;restore status
                        
8864 : 08                       php
8865 : ca                       dex             ;ff
8866 : 28                       plp
8867 : 8a                       txa
                                tst_a $ff,minus
8868 : 08              >            php         ;save flags
8869 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
886b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
886d : 68              >            pla         ;load status
886e : 48              >            pha
                       >            cmp_flag minus
886f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8871 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8873 : 28              >            plp         ;restore status
                        
                                                
8874 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
8876 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8878 : 48              >            pha         ;use stack to load status
8879 : 28              >            plp
                        
887a : 98                       tya
                                tst_a $ff,$ff-zero
887b : 08              >            php         ;save flags
887c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
887e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8880 : 68              >            pla         ;load status
8881 : 48              >            pha
                       >            cmp_flag $ff-zero
8882 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8884 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8886 : 28              >            plp         ;restore status
                        
8887 : 08                       php
8888 : c8                       iny             ;00
8889 : 28                       plp
888a : 98                       tya
                                tst_a 0,$ff-minus
888b : 08              >            php         ;save flags
888c : c900            >            cmp #0     ;test result
                       >            trap_ne
888e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8890 : 68              >            pla         ;load status
8891 : 48              >            pha
                       >            cmp_flag $ff-minus
8892 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8894 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8896 : 28              >            plp         ;restore status
                        
8897 : 08                       php
8898 : c8                       iny             ;01
8899 : 28                       plp
889a : 98                       tya
                                tst_a 1,$ff-minus-zero
889b : 08              >            php         ;save flags
889c : c901            >            cmp #1     ;test result
                       >            trap_ne
889e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88a0 : 68              >            pla         ;load status
88a1 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
88a2 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88a4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88a6 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
88a7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
88a9 : 48              >            pha         ;use stack to load status
88aa : 28              >            plp
                        
88ab : 98                       tya
                                tst_a 1,0
88ac : 08              >            php         ;save flags
88ad : c901            >            cmp #1     ;test result
                       >            trap_ne
88af : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88b1 : 68              >            pla         ;load status
88b2 : 48              >            pha
                       >            cmp_flag 0
88b3 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88b7 : 28              >            plp         ;restore status
                        
88b8 : 08                       php
88b9 : 88                       dey             ;00
88ba : 28                       plp
88bb : 98                       tya
                                tst_a 0,zero
88bc : 08              >            php         ;save flags
88bd : c900            >            cmp #0     ;test result
                       >            trap_ne
88bf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88c1 : 68              >            pla         ;load status
88c2 : 48              >            pha
                       >            cmp_flag zero
88c3 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88c7 : 28              >            plp         ;restore status
                        
88c8 : 08                       php
88c9 : 88                       dey             ;ff
88ca : 28                       plp
88cb : 98                       tya
                                tst_a $ff,minus
88cc : 08              >            php         ;save flags
88cd : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
88cf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88d1 : 68              >            pla         ;load status
88d2 : 48              >            pha
                       >            cmp_flag minus
88d3 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88d7 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
88d8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
88da : 48                       pha
88db : a2ff                     ldx #$ff        ;ff
88dd : 8a                       txa
88de : 28                       plp             
88df : a8                       tay
                                tst_y $ff,$ff-zero
88e0 : 08              >            php         ;save flags
88e1 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
88e3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88e5 : 68              >            pla         ;load status
88e6 : 48              >            pha
                       >            cmp_flag $ff-zero
88e7 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88e9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88eb : 28              >            plp         ;restore status
                        
88ec : 08                       php
88ed : e8                       inx             ;00
88ee : 8a                       txa
88ef : 28                       plp
88f0 : a8                       tay
                                tst_y 0,$ff-minus
88f1 : 08              >            php         ;save flags
88f2 : c000            >            cpy #0     ;test result
                       >            trap_ne
88f4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88f6 : 68              >            pla         ;load status
88f7 : 48              >            pha
                       >            cmp_flag $ff-minus
88f8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88fa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88fc : 28              >            plp         ;restore status
                        
88fd : 08                       php
88fe : e8                       inx             ;01
88ff : 8a                       txa
8900 : 28                       plp
8901 : a8                       tay
                                tst_y 1,$ff-minus-zero
8902 : 08              >            php         ;save flags
8903 : c001            >            cpy #1     ;test result
                       >            trap_ne
8905 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8907 : 68              >            pla         ;load status
8908 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
8909 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
890b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
890d : 28              >            plp         ;restore status
                        
                                load_flag 0
890e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
8910 : 48                       pha
8911 : a900                     lda #0
8913 : 8a                       txa
8914 : 28                       plp
8915 : a8                       tay
                                tst_y 1,0
8916 : 08              >            php         ;save flags
8917 : c001            >            cpy #1     ;test result
                       >            trap_ne
8919 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
891b : 68              >            pla         ;load status
891c : 48              >            pha
                       >            cmp_flag 0
891d : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
891f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8921 : 28              >            plp         ;restore status
                        
8922 : 08                       php
8923 : ca                       dex             ;00
8924 : 8a                       txa
8925 : 28                       plp
8926 : a8                       tay
                                tst_y 0,zero
8927 : 08              >            php         ;save flags
8928 : c000            >            cpy #0     ;test result
                       >            trap_ne
892a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
892c : 68              >            pla         ;load status
892d : 48              >            pha
                       >            cmp_flag zero
892e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8930 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8932 : 28              >            plp         ;restore status
                        
8933 : 08                       php
8934 : ca                       dex             ;ff
8935 : 8a                       txa
8936 : 28                       plp
8937 : a8                       tay
                                tst_y $ff,minus
8938 : 08              >            php         ;save flags
8939 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
893b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
893d : 68              >            pla         ;load status
893e : 48              >            pha
                       >            cmp_flag minus
893f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8941 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8943 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
8944 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
8946 : 48                       pha
8947 : a0ff                     ldy #$ff        ;ff
8949 : 98                       tya
894a : 28                       plp
894b : aa                       tax
                                tst_x $ff,$ff-zero
894c : 08              >            php         ;save flags
894d : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
894f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8951 : 68              >            pla         ;load status
8952 : 48              >            pha
                       >            cmp_flag $ff-zero
8953 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8955 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8957 : 28              >            plp         ;restore status
                        
8958 : 08                       php
8959 : c8                       iny             ;00
895a : 98                       tya
895b : 28                       plp
895c : aa                       tax
                                tst_x 0,$ff-minus
895d : 08              >            php         ;save flags
895e : e000            >            cpx #0     ;test result
                       >            trap_ne
8960 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8962 : 68              >            pla         ;load status
8963 : 48              >            pha
                       >            cmp_flag $ff-minus
8964 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8966 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8968 : 28              >            plp         ;restore status
                        
8969 : 08                       php
896a : c8                       iny             ;01
896b : 98                       tya
896c : 28                       plp
896d : aa                       tax
                                tst_x 1,$ff-minus-zero
896e : 08              >            php         ;save flags
896f : e001            >            cpx #1     ;test result
                       >            trap_ne
8971 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8973 : 68              >            pla         ;load status
8974 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
8975 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8977 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8979 : 28              >            plp         ;restore status
                        
                                load_flag 0
897a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
897c : 48                       pha
897d : a900                     lda #0          ;preset status
897f : 98                       tya
8980 : 28                       plp
8981 : aa                       tax
                                tst_x 1,0
8982 : 08              >            php         ;save flags
8983 : e001            >            cpx #1     ;test result
                       >            trap_ne
8985 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8987 : 68              >            pla         ;load status
8988 : 48              >            pha
                       >            cmp_flag 0
8989 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
898b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
898d : 28              >            plp         ;restore status
                        
898e : 08                       php
898f : 88                       dey             ;00
8990 : 98                       tya
8991 : 28                       plp
8992 : aa                       tax
                                tst_x 0,zero
8993 : 08              >            php         ;save flags
8994 : e000            >            cpx #0     ;test result
                       >            trap_ne
8996 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8998 : 68              >            pla         ;load status
8999 : 48              >            pha
                       >            cmp_flag zero
899a : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
899c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
899e : 28              >            plp         ;restore status
                        
899f : 08                       php
89a0 : 88                       dey             ;ff
89a1 : 98                       tya
89a2 : 28                       plp
89a3 : aa                       tax
                                tst_x $ff,minus
89a4 : 08              >            php         ;save flags
89a5 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
89a7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
89a9 : 68              >            pla         ;load status
89aa : 48              >            pha
                       >            cmp_flag minus
89ab : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
89ad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
89af : 28              >            plp         ;restore status
                        
                                next_test
89b0 : ad0002          >            lda test_case   ;previous test
89b3 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
89b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
89b7 : a90e            >            lda #test_num   ;*** next tests' number
89b9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
89bc : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
89be : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
89c0 : 48              >            pha         ;use stack to load status
89c1 : 28              >            plp
                        
89c2 : 9a                       txs
89c3 : 08                       php
89c4 : ad0101                   lda $101
                                cmp_flag $ff
89c7 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89c9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
89cb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
89cd : 48              >            pha         ;use stack to load status
89ce : 28              >            plp
                        
89cf : 9a                       txs
89d0 : 08                       php
89d1 : ad0101                   lda $101
                                cmp_flag 0
89d4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89d6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
89d8 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
89d9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
89db : 48              >            pha         ;use stack to load status
89dc : 28              >            plp
                        
89dd : 9a                       txs
89de : 08                       php
89df : ad0001                   lda $100
                                cmp_flag $ff
89e2 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89e4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
89e6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
89e8 : 48              >            pha         ;use stack to load status
89e9 : 28              >            plp
                        
89ea : 9a                       txs
89eb : 08                       php
89ec : ad0001                   lda $100
                                cmp_flag 0
89ef : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89f1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
89f3 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
89f4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
89f6 : 48              >            pha         ;use stack to load status
89f7 : 28              >            plp
                        
89f8 : 9a                       txs
89f9 : 08                       php
89fa : adff01                   lda $1ff
                                cmp_flag $ff
89fd : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89ff : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8a01 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a03 : 48              >            pha         ;use stack to load status
8a04 : 28              >            plp
                        
8a05 : 9a                       txs
8a06 : 08                       php
8a07 : adff01                   lda $1ff
                                cmp_flag 0
8a0a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
8a0c : a201                     ldx #1
8a0e : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
8a0f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8a11 : 48              >            pha         ;use stack to load status
8a12 : 28              >            plp
                        
8a13 : ba                       tsx             ;clears Z, N
8a14 : 08                       php             ;sp=00
8a15 : e001                     cpx #1
                                trap_ne
8a17 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a19 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
8a1c : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a1e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8a20 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8a22 : 48              >            pha         ;use stack to load status
8a23 : 28              >            plp
                        
8a24 : ba                       tsx             ;clears N, sets Z
8a25 : 08                       php             ;sp=ff
8a26 : e000                     cpx #0
                                trap_ne
8a28 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a2a : ad0001                   lda $100
                                cmp_flag $ff-minus
8a2d : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a2f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8a31 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8a33 : 48              >            pha         ;use stack to load status
8a34 : 28              >            plp
                        
8a35 : ba                       tsx             ;clears N, sets Z
8a36 : 08                       php             ;sp=fe
8a37 : e0ff                     cpx #$ff
                                trap_ne
8a39 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a3b : adff01                   lda $1ff
                                cmp_flag $ff-zero
8a3e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a40 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
8a42 : a201                     ldx #1
8a44 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
8a45 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a47 : 48              >            pha         ;use stack to load status
8a48 : 28              >            plp
                        
8a49 : ba                       tsx             ;clears Z, N
8a4a : 08                       php             ;sp=00
8a4b : e001                     cpx #1
                                trap_ne
8a4d : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a4f : ad0101                   lda $101
                                cmp_flag 0
8a52 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a54 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8a56 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a58 : 48              >            pha         ;use stack to load status
8a59 : 28              >            plp
                        
8a5a : ba                       tsx             ;clears N, sets Z
8a5b : 08                       php             ;sp=ff
8a5c : e000                     cpx #0
                                trap_ne
8a5e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a60 : ad0001                   lda $100
                                cmp_flag zero
8a63 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a65 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8a67 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a69 : 48              >            pha         ;use stack to load status
8a6a : 28              >            plp
                        
8a6b : ba                       tsx             ;clears N, sets Z
8a6c : 08                       php             ;sp=fe
8a6d : e0ff                     cpx #$ff
                                trap_ne
8a6f : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a71 : adff01                   lda $1ff
                                cmp_flag minus
8a74 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a76 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a78 : 68                       pla             ;sp=ff
                                next_test
8a79 : ad0002          >            lda test_case   ;previous test
8a7c : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8a7e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
8a80 : a90f            >            lda #test_num   ;*** next tests' number
8a82 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
8a85 : a003                     ldy #3
8a87 :                  tldx    
                                set_stat 0
                       >            load_flag 0
8a87 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a89 : 48              >            pha         ;use stack to load status
8a8a : 28              >            plp
                        
8a8b : b60b                     ldx zp1,y
8a8d : 08                       php         ;test stores do not alter flags
8a8e : 8a                       txa
8a8f : 49c3                     eor #$c3
8a91 : 28                       plp
8a92 : 990302                   sta abst,y
8a95 : 08                       php         ;flags after load/store sequence
8a96 : 49c3                     eor #$c3
8a98 : d91802                   cmp abs1,y  ;test result
                                trap_ne
8a9b : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a9d : 68                       pla         ;load status
                                eor_flag 0
8a9e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8aa0 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
8aa3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8aa5 : 88                       dey
8aa6 : 10df                     bpl tldx                  
                        
8aa8 : a003                     ldy #3
8aaa :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
8aaa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8aac : 48              >            pha         ;use stack to load status
8aad : 28              >            plp
                        
8aae : b60b                     ldx zp1,y
8ab0 : 08                       php         ;test stores do not alter flags
8ab1 : 8a                       txa
8ab2 : 49c3                     eor #$c3
8ab4 : 28                       plp
8ab5 : 990302                   sta abst,y
8ab8 : 08                       php         ;flags after load/store sequence
8ab9 : 49c3                     eor #$c3
8abb : d91802                   cmp abs1,y  ;test result
                                trap_ne
8abe : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ac0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8ac1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8ac3 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
8ac6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ac8 : 88                       dey
8ac9 : 10df                     bpl tldx1                  
                        
8acb : a003                     ldy #3
8acd :                  tldx2   
                                set_stat 0
                       >            load_flag 0
8acd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8acf : 48              >            pha         ;use stack to load status
8ad0 : 28              >            plp
                        
8ad1 : be1802                   ldx abs1,y
8ad4 : 08                       php         ;test stores do not alter flags
8ad5 : 8a                       txa
8ad6 : 49c3                     eor #$c3
8ad8 : aa                       tax
8ad9 : 28                       plp
8ada : 9602                     stx zpt,y
8adc : 08                       php         ;flags after load/store sequence
8add : 49c3                     eor #$c3
8adf : d90b00                   cmp zp1,y   ;test result
                                trap_ne
8ae2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ae4 : 68                       pla         ;load status
                                eor_flag 0
8ae5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8ae7 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
8aea : d0fe            >        bne *         ;failed not equal (non zero)
                        
8aec : 88                       dey
8aed : 10de                     bpl tldx2                  
                        
8aef : a003                     ldy #3
8af1 :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
8af1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8af3 : 48              >            pha         ;use stack to load status
8af4 : 28              >            plp
                        
8af5 : be1802                   ldx abs1,y
8af8 : 08                       php         ;test stores do not alter flags
8af9 : 8a                       txa
8afa : 49c3                     eor #$c3
8afc : aa                       tax
8afd : 28                       plp
8afe : 9602                     stx zpt,y
8b00 : 08                       php         ;flags after load/store sequence
8b01 : 49c3                     eor #$c3
8b03 : d90b00                   cmp zp1,y   ;test result
                                trap_ne
8b06 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b08 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8b09 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8b0b : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
8b0e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b10 : 88                       dey
8b11 : 10de                     bpl tldx3
                                
8b13 : a003                     ldy #3      ;testing store result
8b15 : a200                     ldx #0
8b17 : b90200           tstx    lda zpt,y
8b1a : 49c3                     eor #$c3
8b1c : d90b00                   cmp zp1,y
                                trap_ne     ;store to zp data
8b1f : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b21 : 9602                     stx zpt,y   ;clear                
8b23 : b90302                   lda abst,y
8b26 : 49c3                     eor #$c3
8b28 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
8b2b : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b2d : 8a                       txa
8b2e : 990302                   sta abst,y  ;clear                
8b31 : 88                       dey
8b32 : 10e3                     bpl tstx
                                next_test
8b34 : ad0002          >            lda test_case   ;previous test
8b37 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8b39 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
8b3b : a910            >            lda #test_num   ;*** next tests' number
8b3d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
8b40 : a0fd                     ldy #3+$fa
8b42 : b611             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
8b44 : 8a                       txa
8b45 : 990901                   sta abst-$fa,y      ;no STX abs,y!
8b48 : 88                       dey
8b49 : c0fa                     cpy #$fa
8b4b : b0f5                     bcs tldx4                  
8b4d : a0fd                     ldy #3+$fa
8b4f : be1e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
8b52 : 9608                     stx zpt-$fa&$ff,y
8b54 : 88                       dey
8b55 : c0fa                     cpy #$fa
8b57 : b0f6                     bcs tldx5                  
8b59 : a003                     ldy #3      ;testing wraparound result
8b5b : a200                     ldx #0
8b5d : b90200           tstx1   lda zpt,y
8b60 : d90b00                   cmp zp1,y
                                trap_ne     ;store to zp data
8b63 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b65 : 9602                     stx zpt,y   ;clear                
8b67 : b90302                   lda abst,y
8b6a : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
8b6d : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b6f : 8a                       txa
8b70 : 990302                   sta abst,y  ;clear                
8b73 : 88                       dey
8b74 : 10e7                     bpl tstx1
                                next_test
8b76 : ad0002          >            lda test_case   ;previous test
8b79 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8b7b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
8b7d : a911            >            lda #test_num   ;*** next tests' number
8b7f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
8b82 : a203                     ldx #3
8b84 :                  tldy    
                                set_stat 0
                       >            load_flag 0
8b84 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8b86 : 48              >            pha         ;use stack to load status
8b87 : 28              >            plp
                        
8b88 : b40b                     ldy zp1,x
8b8a : 08                       php         ;test stores do not alter flags
8b8b : 98                       tya
8b8c : 49c3                     eor #$c3
8b8e : 28                       plp
8b8f : 9d0302                   sta abst,x
8b92 : 08                       php         ;flags after load/store sequence
8b93 : 49c3                     eor #$c3
8b95 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
8b98 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b9a : 68                       pla         ;load status
                                eor_flag 0
8b9b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8b9d : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
8ba0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ba2 : ca                       dex
8ba3 : 10df                     bpl tldy                  
                        
8ba5 : a203                     ldx #3
8ba7 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
8ba7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8ba9 : 48              >            pha         ;use stack to load status
8baa : 28              >            plp
                        
8bab : b40b                     ldy zp1,x
8bad : 08                       php         ;test stores do not alter flags
8bae : 98                       tya
8baf : 49c3                     eor #$c3
8bb1 : 28                       plp
8bb2 : 9d0302                   sta abst,x
8bb5 : 08                       php         ;flags after load/store sequence
8bb6 : 49c3                     eor #$c3
8bb8 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
8bbb : d0fe            >        bne *         ;failed not equal (non zero)
                        
8bbd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8bbe : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8bc0 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
8bc3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8bc5 : ca                       dex
8bc6 : 10df                     bpl tldy1                  
                        
8bc8 : a203                     ldx #3
8bca :                  tldy2   
                                set_stat 0
                       >            load_flag 0
8bca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8bcc : 48              >            pha         ;use stack to load status
8bcd : 28              >            plp
                        
8bce : bc1802                   ldy abs1,x
8bd1 : 08                       php         ;test stores do not alter flags
8bd2 : 98                       tya
8bd3 : 49c3                     eor #$c3
8bd5 : a8                       tay
8bd6 : 28                       plp
8bd7 : 9402                     sty zpt,x
8bd9 : 08                       php         ;flags after load/store sequence
8bda : 49c3                     eor #$c3
8bdc : d50b                     cmp zp1,x   ;test result
                                trap_ne
8bde : d0fe            >        bne *         ;failed not equal (non zero)
                        
8be0 : 68                       pla         ;load status
                                eor_flag 0
8be1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8be3 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
8be6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8be8 : ca                       dex
8be9 : 10df                     bpl tldy2                  
                        
8beb : a203                     ldx #3
8bed :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
8bed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8bef : 48              >            pha         ;use stack to load status
8bf0 : 28              >            plp
                        
8bf1 : bc1802                   ldy abs1,x
8bf4 : 08                       php         ;test stores do not alter flags
8bf5 : 98                       tya
8bf6 : 49c3                     eor #$c3
8bf8 : a8                       tay
8bf9 : 28                       plp
8bfa : 9402                     sty zpt,x
8bfc : 08                       php         ;flags after load/store sequence
8bfd : 49c3                     eor #$c3
8bff : d50b                     cmp zp1,x   ;test result
                                trap_ne
8c01 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c03 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8c04 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8c06 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
8c09 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c0b : ca                       dex
8c0c : 10df                     bpl tldy3
                        
8c0e : a203                     ldx #3      ;testing store result
8c10 : a000                     ldy #0
8c12 : b502             tsty    lda zpt,x
8c14 : 49c3                     eor #$c3
8c16 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
8c18 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c1a : 9402                     sty zpt,x   ;clear                
8c1c : bd0302                   lda abst,x
8c1f : 49c3                     eor #$c3
8c21 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
8c24 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c26 : 8a                       txa
8c27 : 9d0302                   sta abst,x  ;clear                
8c2a : ca                       dex
8c2b : 10e5                     bpl tsty
                                next_test
8c2d : ad0002          >            lda test_case   ;previous test
8c30 : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8c32 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
8c34 : a912            >            lda #test_num   ;*** next tests' number
8c36 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
8c39 : a2fd                     ldx #3+$fa
8c3b : b411             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
8c3d : 98                       tya
8c3e : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
8c41 : ca                       dex
8c42 : e0fa                     cpx #$fa
8c44 : b0f5                     bcs tldy4                  
8c46 : a2fd                     ldx #3+$fa
8c48 : bc1e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
8c4b : 9408                     sty zpt-$fa&$ff,x
8c4d : ca                       dex
8c4e : e0fa                     cpx #$fa
8c50 : b0f6                     bcs tldy5                  
8c52 : a203                     ldx #3      ;testing wraparound result
8c54 : a000                     ldy #0
8c56 : b502             tsty1   lda zpt,x
8c58 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
8c5a : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c5c : 9402                     sty zpt,x   ;clear                
8c5e : bd0302                   lda abst,x
8c61 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
8c64 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c66 : 8a                       txa
8c67 : 9d0302                   sta abst,x  ;clear                
8c6a : ca                       dex
8c6b : 10e9                     bpl tsty1
                                next_test
8c6d : ad0002          >            lda test_case   ;previous test
8c70 : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8c72 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
8c74 : a913            >            lda #test_num   ;*** next tests' number
8c76 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
8c79 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
8c7b : 48              >            pha         ;use stack to load status
8c7c : 28              >            plp
                        
8c7d : a60b                     ldx zp1
8c7f : 08                       php         ;test stores do not alter flags
8c80 : 8a                       txa
8c81 : 49c3                     eor #$c3
8c83 : aa                       tax
8c84 : 28                       plp
8c85 : 8e0302                   stx abst
8c88 : 08                       php         ;flags after load/store sequence
8c89 : 49c3                     eor #$c3
8c8b : aa                       tax
8c8c : e0c3                     cpx #$c3    ;test result
                                trap_ne
8c8e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c90 : 68                       pla         ;load status
                                eor_flag 0
8c91 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8c93 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8c96 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8c98 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8c9a : 48              >            pha         ;use stack to load status
8c9b : 28              >            plp
                        
8c9c : a60c                     ldx zp1+1
8c9e : 08                       php         ;test stores do not alter flags
8c9f : 8a                       txa
8ca0 : 49c3                     eor #$c3
8ca2 : aa                       tax
8ca3 : 28                       plp
8ca4 : 8e0402                   stx abst+1
8ca7 : 08                       php         ;flags after load/store sequence
8ca8 : 49c3                     eor #$c3
8caa : aa                       tax
8cab : e082                     cpx #$82    ;test result
                                trap_ne
8cad : d0fe            >        bne *         ;failed not equal (non zero)
                        
8caf : 68                       pla         ;load status
                                eor_flag 0
8cb0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8cb2 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8cb5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8cb7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8cb9 : 48              >            pha         ;use stack to load status
8cba : 28              >            plp
                        
8cbb : a60d                     ldx zp1+2
8cbd : 08                       php         ;test stores do not alter flags
8cbe : 8a                       txa
8cbf : 49c3                     eor #$c3
8cc1 : aa                       tax
8cc2 : 28                       plp
8cc3 : 8e0502                   stx abst+2
8cc6 : 08                       php         ;flags after load/store sequence
8cc7 : 49c3                     eor #$c3
8cc9 : aa                       tax
8cca : e041                     cpx #$41    ;test result
                                trap_ne
8ccc : d0fe            >        bne *         ;failed not equal (non zero)
                        
8cce : 68                       pla         ;load status
                                eor_flag 0
8ccf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8cd1 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8cd4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8cd6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8cd8 : 48              >            pha         ;use stack to load status
8cd9 : 28              >            plp
                        
8cda : a60e                     ldx zp1+3
8cdc : 08                       php         ;test stores do not alter flags
8cdd : 8a                       txa
8cde : 49c3                     eor #$c3
8ce0 : aa                       tax
8ce1 : 28                       plp
8ce2 : 8e0602                   stx abst+3
8ce5 : 08                       php         ;flags after load/store sequence
8ce6 : 49c3                     eor #$c3
8ce8 : aa                       tax
8ce9 : e000                     cpx #0      ;test result
                                trap_ne
8ceb : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ced : 68                       pla         ;load status
                                eor_flag 0
8cee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8cf0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8cf3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
8cf5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8cf7 : 48              >            pha         ;use stack to load status
8cf8 : 28              >            plp
                        
8cf9 : a60b                     ldx zp1  
8cfb : 08                       php         ;test stores do not alter flags
8cfc : 8a                       txa
8cfd : 49c3                     eor #$c3
8cff : aa                       tax
8d00 : 28                       plp
8d01 : 8e0302                   stx abst  
8d04 : 08                       php         ;flags after load/store sequence
8d05 : 49c3                     eor #$c3
8d07 : aa                       tax
8d08 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
8d0a : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d0c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8d0d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8d0f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8d12 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8d14 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8d16 : 48              >            pha         ;use stack to load status
8d17 : 28              >            plp
                        
8d18 : a60c                     ldx zp1+1
8d1a : 08                       php         ;test stores do not alter flags
8d1b : 8a                       txa
8d1c : 49c3                     eor #$c3
8d1e : aa                       tax
8d1f : 28                       plp
8d20 : 8e0402                   stx abst+1
8d23 : 08                       php         ;flags after load/store sequence
8d24 : 49c3                     eor #$c3
8d26 : aa                       tax
8d27 : e082                     cpx #$82    ;test result
                                trap_ne
8d29 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d2b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8d2c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8d2e : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8d31 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8d33 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8d35 : 48              >            pha         ;use stack to load status
8d36 : 28              >            plp
                        
8d37 : a60d                     ldx zp1+2
8d39 : 08                       php         ;test stores do not alter flags
8d3a : 8a                       txa
8d3b : 49c3                     eor #$c3
8d3d : aa                       tax
8d3e : 28                       plp
8d3f : 8e0502                   stx abst+2
8d42 : 08                       php         ;flags after load/store sequence
8d43 : 49c3                     eor #$c3
8d45 : aa                       tax
8d46 : e041                     cpx #$41    ;test result
                                trap_ne     ;
8d48 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d4a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8d4b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8d4d : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8d50 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8d52 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8d54 : 48              >            pha         ;use stack to load status
8d55 : 28              >            plp
                        
8d56 : a60e                     ldx zp1+3
8d58 : 08                       php         ;test stores do not alter flags
8d59 : 8a                       txa
8d5a : 49c3                     eor #$c3
8d5c : aa                       tax
8d5d : 28                       plp
8d5e : 8e0602                   stx abst+3
8d61 : 08                       php         ;flags after load/store sequence
8d62 : 49c3                     eor #$c3
8d64 : aa                       tax
8d65 : e000                     cpx #0      ;test result
                                trap_ne
8d67 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d69 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8d6a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8d6c : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8d6f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
8d71 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8d73 : 48              >            pha         ;use stack to load status
8d74 : 28              >            plp
                        
8d75 : ae1802                   ldx abs1  
8d78 : 08                       php         ;test stores do not alter flags
8d79 : 8a                       txa
8d7a : 49c3                     eor #$c3
8d7c : aa                       tax
8d7d : 28                       plp
8d7e : 8602                     stx zpt  
8d80 : 08                       php         ;flags after load/store sequence
8d81 : 49c3                     eor #$c3
8d83 : c50b                     cmp zp1     ;test result
                                trap_ne
8d85 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d87 : 68                       pla         ;load status
                                eor_flag 0
8d88 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8d8a : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8d8d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8d8f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8d91 : 48              >            pha         ;use stack to load status
8d92 : 28              >            plp
                        
8d93 : ae1902                   ldx abs1+1
8d96 : 08                       php         ;test stores do not alter flags
8d97 : 8a                       txa
8d98 : 49c3                     eor #$c3
8d9a : aa                       tax
8d9b : 28                       plp
8d9c : 8603                     stx zpt+1
8d9e : 08                       php         ;flags after load/store sequence
8d9f : 49c3                     eor #$c3
8da1 : c50c                     cmp zp1+1   ;test result
                                trap_ne
8da3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8da5 : 68                       pla         ;load status
                                eor_flag 0
8da6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8da8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8dab : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8dad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8daf : 48              >            pha         ;use stack to load status
8db0 : 28              >            plp
                        
8db1 : ae1a02                   ldx abs1+2
8db4 : 08                       php         ;test stores do not alter flags
8db5 : 8a                       txa
8db6 : 49c3                     eor #$c3
8db8 : aa                       tax
8db9 : 28                       plp
8dba : 8604                     stx zpt+2
8dbc : 08                       php         ;flags after load/store sequence
8dbd : 49c3                     eor #$c3
8dbf : c50d                     cmp zp1+2   ;test result
                                trap_ne
8dc1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8dc3 : 68                       pla         ;load status
                                eor_flag 0
8dc4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8dc6 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8dc9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8dcb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8dcd : 48              >            pha         ;use stack to load status
8dce : 28              >            plp
                        
8dcf : ae1b02                   ldx abs1+3
8dd2 : 08                       php         ;test stores do not alter flags
8dd3 : 8a                       txa
8dd4 : 49c3                     eor #$c3
8dd6 : aa                       tax
8dd7 : 28                       plp
8dd8 : 8605                     stx zpt+3
8dda : 08                       php         ;flags after load/store sequence
8ddb : 49c3                     eor #$c3
8ddd : c50e                     cmp zp1+3   ;test result
                                trap_ne
8ddf : d0fe            >        bne *         ;failed not equal (non zero)
                        
8de1 : 68                       pla         ;load status
                                eor_flag 0
8de2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8de4 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8de7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
8de9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8deb : 48              >            pha         ;use stack to load status
8dec : 28              >            plp
                        
8ded : ae1802                   ldx abs1  
8df0 : 08                       php         ;test stores do not alter flags
8df1 : 8a                       txa
8df2 : 49c3                     eor #$c3
8df4 : aa                       tax
8df5 : 28                       plp
8df6 : 8602                     stx zpt  
8df8 : 08                       php         ;flags after load/store sequence
8df9 : 49c3                     eor #$c3
8dfb : aa                       tax
8dfc : e40b                     cpx zp1     ;test result
                                trap_ne
8dfe : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e00 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8e01 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8e03 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8e06 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8e08 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8e0a : 48              >            pha         ;use stack to load status
8e0b : 28              >            plp
                        
8e0c : ae1902                   ldx abs1+1
8e0f : 08                       php         ;test stores do not alter flags
8e10 : 8a                       txa
8e11 : 49c3                     eor #$c3
8e13 : aa                       tax
8e14 : 28                       plp
8e15 : 8603                     stx zpt+1
8e17 : 08                       php         ;flags after load/store sequence
8e18 : 49c3                     eor #$c3
8e1a : aa                       tax
8e1b : e40c                     cpx zp1+1   ;test result
                                trap_ne
8e1d : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e1f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8e20 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8e22 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8e25 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8e27 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8e29 : 48              >            pha         ;use stack to load status
8e2a : 28              >            plp
                        
8e2b : ae1a02                   ldx abs1+2
8e2e : 08                       php         ;test stores do not alter flags
8e2f : 8a                       txa
8e30 : 49c3                     eor #$c3
8e32 : aa                       tax
8e33 : 28                       plp
8e34 : 8604                     stx zpt+2
8e36 : 08                       php         ;flags after load/store sequence
8e37 : 49c3                     eor #$c3
8e39 : aa                       tax
8e3a : e40d                     cpx zp1+2   ;test result
                                trap_ne
8e3c : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e3e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8e3f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8e41 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8e44 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8e46 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8e48 : 48              >            pha         ;use stack to load status
8e49 : 28              >            plp
                        
8e4a : ae1b02                   ldx abs1+3
8e4d : 08                       php         ;test stores do not alter flags
8e4e : 8a                       txa
8e4f : 49c3                     eor #$c3
8e51 : aa                       tax
8e52 : 28                       plp
8e53 : 8605                     stx zpt+3
8e55 : 08                       php         ;flags after load/store sequence
8e56 : 49c3                     eor #$c3
8e58 : aa                       tax
8e59 : e40e                     cpx zp1+3   ;test result
                                trap_ne
8e5b : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e5d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8e5e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8e60 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8e63 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
8e65 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
8e67 : 48              >            pha         ;use stack to load status
8e68 : 28              >            plp
                        
8e69 : a2c3                     ldx #$c3
8e6b : 08                       php
8e6c : ec1802                   cpx abs1    ;test result
                                trap_ne
8e6f : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e71 : 68                       pla         ;load status
                                eor_flag 0
8e72 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8e74 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8e77 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8e79 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8e7b : 48              >            pha         ;use stack to load status
8e7c : 28              >            plp
                        
8e7d : a282                     ldx #$82
8e7f : 08                       php
8e80 : ec1902                   cpx abs1+1  ;test result
                                trap_ne
8e83 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e85 : 68                       pla         ;load status
                                eor_flag 0
8e86 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8e88 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8e8b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8e8d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8e8f : 48              >            pha         ;use stack to load status
8e90 : 28              >            plp
                        
8e91 : a241                     ldx #$41
8e93 : 08                       php
8e94 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
8e97 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e99 : 68                       pla         ;load status
                                eor_flag 0
8e9a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8e9c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8e9f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8ea1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8ea3 : 48              >            pha         ;use stack to load status
8ea4 : 28              >            plp
                        
8ea5 : a200                     ldx #0
8ea7 : 08                       php
8ea8 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
8eab : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ead : 68                       pla         ;load status
                                eor_flag 0
8eae : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8eb0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8eb3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
8eb5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8eb7 : 48              >            pha         ;use stack to load status
8eb8 : 28              >            plp
                        
8eb9 : a2c3                     ldx #$c3  
8ebb : 08                       php
8ebc : ec1802                   cpx abs1    ;test result
                                trap_ne
8ebf : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ec1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8ec2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8ec4 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8ec7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8ec9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8ecb : 48              >            pha         ;use stack to load status
8ecc : 28              >            plp
                        
8ecd : a282                     ldx #$82
8ecf : 08                       php
8ed0 : ec1902                   cpx abs1+1  ;test result
                                trap_ne
8ed3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ed5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8ed6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8ed8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8edb : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8edd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8edf : 48              >            pha         ;use stack to load status
8ee0 : 28              >            plp
                        
8ee1 : a241                     ldx #$41
8ee3 : 08                       php
8ee4 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
8ee7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ee9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8eea : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8eec : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8eef : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8ef1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8ef3 : 48              >            pha         ;use stack to load status
8ef4 : 28              >            plp
                        
8ef5 : a200                     ldx #0
8ef7 : 08                       php
8ef8 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
8efb : d0fe            >        bne *         ;failed not equal (non zero)
                        
8efd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8efe : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8f00 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8f03 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
8f05 : a200                     ldx #0
8f07 : a502                     lda zpt  
8f09 : 49c3                     eor #$c3
8f0b : c50b                     cmp zp1  
                                trap_ne     ;store to zp data
8f0d : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f0f : 8602                     stx zpt     ;clear                
8f11 : ad0302                   lda abst  
8f14 : 49c3                     eor #$c3
8f16 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
8f19 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f1b : 8e0302                   stx abst    ;clear                
8f1e : a503                     lda zpt+1
8f20 : 49c3                     eor #$c3
8f22 : c50c                     cmp zp1+1
                                trap_ne     ;store to zp data
8f24 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f26 : 8603                     stx zpt+1   ;clear                
8f28 : ad0402                   lda abst+1
8f2b : 49c3                     eor #$c3
8f2d : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
8f30 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f32 : 8e0402                   stx abst+1  ;clear                
8f35 : a504                     lda zpt+2
8f37 : 49c3                     eor #$c3
8f39 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp data
8f3b : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f3d : 8604                     stx zpt+2   ;clear                
8f3f : ad0502                   lda abst+2
8f42 : 49c3                     eor #$c3
8f44 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
8f47 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f49 : 8e0502                   stx abst+2  ;clear                
8f4c : a505                     lda zpt+3
8f4e : 49c3                     eor #$c3
8f50 : c50e                     cmp zp1+3
                                trap_ne     ;store to zp data
8f52 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f54 : 8605                     stx zpt+3   ;clear                
8f56 : ad0602                   lda abst+3
8f59 : 49c3                     eor #$c3
8f5b : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
8f5e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f60 : 8e0602                   stx abst+3  ;clear                
                                next_test
8f63 : ad0002          >            lda test_case   ;previous test
8f66 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8f68 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
8f6a : a914            >            lda #test_num   ;*** next tests' number
8f6c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
8f6f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8f71 : 48              >            pha         ;use stack to load status
8f72 : 28              >            plp
                        
8f73 : a40b                     ldy zp1  
8f75 : 08                       php         ;test stores do not alter flags
8f76 : 98                       tya
8f77 : 49c3                     eor #$c3
8f79 : a8                       tay
8f7a : 28                       plp
8f7b : 8c0302                   sty abst  
8f7e : 08                       php         ;flags after load/store sequence
8f7f : 49c3                     eor #$c3
8f81 : a8                       tay
8f82 : c0c3                     cpy #$c3    ;test result
                                trap_ne
8f84 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f86 : 68                       pla         ;load status
                                eor_flag 0
8f87 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8f89 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8f8c : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8f8e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8f90 : 48              >            pha         ;use stack to load status
8f91 : 28              >            plp
                        
8f92 : a40c                     ldy zp1+1
8f94 : 08                       php         ;test stores do not alter flags
8f95 : 98                       tya
8f96 : 49c3                     eor #$c3
8f98 : a8                       tay
8f99 : 28                       plp
8f9a : 8c0402                   sty abst+1
8f9d : 08                       php         ;flags after load/store sequence
8f9e : 49c3                     eor #$c3
8fa0 : a8                       tay
8fa1 : c082                     cpy #$82    ;test result
                                trap_ne
8fa3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8fa5 : 68                       pla         ;load status
                                eor_flag 0
8fa6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8fa8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8fab : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8fad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8faf : 48              >            pha         ;use stack to load status
8fb0 : 28              >            plp
                        
8fb1 : a40d                     ldy zp1+2
8fb3 : 08                       php         ;test stores do not alter flags
8fb4 : 98                       tya
8fb5 : 49c3                     eor #$c3
8fb7 : a8                       tay
8fb8 : 28                       plp
8fb9 : 8c0502                   sty abst+2
8fbc : 08                       php         ;flags after load/store sequence
8fbd : 49c3                     eor #$c3
8fbf : a8                       tay
8fc0 : c041                     cpy #$41    ;test result
                                trap_ne
8fc2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8fc4 : 68                       pla         ;load status
                                eor_flag 0
8fc5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8fc7 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8fca : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8fcc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8fce : 48              >            pha         ;use stack to load status
8fcf : 28              >            plp
                        
8fd0 : a40e                     ldy zp1+3
8fd2 : 08                       php         ;test stores do not alter flags
8fd3 : 98                       tya
8fd4 : 49c3                     eor #$c3
8fd6 : a8                       tay
8fd7 : 28                       plp
8fd8 : 8c0602                   sty abst+3
8fdb : 08                       php         ;flags after load/store sequence
8fdc : 49c3                     eor #$c3
8fde : a8                       tay
8fdf : c000                     cpy #0      ;test result
                                trap_ne
8fe1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8fe3 : 68                       pla         ;load status
                                eor_flag 0
8fe4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8fe6 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8fe9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
8feb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8fed : 48              >            pha         ;use stack to load status
8fee : 28              >            plp
                        
8fef : a40b                     ldy zp1  
8ff1 : 08                       php         ;test stores do not alter flags
8ff2 : 98                       tya
8ff3 : 49c3                     eor #$c3
8ff5 : a8                       tay
8ff6 : 28                       plp
8ff7 : 8c0302                   sty abst  
8ffa : 08                       php         ;flags after load/store sequence
8ffb : 49c3                     eor #$c3
8ffd : a8                       tay
8ffe : c0c3                     cpy #$c3    ;test result
                                trap_ne
9000 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9002 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9003 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9005 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
9008 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
900a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
900c : 48              >            pha         ;use stack to load status
900d : 28              >            plp
                        
900e : a40c                     ldy zp1+1
9010 : 08                       php         ;test stores do not alter flags
9011 : 98                       tya
9012 : 49c3                     eor #$c3
9014 : a8                       tay
9015 : 28                       plp
9016 : 8c0402                   sty abst+1
9019 : 08                       php         ;flags after load/store sequence
901a : 49c3                     eor #$c3
901c : a8                       tay
901d : c082                     cpy #$82   ;test result
                                trap_ne
901f : d0fe            >        bne *         ;failed not equal (non zero)
                        
9021 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9022 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9024 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
9027 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9029 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
902b : 48              >            pha         ;use stack to load status
902c : 28              >            plp
                        
902d : a40d                     ldy zp1+2
902f : 08                       php         ;test stores do not alter flags
9030 : 98                       tya
9031 : 49c3                     eor #$c3
9033 : a8                       tay
9034 : 28                       plp
9035 : 8c0502                   sty abst+2
9038 : 08                       php         ;flags after load/store sequence
9039 : 49c3                     eor #$c3
903b : a8                       tay
903c : c041                     cpy #$41    ;test result
                                trap_ne
903e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9040 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9041 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9043 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
9046 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9048 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
904a : 48              >            pha         ;use stack to load status
904b : 28              >            plp
                        
904c : a40e                     ldy zp1+3
904e : 08                       php         ;test stores do not alter flags
904f : 98                       tya
9050 : 49c3                     eor #$c3
9052 : a8                       tay
9053 : 28                       plp
9054 : 8c0602                   sty abst+3
9057 : 08                       php         ;flags after load/store sequence
9058 : 49c3                     eor #$c3
905a : a8                       tay
905b : c000                     cpy #0      ;test result
                                trap_ne
905d : d0fe            >        bne *         ;failed not equal (non zero)
                        
905f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9060 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9062 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9065 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
9067 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9069 : 48              >            pha         ;use stack to load status
906a : 28              >            plp
                        
906b : ac1802                   ldy abs1  
906e : 08                       php         ;test stores do not alter flags
906f : 98                       tya
9070 : 49c3                     eor #$c3
9072 : a8                       tay
9073 : 28                       plp
9074 : 8402                     sty zpt  
9076 : 08                       php         ;flags after load/store sequence
9077 : 49c3                     eor #$c3
9079 : a8                       tay
907a : c40b                     cpy zp1     ;test result
                                trap_ne
907c : d0fe            >        bne *         ;failed not equal (non zero)
                        
907e : 68                       pla         ;load status
                                eor_flag 0
907f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9081 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
9084 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9086 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9088 : 48              >            pha         ;use stack to load status
9089 : 28              >            plp
                        
908a : ac1902                   ldy abs1+1
908d : 08                       php         ;test stores do not alter flags
908e : 98                       tya
908f : 49c3                     eor #$c3
9091 : a8                       tay
9092 : 28                       plp
9093 : 8403                     sty zpt+1
9095 : 08                       php         ;flags after load/store sequence
9096 : 49c3                     eor #$c3
9098 : a8                       tay
9099 : c40c                     cpy zp1+1   ;test result
                                trap_ne
909b : d0fe            >        bne *         ;failed not equal (non zero)
                        
909d : 68                       pla         ;load status
                                eor_flag 0
909e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
90a0 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
90a3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
90a5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
90a7 : 48              >            pha         ;use stack to load status
90a8 : 28              >            plp
                        
90a9 : ac1a02                   ldy abs1+2
90ac : 08                       php         ;test stores do not alter flags
90ad : 98                       tya
90ae : 49c3                     eor #$c3
90b0 : a8                       tay
90b1 : 28                       plp
90b2 : 8404                     sty zpt+2
90b4 : 08                       php         ;flags after load/store sequence
90b5 : 49c3                     eor #$c3
90b7 : a8                       tay
90b8 : c40d                     cpy zp1+2   ;test result
                                trap_ne
90ba : d0fe            >        bne *         ;failed not equal (non zero)
                        
90bc : 68                       pla         ;load status
                                eor_flag 0
90bd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
90bf : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
90c2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
90c4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
90c6 : 48              >            pha         ;use stack to load status
90c7 : 28              >            plp
                        
90c8 : ac1b02                   ldy abs1+3
90cb : 08                       php         ;test stores do not alter flags
90cc : 98                       tya
90cd : 49c3                     eor #$c3
90cf : a8                       tay
90d0 : 28                       plp
90d1 : 8405                     sty zpt+3
90d3 : 08                       php         ;flags after load/store sequence
90d4 : 49c3                     eor #$c3
90d6 : a8                       tay
90d7 : c40e                     cpy zp1+3   ;test result
                                trap_ne
90d9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
90db : 68                       pla         ;load status
                                eor_flag 0
90dc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
90de : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
90e1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
90e3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
90e5 : 48              >            pha         ;use stack to load status
90e6 : 28              >            plp
                        
90e7 : ac1802                   ldy abs1  
90ea : 08                       php         ;test stores do not alter flags
90eb : 98                       tya
90ec : 49c3                     eor #$c3
90ee : a8                       tay
90ef : 28                       plp
90f0 : 8402                     sty zpt  
90f2 : 08                       php         ;flags after load/store sequence
90f3 : 49c3                     eor #$c3
90f5 : a8                       tay
90f6 : c50b                     cmp zp1     ;test result
                                trap_ne
90f8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
90fa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
90fb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
90fd : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
9100 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9102 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9104 : 48              >            pha         ;use stack to load status
9105 : 28              >            plp
                        
9106 : ac1902                   ldy abs1+1
9109 : 08                       php         ;test stores do not alter flags
910a : 98                       tya
910b : 49c3                     eor #$c3
910d : a8                       tay
910e : 28                       plp
910f : 8403                     sty zpt+1
9111 : 08                       php         ;flags after load/store sequence
9112 : 49c3                     eor #$c3
9114 : a8                       tay
9115 : c50c                     cmp zp1+1   ;test result
                                trap_ne
9117 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9119 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
911a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
911c : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
911f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9121 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9123 : 48              >            pha         ;use stack to load status
9124 : 28              >            plp
                        
9125 : ac1a02                   ldy abs1+2
9128 : 08                       php         ;test stores do not alter flags
9129 : 98                       tya
912a : 49c3                     eor #$c3
912c : a8                       tay
912d : 28                       plp
912e : 8404                     sty zpt+2
9130 : 08                       php         ;flags after load/store sequence
9131 : 49c3                     eor #$c3
9133 : a8                       tay
9134 : c50d                     cmp zp1+2   ;test result
                                trap_ne
9136 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9138 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9139 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
913b : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
913e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9140 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9142 : 48              >            pha         ;use stack to load status
9143 : 28              >            plp
                        
9144 : ac1b02                   ldy abs1+3
9147 : 08                       php         ;test stores do not alter flags
9148 : 98                       tya
9149 : 49c3                     eor #$c3
914b : a8                       tay
914c : 28                       plp
914d : 8405                     sty zpt+3
914f : 08                       php         ;flags after load/store sequence
9150 : 49c3                     eor #$c3
9152 : a8                       tay
9153 : c50e                     cmp zp1+3   ;test result
                                trap_ne
9155 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9157 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9158 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
915a : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
915d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
915f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9161 : 48              >            pha         ;use stack to load status
9162 : 28              >            plp
                        
9163 : a0c3                     ldy #$c3  
9165 : 08                       php
9166 : cc1802                   cpy abs1    ;test result
                                trap_ne
9169 : d0fe            >        bne *         ;failed not equal (non zero)
                        
916b : 68                       pla         ;load status
                                eor_flag 0
916c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
916e : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
9171 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9173 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9175 : 48              >            pha         ;use stack to load status
9176 : 28              >            plp
                        
9177 : a082                     ldy #$82
9179 : 08                       php
917a : cc1902                   cpy abs1+1  ;test result
                                trap_ne
917d : d0fe            >        bne *         ;failed not equal (non zero)
                        
917f : 68                       pla         ;load status
                                eor_flag 0
9180 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9182 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
9185 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9187 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9189 : 48              >            pha         ;use stack to load status
918a : 28              >            plp
                        
918b : a041                     ldy #$41
918d : 08                       php
918e : cc1a02                   cpy abs1+2  ;test result
                                trap_ne
9191 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9193 : 68                       pla         ;load status
                                eor_flag 0
9194 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9196 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
9199 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
919b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
919d : 48              >            pha         ;use stack to load status
919e : 28              >            plp
                        
919f : a000                     ldy #0
91a1 : 08                       php
91a2 : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
91a5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
91a7 : 68                       pla         ;load status
                                eor_flag 0
91a8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
91aa : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
91ad : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
91af : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
91b1 : 48              >            pha         ;use stack to load status
91b2 : 28              >            plp
                        
91b3 : a0c3                     ldy #$c3  
91b5 : 08                       php
91b6 : cc1802                   cpy abs1    ;test result
                                trap_ne
91b9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
91bb : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
91bc : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
91be : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
91c1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
91c3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
91c5 : 48              >            pha         ;use stack to load status
91c6 : 28              >            plp
                        
91c7 : a082                     ldy #$82
91c9 : 08                       php
91ca : cc1902                   cpy abs1+1  ;test result
                                trap_ne
91cd : d0fe            >        bne *         ;failed not equal (non zero)
                        
91cf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
91d0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
91d2 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
91d5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
91d7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
91d9 : 48              >            pha         ;use stack to load status
91da : 28              >            plp
                        
91db : a041                     ldy #$41
91dd : 08                       php
91de : cc1a02                   cpy abs1+2   ;test result
                                trap_ne
91e1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
91e3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
91e4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
91e6 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
91e9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
91eb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
91ed : 48              >            pha         ;use stack to load status
91ee : 28              >            plp
                        
91ef : a000                     ldy #0
91f1 : 08                       php
91f2 : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
91f5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
91f7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
91f8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
91fa : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
91fd : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
91ff : a000                     ldy #0
9201 : a502                     lda zpt  
9203 : 49c3                     eor #$c3
9205 : c50b                     cmp zp1  
                                trap_ne     ;store to zp   data
9207 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9209 : 8402                     sty zpt     ;clear                
920b : ad0302                   lda abst  
920e : 49c3                     eor #$c3
9210 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs   data
9213 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9215 : 8c0302                   sty abst    ;clear                
9218 : a503                     lda zpt+1
921a : 49c3                     eor #$c3
921c : c50c                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
921e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9220 : 8403                     sty zpt+1   ;clear                
9222 : ad0402                   lda abst+1
9225 : 49c3                     eor #$c3
9227 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
922a : d0fe            >        bne *         ;failed not equal (non zero)
                        
922c : 8c0402                   sty abst+1  ;clear                
922f : a504                     lda zpt+2
9231 : 49c3                     eor #$c3
9233 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
9235 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9237 : 8404                     sty zpt+2   ;clear                
9239 : ad0502                   lda abst+2
923c : 49c3                     eor #$c3
923e : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
9241 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9243 : 8c0502                   sty abst+2  ;clear                
9246 : a505                     lda zpt+3
9248 : 49c3                     eor #$c3
924a : c50e                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
924c : d0fe            >        bne *         ;failed not equal (non zero)
                        
924e : 8405                     sty zpt+3   ;clear                
9250 : ad0602                   lda abst+3
9253 : 49c3                     eor #$c3
9255 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
9258 : d0fe            >        bne *         ;failed not equal (non zero)
                        
925a : 8c0602                   sty abst+3  ;clear                
                                next_test
925d : ad0002          >            lda test_case   ;previous test
9260 : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
9262 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
9264 : a915            >            lda #test_num   ;*** next tests' number
9266 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
9269 : a203                     ldx #3
926b :                  tldax    
                                set_stat 0
                       >            load_flag 0
926b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
926d : 48              >            pha         ;use stack to load status
926e : 28              >            plp
                        
926f : b50b                     lda zp1,x
9271 : 08                       php         ;test stores do not alter flags
9272 : 49c3                     eor #$c3
9274 : 28                       plp
9275 : 9d0302                   sta abst,x
9278 : 08                       php         ;flags after load/store sequence
9279 : 49c3                     eor #$c3
927b : dd1802                   cmp abs1,x  ;test result
                                trap_ne
927e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9280 : 68                       pla         ;load status
                                eor_flag 0
9281 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9283 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
9286 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9288 : ca                       dex
9289 : 10e0                     bpl tldax                  
                        
928b : a203                     ldx #3
928d :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
928d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
928f : 48              >            pha         ;use stack to load status
9290 : 28              >            plp
                        
9291 : b50b                     lda zp1,x
9293 : 08                       php         ;test stores do not alter flags
9294 : 49c3                     eor #$c3
9296 : 28                       plp
9297 : 9d0302                   sta abst,x
929a : 08                       php         ;flags after load/store sequence
929b : 49c3                     eor #$c3
929d : dd1802                   cmp abs1,x   ;test result
                                trap_ne
92a0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92a2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
92a3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
92a5 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
92a8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92aa : ca                       dex
92ab : 10e0                     bpl tldax1                  
                        
92ad : a203                     ldx #3
92af :                  tldax2   
                                set_stat 0
                       >            load_flag 0
92af : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
92b1 : 48              >            pha         ;use stack to load status
92b2 : 28              >            plp
                        
92b3 : bd1802                   lda abs1,x
92b6 : 08                       php         ;test stores do not alter flags
92b7 : 49c3                     eor #$c3
92b9 : 28                       plp
92ba : 9502                     sta zpt,x
92bc : 08                       php         ;flags after load/store sequence
92bd : 49c3                     eor #$c3
92bf : d50b                     cmp zp1,x   ;test result
                                trap_ne
92c1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92c3 : 68                       pla         ;load status
                                eor_flag 0
92c4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
92c6 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
92c9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92cb : ca                       dex
92cc : 10e1                     bpl tldax2                  
                        
92ce : a203                     ldx #3
92d0 :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
92d0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
92d2 : 48              >            pha         ;use stack to load status
92d3 : 28              >            plp
                        
92d4 : bd1802                   lda abs1,x
92d7 : 08                       php         ;test stores do not alter flags
92d8 : 49c3                     eor #$c3
92da : 28                       plp
92db : 9502                     sta zpt,x
92dd : 08                       php         ;flags after load/store sequence
92de : 49c3                     eor #$c3
92e0 : d50b                     cmp zp1,x   ;test result
                                trap_ne
92e2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92e4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
92e5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
92e7 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
92ea : d0fe            >        bne *         ;failed not equal (non zero)
                        
92ec : ca                       dex
92ed : 10e1                     bpl tldax3
                        
92ef : a203                     ldx #3      ;testing store result
92f1 : a000                     ldy #0
92f3 : b502             tstax   lda zpt,x
92f5 : 49c3                     eor #$c3
92f7 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
92f9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92fb : 9402                     sty zpt,x   ;clear                
92fd : bd0302                   lda abst,x
9300 : 49c3                     eor #$c3
9302 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
9305 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9307 : 8a                       txa
9308 : 9d0302                   sta abst,x  ;clear                
930b : ca                       dex
930c : 10e5                     bpl tstax
                                next_test
930e : ad0002          >            lda test_case   ;previous test
9311 : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
9313 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
9315 : a916            >            lda #test_num   ;*** next tests' number
9317 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
931a : a003                     ldy #3
931c :                  tlday    
                                set_stat 0
                       >            load_flag 0
931c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
931e : 48              >            pha         ;use stack to load status
931f : 28              >            plp
                        
9320 : b11c                     lda (ind1),y
9322 : 08                       php         ;test stores do not alter flags
9323 : 49c3                     eor #$c3
9325 : 28                       plp
9326 : 990302                   sta abst,y
9329 : 08                       php         ;flags after load/store sequence
932a : 49c3                     eor #$c3
932c : d91802                   cmp abs1,y  ;test result
                                trap_ne
932f : d0fe            >        bne *         ;failed not equal (non zero)
                        
9331 : 68                       pla         ;load status
                                eor_flag 0
9332 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9334 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
9337 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9339 : 88                       dey
933a : 10e0                     bpl tlday                  
                        
933c : a003                     ldy #3
933e :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
933e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9340 : 48              >            pha         ;use stack to load status
9341 : 28              >            plp
                        
9342 : b11c                     lda (ind1),y
9344 : 08                       php         ;test stores do not alter flags
9345 : 49c3                     eor #$c3
9347 : 28                       plp
9348 : 990302                   sta abst,y
934b : 08                       php         ;flags after load/store sequence
934c : 49c3                     eor #$c3
934e : d91802                   cmp abs1,y  ;test result
                                trap_ne
9351 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9353 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9354 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9356 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
9359 : d0fe            >        bne *         ;failed not equal (non zero)
                        
935b : 88                       dey
935c : 10e0                     bpl tlday1                  
                        
935e : a003                     ldy #3      ;testing store result
9360 : a200                     ldx #0
9362 : b90302           tstay   lda abst,y
9365 : 49c3                     eor #$c3
9367 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
936a : d0fe            >        bne *         ;failed not equal (non zero)
                        
936c : 8a                       txa
936d : 990302                   sta abst,y  ;clear                
9370 : 88                       dey
9371 : 10ef                     bpl tstay
                        
9373 : a003                     ldy #3
9375 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
9375 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9377 : 48              >            pha         ;use stack to load status
9378 : 28              >            plp
                        
9379 : b91802                   lda abs1,y
937c : 08                       php         ;test stores do not alter flags
937d : 49c3                     eor #$c3
937f : 28                       plp
9380 : 9128                     sta (indt),y
9382 : 08                       php         ;flags after load/store sequence
9383 : 49c3                     eor #$c3
9385 : d11c                     cmp (ind1),y    ;test result
                                trap_ne
9387 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9389 : 68                       pla         ;load status
                                eor_flag 0
938a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
938c : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
938f : d0fe            >        bne *         ;failed not equal (non zero)
                        
9391 : 88                       dey
9392 : 10e1                     bpl tlday2                  
                        
9394 : a003                     ldy #3
9396 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
9396 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9398 : 48              >            pha         ;use stack to load status
9399 : 28              >            plp
                        
939a : b91802                   lda abs1,y
939d : 08                       php         ;test stores do not alter flags
939e : 49c3                     eor #$c3
93a0 : 28                       plp
93a1 : 9128                     sta (indt),y
93a3 : 08                       php         ;flags after load/store sequence
93a4 : 49c3                     eor #$c3
93a6 : d11c                     cmp (ind1),y   ;test result
                                trap_ne
93a8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
93aa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
93ab : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
93ad : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
93b0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
93b2 : 88                       dey
93b3 : 10e1                     bpl tlday3
                                
93b5 : a003                     ldy #3      ;testing store result
93b7 : a200                     ldx #0
93b9 : b90302           tstay1  lda abst,y
93bc : 49c3                     eor #$c3
93be : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
93c1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
93c3 : 8a                       txa
93c4 : 990302                   sta abst,y  ;clear                
93c7 : 88                       dey
93c8 : 10ef                     bpl tstay1
                                
93ca : a206                     ldx #6
93cc : a003                     ldy #3
93ce :                  tldax4   
                                set_stat 0
                       >            load_flag 0
93ce : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
93d0 : 48              >            pha         ;use stack to load status
93d1 : 28              >            plp
                        
93d2 : a11c                     lda (ind1,x)
93d4 : 08                       php         ;test stores do not alter flags
93d5 : 49c3                     eor #$c3
93d7 : 28                       plp
93d8 : 8128                     sta (indt,x)
93da : 08                       php         ;flags after load/store sequence
93db : 49c3                     eor #$c3
93dd : d91802                   cmp abs1,y  ;test result
                                trap_ne
93e0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
93e2 : 68                       pla         ;load status
                                eor_flag 0
93e3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
93e5 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
93e8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
93ea : ca                       dex
93eb : ca                       dex
93ec : 88                       dey
93ed : 10df                     bpl tldax4                  
                        
93ef : a206                     ldx #6
93f1 : a003                     ldy #3
93f3 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
93f3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
93f5 : 48              >            pha         ;use stack to load status
93f6 : 28              >            plp
                        
93f7 : a11c                     lda (ind1,x)
93f9 : 08                       php         ;test stores do not alter flags
93fa : 49c3                     eor #$c3
93fc : 28                       plp
93fd : 8128                     sta (indt,x)
93ff : 08                       php         ;flags after load/store sequence
9400 : 49c3                     eor #$c3
9402 : d91802                   cmp abs1,y  ;test result
                                trap_ne
9405 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9407 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9408 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
940a : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
940d : d0fe            >        bne *         ;failed not equal (non zero)
                        
940f : ca                       dex
9410 : ca                       dex
9411 : 88                       dey
9412 : 10df                     bpl tldax5
                        
9414 : a003                     ldy #3      ;testing store result
9416 : a200                     ldx #0
9418 : b90302           tstay2  lda abst,y
941b : 49c3                     eor #$c3
941d : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
9420 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9422 : 8a                       txa
9423 : 990302                   sta abst,y  ;clear                
9426 : 88                       dey
9427 : 10ef                     bpl tstay2
                                next_test
9429 : ad0002          >            lda test_case   ;previous test
942c : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
942e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
9430 : a917            >            lda #test_num   ;*** next tests' number
9432 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
9435 : a2fd                     ldx #3+$fa
9437 : b511             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
9439 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
943c : ca                       dex
943d : e0fa                     cpx #$fa
943f : b0f6                     bcs tldax6                  
9441 : a2fd                     ldx #3+$fa
9443 : bd1e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
9446 : 9508                     sta zpt-$fa&$ff,x
9448 : ca                       dex
9449 : e0fa                     cpx #$fa
944b : b0f6                     bcs tldax7
                                                  
944d : a203                     ldx #3      ;testing wraparound result
944f : a000                     ldy #0
9451 : b502             tstax1  lda zpt,x
9453 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
9455 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9457 : 9402                     sty zpt,x   ;clear                
9459 : bd0302                   lda abst,x
945c : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
945f : d0fe            >        bne *         ;failed not equal (non zero)
                        
9461 : 8a                       txa
9462 : 9d0302                   sta abst,x  ;clear                
9465 : ca                       dex
9466 : 10e9                     bpl tstax1
                        
9468 : a0fb                     ldy #3+$f8
946a : a2fe                     ldx #6+$f8
946c : a124             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
946e : 990b01                   sta abst-$f8,y
9471 : ca                       dex
9472 : ca                       dex
9473 : 88                       dey
9474 : c0f8                     cpy #$f8
9476 : b0f4                     bcs tlday4
9478 : a003                     ldy #3      ;testing wraparound result
947a : a200                     ldx #0
947c : b90302           tstay4  lda abst,y
947f : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
9482 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9484 : 8a                       txa
9485 : 990302                   sta abst,y  ;clear                
9488 : 88                       dey
9489 : 10f1                     bpl tstay4
                                
948b : a0fb                     ldy #3+$f8
948d : b92001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
9490 : 9130                     sta (inwt),y
9492 : 88                       dey
9493 : c0f8                     cpy #$f8
9495 : b0f6                     bcs tlday5                  
9497 : a003                     ldy #3      ;testing wraparound result
9499 : a200                     ldx #0
949b : b90302           tstay5  lda abst,y
949e : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
94a1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
94a3 : 8a                       txa
94a4 : 990302                   sta abst,y  ;clear                
94a7 : 88                       dey
94a8 : 10f1                     bpl tstay5
                        
94aa : a0fb                     ldy #3+$f8
94ac : a2fe                     ldx #6+$f8
94ae : b126             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
94b0 : 8130                     sta (indt-$f8&$ff,x)
94b2 : ca                       dex
94b3 : ca                       dex
94b4 : 88                       dey
94b5 : c0f8                     cpy #$f8
94b7 : b0f5                     bcs tlday6
94b9 : a003                     ldy #3      ;testing wraparound result
94bb : a200                     ldx #0
94bd : b90302           tstay6  lda abst,y
94c0 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
94c3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
94c5 : 8a                       txa
94c6 : 990302                   sta abst,y  ;clear                
94c9 : 88                       dey
94ca : 10f1                     bpl tstay6
                                next_test
94cc : ad0002          >            lda test_case   ;previous test
94cf : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
94d1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
94d3 : a918            >            lda #test_num   ;*** next tests' number
94d5 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
94d8 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
94da : 48              >            pha         ;use stack to load status
94db : 28              >            plp
                        
94dc : a50b                     lda zp1
94de : 08                       php         ;test stores do not alter flags
94df : 49c3                     eor #$c3
94e1 : 28                       plp
94e2 : 8d0302                   sta abst
94e5 : 08                       php         ;flags after load/store sequence
94e6 : 49c3                     eor #$c3
94e8 : c9c3                     cmp #$c3    ;test result
                                trap_ne
94ea : d0fe            >        bne *         ;failed not equal (non zero)
                        
94ec : 68                       pla         ;load status
                                eor_flag 0
94ed : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
94ef : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
94f2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
94f4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
94f6 : 48              >            pha         ;use stack to load status
94f7 : 28              >            plp
                        
94f8 : a50c                     lda zp1+1
94fa : 08                       php         ;test stores do not alter flags
94fb : 49c3                     eor #$c3
94fd : 28                       plp
94fe : 8d0402                   sta abst+1
9501 : 08                       php         ;flags after load/store sequence
9502 : 49c3                     eor #$c3
9504 : c982                     cmp #$82    ;test result
                                trap_ne
9506 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9508 : 68                       pla         ;load status
                                eor_flag 0
9509 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
950b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
950e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9510 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9512 : 48              >            pha         ;use stack to load status
9513 : 28              >            plp
                        
9514 : a50d                     lda zp1+2
9516 : 08                       php         ;test stores do not alter flags
9517 : 49c3                     eor #$c3
9519 : 28                       plp
951a : 8d0502                   sta abst+2
951d : 08                       php         ;flags after load/store sequence
951e : 49c3                     eor #$c3
9520 : c941                     cmp #$41    ;test result
                                trap_ne
9522 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9524 : 68                       pla         ;load status
                                eor_flag 0
9525 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9527 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
952a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
952c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
952e : 48              >            pha         ;use stack to load status
952f : 28              >            plp
                        
9530 : a50e                     lda zp1+3
9532 : 08                       php         ;test stores do not alter flags
9533 : 49c3                     eor #$c3
9535 : 28                       plp
9536 : 8d0602                   sta abst+3
9539 : 08                       php         ;flags after load/store sequence
953a : 49c3                     eor #$c3
953c : c900                     cmp #0      ;test result
                                trap_ne
953e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9540 : 68                       pla         ;load status
                                eor_flag 0
9541 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9543 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9546 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9548 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
954a : 48              >            pha         ;use stack to load status
954b : 28              >            plp
                        
954c : a50b                     lda zp1  
954e : 08                       php         ;test stores do not alter flags
954f : 49c3                     eor #$c3
9551 : 28                       plp
9552 : 8d0302                   sta abst  
9555 : 08                       php         ;flags after load/store sequence
9556 : 49c3                     eor #$c3
9558 : c9c3                     cmp #$c3    ;test result
                                trap_ne
955a : d0fe            >        bne *         ;failed not equal (non zero)
                        
955c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
955d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
955f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
9562 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9564 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9566 : 48              >            pha         ;use stack to load status
9567 : 28              >            plp
                        
9568 : a50c                     lda zp1+1
956a : 08                       php         ;test stores do not alter flags
956b : 49c3                     eor #$c3
956d : 28                       plp
956e : 8d0402                   sta abst+1
9571 : 08                       php         ;flags after load/store sequence
9572 : 49c3                     eor #$c3
9574 : c982                     cmp #$82    ;test result
                                trap_ne
9576 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9578 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9579 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
957b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
957e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9580 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9582 : 48              >            pha         ;use stack to load status
9583 : 28              >            plp
                        
9584 : a50d                     lda zp1+2
9586 : 08                       php         ;test stores do not alter flags
9587 : 49c3                     eor #$c3
9589 : 28                       plp
958a : 8d0502                   sta abst+2
958d : 08                       php         ;flags after load/store sequence
958e : 49c3                     eor #$c3
9590 : c941                     cmp #$41    ;test result
                                trap_ne
9592 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9594 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9595 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9597 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
959a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
959c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
959e : 48              >            pha         ;use stack to load status
959f : 28              >            plp
                        
95a0 : a50e                     lda zp1+3
95a2 : 08                       php         ;test stores do not alter flags
95a3 : 49c3                     eor #$c3
95a5 : 28                       plp
95a6 : 8d0602                   sta abst+3
95a9 : 08                       php         ;flags after load/store sequence
95aa : 49c3                     eor #$c3
95ac : c900                     cmp #0      ;test result
                                trap_ne
95ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
95b0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
95b1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
95b3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
95b6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
95b8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
95ba : 48              >            pha         ;use stack to load status
95bb : 28              >            plp
                        
95bc : ad1802                   lda abs1  
95bf : 08                       php         ;test stores do not alter flags
95c0 : 49c3                     eor #$c3
95c2 : 28                       plp
95c3 : 8502                     sta zpt  
95c5 : 08                       php         ;flags after load/store sequence
95c6 : 49c3                     eor #$c3
95c8 : c50b                     cmp zp1     ;test result
                                trap_ne
95ca : d0fe            >        bne *         ;failed not equal (non zero)
                        
95cc : 68                       pla         ;load status
                                eor_flag 0
95cd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
95cf : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
95d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
95d4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
95d6 : 48              >            pha         ;use stack to load status
95d7 : 28              >            plp
                        
95d8 : ad1902                   lda abs1+1
95db : 08                       php         ;test stores do not alter flags
95dc : 49c3                     eor #$c3
95de : 28                       plp
95df : 8503                     sta zpt+1
95e1 : 08                       php         ;flags after load/store sequence
95e2 : 49c3                     eor #$c3
95e4 : c50c                     cmp zp1+1   ;test result
                                trap_ne
95e6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
95e8 : 68                       pla         ;load status
                                eor_flag 0
95e9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
95eb : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
95ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
95f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
95f2 : 48              >            pha         ;use stack to load status
95f3 : 28              >            plp
                        
95f4 : ad1a02                   lda abs1+2
95f7 : 08                       php         ;test stores do not alter flags
95f8 : 49c3                     eor #$c3
95fa : 28                       plp
95fb : 8504                     sta zpt+2
95fd : 08                       php         ;flags after load/store sequence
95fe : 49c3                     eor #$c3
9600 : c50d                     cmp zp1+2   ;test result
                                trap_ne
9602 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9604 : 68                       pla         ;load status
                                eor_flag 0
9605 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9607 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
960a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
960c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
960e : 48              >            pha         ;use stack to load status
960f : 28              >            plp
                        
9610 : ad1b02                   lda abs1+3
9613 : 08                       php         ;test stores do not alter flags
9614 : 49c3                     eor #$c3
9616 : 28                       plp
9617 : 8505                     sta zpt+3
9619 : 08                       php         ;flags after load/store sequence
961a : 49c3                     eor #$c3
961c : c50e                     cmp zp1+3   ;test result
                                trap_ne
961e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9620 : 68                       pla         ;load status
                                eor_flag 0
9621 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9623 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9626 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9628 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
962a : 48              >            pha         ;use stack to load status
962b : 28              >            plp
                        
962c : ad1802                   lda abs1  
962f : 08                       php         ;test stores do not alter flags
9630 : 49c3                     eor #$c3
9632 : 28                       plp
9633 : 8502                     sta zpt  
9635 : 08                       php         ;flags after load/store sequence
9636 : 49c3                     eor #$c3
9638 : c50b                     cmp zp1     ;test result
                                trap_ne
963a : d0fe            >        bne *         ;failed not equal (non zero)
                        
963c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
963d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
963f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
9642 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9644 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9646 : 48              >            pha         ;use stack to load status
9647 : 28              >            plp
                        
9648 : ad1902                   lda abs1+1
964b : 08                       php         ;test stores do not alter flags
964c : 49c3                     eor #$c3
964e : 28                       plp
964f : 8503                     sta zpt+1
9651 : 08                       php         ;flags after load/store sequence
9652 : 49c3                     eor #$c3
9654 : c50c                     cmp zp1+1   ;test result
                                trap_ne
9656 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9658 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9659 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
965b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
965e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9660 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9662 : 48              >            pha         ;use stack to load status
9663 : 28              >            plp
                        
9664 : ad1a02                   lda abs1+2
9667 : 08                       php         ;test stores do not alter flags
9668 : 49c3                     eor #$c3
966a : 28                       plp
966b : 8504                     sta zpt+2
966d : 08                       php         ;flags after load/store sequence
966e : 49c3                     eor #$c3
9670 : c50d                     cmp zp1+2   ;test result
                                trap_ne
9672 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9674 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9675 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9677 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
967a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
967c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
967e : 48              >            pha         ;use stack to load status
967f : 28              >            plp
                        
9680 : ad1b02                   lda abs1+3
9683 : 08                       php         ;test stores do not alter flags
9684 : 49c3                     eor #$c3
9686 : 28                       plp
9687 : 8505                     sta zpt+3
9689 : 08                       php         ;flags after load/store sequence
968a : 49c3                     eor #$c3
968c : c50e                     cmp zp1+3   ;test result
                                trap_ne
968e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9690 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9691 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9693 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9696 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
9698 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
969a : 48              >            pha         ;use stack to load status
969b : 28              >            plp
                        
969c : a9c3                     lda #$c3
969e : 08                       php
969f : cd1802                   cmp abs1    ;test result
                                trap_ne
96a2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
96a4 : 68                       pla         ;load status
                                eor_flag 0
96a5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
96a7 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
96aa : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
96ac : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
96ae : 48              >            pha         ;use stack to load status
96af : 28              >            plp
                        
96b0 : a982                     lda #$82
96b2 : 08                       php
96b3 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
96b6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
96b8 : 68                       pla         ;load status
                                eor_flag 0
96b9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
96bb : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
96be : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
96c0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
96c2 : 48              >            pha         ;use stack to load status
96c3 : 28              >            plp
                        
96c4 : a941                     lda #$41
96c6 : 08                       php
96c7 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
96ca : d0fe            >        bne *         ;failed not equal (non zero)
                        
96cc : 68                       pla         ;load status
                                eor_flag 0
96cd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
96cf : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
96d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
96d4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
96d6 : 48              >            pha         ;use stack to load status
96d7 : 28              >            plp
                        
96d8 : a900                     lda #0
96da : 08                       php
96db : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
96de : d0fe            >        bne *         ;failed not equal (non zero)
                        
96e0 : 68                       pla         ;load status
                                eor_flag 0
96e1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
96e3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
96e6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
96e8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
96ea : 48              >            pha         ;use stack to load status
96eb : 28              >            plp
                        
96ec : a9c3                     lda #$c3  
96ee : 08                       php
96ef : cd1802                   cmp abs1    ;test result
                                trap_ne
96f2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
96f4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
96f5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
96f7 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
96fa : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
96fc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
96fe : 48              >            pha         ;use stack to load status
96ff : 28              >            plp
                        
9700 : a982                     lda #$82
9702 : 08                       php
9703 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
9706 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9708 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9709 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
970b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
970e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9710 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9712 : 48              >            pha         ;use stack to load status
9713 : 28              >            plp
                        
9714 : a941                     lda #$41
9716 : 08                       php
9717 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
971a : d0fe            >        bne *         ;failed not equal (non zero)
                        
971c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
971d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
971f : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
9722 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9724 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9726 : 48              >            pha         ;use stack to load status
9727 : 28              >            plp
                        
9728 : a900                     lda #0
972a : 08                       php
972b : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
972e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9730 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9731 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9733 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9736 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
9738 : a200                     ldx #0
973a : a502                     lda zpt  
973c : 49c3                     eor #$c3
973e : c50b                     cmp zp1  
                                trap_ne     ;store to zp data
9740 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9742 : 8602                     stx zpt     ;clear                
9744 : ad0302                   lda abst  
9747 : 49c3                     eor #$c3
9749 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
974c : d0fe            >        bne *         ;failed not equal (non zero)
                        
974e : 8e0302                   stx abst    ;clear                
9751 : a503                     lda zpt+1
9753 : 49c3                     eor #$c3
9755 : c50c                     cmp zp1+1
                                trap_ne     ;store to zp data
9757 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9759 : 8603                     stx zpt+1   ;clear                
975b : ad0402                   lda abst+1
975e : 49c3                     eor #$c3
9760 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
9763 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9765 : 8e0402                   stx abst+1  ;clear                
9768 : a504                     lda zpt+2
976a : 49c3                     eor #$c3
976c : c50d                     cmp zp1+2
                                trap_ne     ;store to zp data
976e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9770 : 8604                     stx zpt+2   ;clear                
9772 : ad0502                   lda abst+2
9775 : 49c3                     eor #$c3
9777 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
977a : d0fe            >        bne *         ;failed not equal (non zero)
                        
977c : 8e0502                   stx abst+2  ;clear                
977f : a505                     lda zpt+3
9781 : 49c3                     eor #$c3
9783 : c50e                     cmp zp1+3
                                trap_ne     ;store to zp data
9785 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9787 : 8605                     stx zpt+3   ;clear                
9789 : ad0602                   lda abst+3
978c : 49c3                     eor #$c3
978e : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
9791 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9793 : 8e0602                   stx abst+3  ;clear                
                                next_test
9796 : ad0002          >            lda test_case   ;previous test
9799 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
979b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
979d : a919            >            lda #test_num   ;*** next tests' number
979f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
97a2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
97a4 : 48              >            pha         ;use stack to load status
97a5 : a9ff            >            lda #$ff     ;precharge accu
97a7 : 28              >            plp
                        
97a8 : 240e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
97aa : 08              >            php         ;save flags
97ab : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
97ad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97af : 68              >            pla         ;load status
97b0 : 48              >            pha
                       >            cmp_flag fz 
97b1 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97b3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97b5 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
97b6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
97b8 : 48              >            pha         ;use stack to load status
97b9 : a901            >            lda #1     ;precharge accu
97bb : 28              >            plp
                        
97bc : 240d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
97be : 08              >            php         ;save flags
97bf : c901            >            cmp #1     ;test result
                       >            trap_ne
97c1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97c3 : 68              >            pla         ;load status
97c4 : 48              >            pha
                       >            cmp_flag fv
97c5 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97c7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97c9 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
97ca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
97cc : 48              >            pha         ;use stack to load status
97cd : a901            >            lda #1     ;precharge accu
97cf : 28              >            plp
                        
97d0 : 240c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
97d2 : 08              >            php         ;save flags
97d3 : c901            >            cmp #1     ;test result
                       >            trap_ne
97d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97d7 : 68              >            pla         ;load status
97d8 : 48              >            pha
                       >            cmp_flag fnz
97d9 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97db : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97dd : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
97de : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
97e0 : 48              >            pha         ;use stack to load status
97e1 : a901            >            lda #1     ;precharge accu
97e3 : 28              >            plp
                        
97e4 : 240b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
97e6 : 08              >            php         ;save flags
97e7 : c901            >            cmp #1     ;test result
                       >            trap_ne
97e9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97eb : 68              >            pla         ;load status
97ec : 48              >            pha
                       >            cmp_flag fnv
97ed : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97f1 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
97f2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
97f4 : 48              >            pha         ;use stack to load status
97f5 : a9ff            >            lda #$ff     ;precharge accu
97f7 : 28              >            plp
                        
97f8 : 240e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
97fa : 08              >            php         ;save flags
97fb : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
97fd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97ff : 68              >            pla         ;load status
9800 : 48              >            pha
                       >            cmp_flag ~fnv 
9801 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9803 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9805 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
9806 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9808 : 48              >            pha         ;use stack to load status
9809 : a901            >            lda #1     ;precharge accu
980b : 28              >            plp
                        
980c : 240d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
980e : 08              >            php         ;save flags
980f : c901            >            cmp #1     ;test result
                       >            trap_ne
9811 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9813 : 68              >            pla         ;load status
9814 : 48              >            pha
                       >            cmp_flag ~fnz
9815 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9817 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9819 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
981a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
981c : 48              >            pha         ;use stack to load status
981d : a901            >            lda #1     ;precharge accu
981f : 28              >            plp
                        
9820 : 240c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
9822 : 08              >            php         ;save flags
9823 : c901            >            cmp #1     ;test result
                       >            trap_ne
9825 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9827 : 68              >            pla         ;load status
9828 : 48              >            pha
                       >            cmp_flag ~fv
9829 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
982b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
982d : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
982e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9830 : 48              >            pha         ;use stack to load status
9831 : a901            >            lda #1     ;precharge accu
9833 : 28              >            plp
                        
9834 : 240b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
9836 : 08              >            php         ;save flags
9837 : c901            >            cmp #1     ;test result
                       >            trap_ne
9839 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
983b : 68              >            pla         ;load status
983c : 48              >            pha
                       >            cmp_flag ~fz
983d : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
983f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9841 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
9842 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9844 : 48              >            pha         ;use stack to load status
9845 : a9ff            >            lda #$ff     ;precharge accu
9847 : 28              >            plp
                        
9848 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
984b : 08              >            php         ;save flags
984c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
984e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9850 : 68              >            pla         ;load status
9851 : 48              >            pha
                       >            cmp_flag fz 
9852 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9854 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9856 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
9857 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9859 : 48              >            pha         ;use stack to load status
985a : a901            >            lda #1     ;precharge accu
985c : 28              >            plp
                        
985d : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
9860 : 08              >            php         ;save flags
9861 : c901            >            cmp #1     ;test result
                       >            trap_ne
9863 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9865 : 68              >            pla         ;load status
9866 : 48              >            pha
                       >            cmp_flag fv
9867 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9869 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
986b : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
986c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
986e : 48              >            pha         ;use stack to load status
986f : a901            >            lda #1     ;precharge accu
9871 : 28              >            plp
                        
9872 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
9875 : 08              >            php         ;save flags
9876 : c901            >            cmp #1     ;test result
                       >            trap_ne
9878 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
987a : 68              >            pla         ;load status
987b : 48              >            pha
                       >            cmp_flag fnz
987c : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
987e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9880 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
9881 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9883 : 48              >            pha         ;use stack to load status
9884 : a901            >            lda #1     ;precharge accu
9886 : 28              >            plp
                        
9887 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
988a : 08              >            php         ;save flags
988b : c901            >            cmp #1     ;test result
                       >            trap_ne
988d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
988f : 68              >            pla         ;load status
9890 : 48              >            pha
                       >            cmp_flag fnv
9891 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9893 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9895 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
9896 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9898 : 48              >            pha         ;use stack to load status
9899 : a9ff            >            lda #$ff     ;precharge accu
989b : 28              >            plp
                        
989c : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
989f : 08              >            php         ;save flags
98a0 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
98a2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98a4 : 68              >            pla         ;load status
98a5 : 48              >            pha
                       >            cmp_flag ~fnv 
98a6 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98a8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98aa : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
98ab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
98ad : 48              >            pha         ;use stack to load status
98ae : a901            >            lda #1     ;precharge accu
98b0 : 28              >            plp
                        
98b1 : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
98b4 : 08              >            php         ;save flags
98b5 : c901            >            cmp #1     ;test result
                       >            trap_ne
98b7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98b9 : 68              >            pla         ;load status
98ba : 48              >            pha
                       >            cmp_flag ~fnz
98bb : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98bd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98bf : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
98c0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
98c2 : 48              >            pha         ;use stack to load status
98c3 : a901            >            lda #1     ;precharge accu
98c5 : 28              >            plp
                        
98c6 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
98c9 : 08              >            php         ;save flags
98ca : c901            >            cmp #1     ;test result
                       >            trap_ne
98cc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98ce : 68              >            pla         ;load status
98cf : 48              >            pha
                       >            cmp_flag ~fv
98d0 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98d2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98d4 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
98d5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
98d7 : 48              >            pha         ;use stack to load status
98d8 : a901            >            lda #1     ;precharge accu
98da : 28              >            plp
                        
98db : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
98de : 08              >            php         ;save flags
98df : c901            >            cmp #1     ;test result
                       >            trap_ne
98e1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98e3 : 68              >            pla         ;load status
98e4 : 48              >            pha
                       >            cmp_flag ~fz
98e5 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98e9 : 28              >            plp         ;restore status
                        
                                next_test
98ea : ad0002          >            lda test_case   ;previous test
98ed : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
98ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
98f1 : a91a            >            lda #test_num   ;*** next tests' number
98f3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
98f6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
98f8 : 48              >            pha         ;use stack to load status
98f9 : a280            >            ldx #$80     ;precharge index x
98fb : 28              >            plp
                        
98fc : e40f                     cpx zp7f
                                tst_stat fc
98fe : 08              >            php         ;save status
98ff : 68              >            pla         ;use stack to retrieve status
9900 : 48              >            pha
                       >            cmp_flag fc
9901 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9903 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9905 : 28              >            plp         ;restore status
                        
9906 : ca                       dex
9907 : e40f                     cpx zp7f
                                tst_stat fzc
9909 : 08              >            php         ;save status
990a : 68              >            pla         ;use stack to retrieve status
990b : 48              >            pha
                       >            cmp_flag fzc
990c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
990e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9910 : 28              >            plp         ;restore status
                        
9911 : ca                       dex
9912 : e40f                     cpx zp7f
                                tst_x $7e,fn
9914 : 08              >            php         ;save flags
9915 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
9917 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9919 : 68              >            pla         ;load status
991a : 48              >            pha
                       >            cmp_flag fn
991b : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
991d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
991f : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
9920 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9922 : 48              >            pha         ;use stack to load status
9923 : a280            >            ldx #$80     ;precharge index x
9925 : 28              >            plp
                        
9926 : e40f                     cpx zp7f
                                tst_stat ~fnz
9928 : 08              >            php         ;save status
9929 : 68              >            pla         ;use stack to retrieve status
992a : 48              >            pha
                       >            cmp_flag ~fnz
992b : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
992d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
992f : 28              >            plp         ;restore status
                        
9930 : ca                       dex
9931 : e40f                     cpx zp7f
                                tst_stat ~fn
9933 : 08              >            php         ;save status
9934 : 68              >            pla         ;use stack to retrieve status
9935 : 48              >            pha
                       >            cmp_flag ~fn
9936 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9938 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
993a : 28              >            plp         ;restore status
                        
993b : ca                       dex
993c : e40f                     cpx zp7f
                                tst_x $7e,~fzc
993e : 08              >            php         ;save flags
993f : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
9941 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9943 : 68              >            pla         ;load status
9944 : 48              >            pha
                       >            cmp_flag ~fzc
9945 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9947 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9949 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
994a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
994c : 48              >            pha         ;use stack to load status
994d : a280            >            ldx #$80     ;precharge index x
994f : 28              >            plp
                        
9950 : ec1c02                   cpx abs7f
                                tst_stat fc
9953 : 08              >            php         ;save status
9954 : 68              >            pla         ;use stack to retrieve status
9955 : 48              >            pha
                       >            cmp_flag fc
9956 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9958 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
995a : 28              >            plp         ;restore status
                        
995b : ca                       dex
995c : ec1c02                   cpx abs7f
                                tst_stat fzc
995f : 08              >            php         ;save status
9960 : 68              >            pla         ;use stack to retrieve status
9961 : 48              >            pha
                       >            cmp_flag fzc
9962 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9964 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9966 : 28              >            plp         ;restore status
                        
9967 : ca                       dex
9968 : ec1c02                   cpx abs7f
                                tst_x $7e,fn
996b : 08              >            php         ;save flags
996c : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
996e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9970 : 68              >            pla         ;load status
9971 : 48              >            pha
                       >            cmp_flag fn
9972 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9974 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9976 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
9977 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9979 : 48              >            pha         ;use stack to load status
997a : a280            >            ldx #$80     ;precharge index x
997c : 28              >            plp
                        
997d : ec1c02                   cpx abs7f
                                tst_stat ~fnz
9980 : 08              >            php         ;save status
9981 : 68              >            pla         ;use stack to retrieve status
9982 : 48              >            pha
                       >            cmp_flag ~fnz
9983 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9985 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9987 : 28              >            plp         ;restore status
                        
9988 : ca                       dex
9989 : ec1c02                   cpx abs7f
                                tst_stat ~fn
998c : 08              >            php         ;save status
998d : 68              >            pla         ;use stack to retrieve status
998e : 48              >            pha
                       >            cmp_flag ~fn
998f : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9991 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9993 : 28              >            plp         ;restore status
                        
9994 : ca                       dex
9995 : ec1c02                   cpx abs7f
                                tst_x $7e,~fzc
9998 : 08              >            php         ;save flags
9999 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
999b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
999d : 68              >            pla         ;load status
999e : 48              >            pha
                       >            cmp_flag ~fzc
999f : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99a1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99a3 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
99a4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
99a6 : 48              >            pha         ;use stack to load status
99a7 : a280            >            ldx #$80     ;precharge index x
99a9 : 28              >            plp
                        
99aa : e07f                     cpx #$7f
                                tst_stat fc
99ac : 08              >            php         ;save status
99ad : 68              >            pla         ;use stack to retrieve status
99ae : 48              >            pha
                       >            cmp_flag fc
99af : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99b1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99b3 : 28              >            plp         ;restore status
                        
99b4 : ca                       dex
99b5 : e07f                     cpx #$7f
                                tst_stat fzc
99b7 : 08              >            php         ;save status
99b8 : 68              >            pla         ;use stack to retrieve status
99b9 : 48              >            pha
                       >            cmp_flag fzc
99ba : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99bc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99be : 28              >            plp         ;restore status
                        
99bf : ca                       dex
99c0 : e07f                     cpx #$7f
                                tst_x $7e,fn
99c2 : 08              >            php         ;save flags
99c3 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
99c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99c7 : 68              >            pla         ;load status
99c8 : 48              >            pha
                       >            cmp_flag fn
99c9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99cb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99cd : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
99ce : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
99d0 : 48              >            pha         ;use stack to load status
99d1 : a280            >            ldx #$80     ;precharge index x
99d3 : 28              >            plp
                        
99d4 : e07f                     cpx #$7f
                                tst_stat ~fnz
99d6 : 08              >            php         ;save status
99d7 : 68              >            pla         ;use stack to retrieve status
99d8 : 48              >            pha
                       >            cmp_flag ~fnz
99d9 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99db : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99dd : 28              >            plp         ;restore status
                        
99de : ca                       dex
99df : e07f                     cpx #$7f
                                tst_stat ~fn
99e1 : 08              >            php         ;save status
99e2 : 68              >            pla         ;use stack to retrieve status
99e3 : 48              >            pha
                       >            cmp_flag ~fn
99e4 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99e6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99e8 : 28              >            plp         ;restore status
                        
99e9 : ca                       dex
99ea : e07f                     cpx #$7f
                                tst_x $7e,~fzc
99ec : 08              >            php         ;save flags
99ed : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
99ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99f1 : 68              >            pla         ;load status
99f2 : 48              >            pha
                       >            cmp_flag ~fzc
99f3 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99f5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99f7 : 28              >            plp         ;restore status
                        
                                next_test
99f8 : ad0002          >            lda test_case   ;previous test
99fb : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
99fd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
99ff : a91b            >            lda #test_num   ;*** next tests' number
9a01 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
9a04 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9a06 : 48              >            pha         ;use stack to load status
9a07 : a080            >            ldy #$80     ;precharge index y
9a09 : 28              >            plp
                        
9a0a : c40f                     cpy zp7f
                                tst_stat fc
9a0c : 08              >            php         ;save status
9a0d : 68              >            pla         ;use stack to retrieve status
9a0e : 48              >            pha
                       >            cmp_flag fc
9a0f : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a11 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a13 : 28              >            plp         ;restore status
                        
9a14 : 88                       dey
9a15 : c40f                     cpy zp7f
                                tst_stat fzc
9a17 : 08              >            php         ;save status
9a18 : 68              >            pla         ;use stack to retrieve status
9a19 : 48              >            pha
                       >            cmp_flag fzc
9a1a : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a1c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a1e : 28              >            plp         ;restore status
                        
9a1f : 88                       dey
9a20 : c40f                     cpy zp7f
                                tst_y $7e,fn
9a22 : 08              >            php         ;save flags
9a23 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9a25 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a27 : 68              >            pla         ;load status
9a28 : 48              >            pha
                       >            cmp_flag fn
9a29 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a2b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a2d : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
9a2e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9a30 : 48              >            pha         ;use stack to load status
9a31 : a080            >            ldy #$80     ;precharge index y
9a33 : 28              >            plp
                        
9a34 : c40f                     cpy zp7f
                                tst_stat ~fnz
9a36 : 08              >            php         ;save status
9a37 : 68              >            pla         ;use stack to retrieve status
9a38 : 48              >            pha
                       >            cmp_flag ~fnz
9a39 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a3b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a3d : 28              >            plp         ;restore status
                        
9a3e : 88                       dey
9a3f : c40f                     cpy zp7f
                                tst_stat ~fn
9a41 : 08              >            php         ;save status
9a42 : 68              >            pla         ;use stack to retrieve status
9a43 : 48              >            pha
                       >            cmp_flag ~fn
9a44 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a46 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a48 : 28              >            plp         ;restore status
                        
9a49 : 88                       dey
9a4a : c40f                     cpy zp7f
                                tst_y $7e,~fzc
9a4c : 08              >            php         ;save flags
9a4d : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9a4f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a51 : 68              >            pla         ;load status
9a52 : 48              >            pha
                       >            cmp_flag ~fzc
9a53 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a55 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a57 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
9a58 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9a5a : 48              >            pha         ;use stack to load status
9a5b : a080            >            ldy #$80     ;precharge index y
9a5d : 28              >            plp
                        
9a5e : cc1c02                   cpy abs7f
                                tst_stat fc
9a61 : 08              >            php         ;save status
9a62 : 68              >            pla         ;use stack to retrieve status
9a63 : 48              >            pha
                       >            cmp_flag fc
9a64 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a66 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a68 : 28              >            plp         ;restore status
                        
9a69 : 88                       dey
9a6a : cc1c02                   cpy abs7f
                                tst_stat fzc
9a6d : 08              >            php         ;save status
9a6e : 68              >            pla         ;use stack to retrieve status
9a6f : 48              >            pha
                       >            cmp_flag fzc
9a70 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a72 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a74 : 28              >            plp         ;restore status
                        
9a75 : 88                       dey
9a76 : cc1c02                   cpy abs7f
                                tst_y $7e,fn
9a79 : 08              >            php         ;save flags
9a7a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9a7c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a7e : 68              >            pla         ;load status
9a7f : 48              >            pha
                       >            cmp_flag fn
9a80 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a82 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a84 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
9a85 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9a87 : 48              >            pha         ;use stack to load status
9a88 : a080            >            ldy #$80     ;precharge index y
9a8a : 28              >            plp
                        
9a8b : cc1c02                   cpy abs7f
                                tst_stat ~fnz
9a8e : 08              >            php         ;save status
9a8f : 68              >            pla         ;use stack to retrieve status
9a90 : 48              >            pha
                       >            cmp_flag ~fnz
9a91 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a95 : 28              >            plp         ;restore status
                        
9a96 : 88                       dey
9a97 : cc1c02                   cpy abs7f
                                tst_stat ~fn
9a9a : 08              >            php         ;save status
9a9b : 68              >            pla         ;use stack to retrieve status
9a9c : 48              >            pha
                       >            cmp_flag ~fn
9a9d : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a9f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9aa1 : 28              >            plp         ;restore status
                        
9aa2 : 88                       dey
9aa3 : cc1c02                   cpy abs7f
                                tst_y $7e,~fzc
9aa6 : 08              >            php         ;save flags
9aa7 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9aa9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9aab : 68              >            pla         ;load status
9aac : 48              >            pha
                       >            cmp_flag ~fzc
9aad : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9aaf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ab1 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
9ab2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9ab4 : 48              >            pha         ;use stack to load status
9ab5 : a080            >            ldy #$80     ;precharge index y
9ab7 : 28              >            plp
                        
9ab8 : c07f                     cpy #$7f
                                tst_stat fc
9aba : 08              >            php         ;save status
9abb : 68              >            pla         ;use stack to retrieve status
9abc : 48              >            pha
                       >            cmp_flag fc
9abd : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9abf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ac1 : 28              >            plp         ;restore status
                        
9ac2 : 88                       dey
9ac3 : c07f                     cpy #$7f
                                tst_stat fzc
9ac5 : 08              >            php         ;save status
9ac6 : 68              >            pla         ;use stack to retrieve status
9ac7 : 48              >            pha
                       >            cmp_flag fzc
9ac8 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9aca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9acc : 28              >            plp         ;restore status
                        
9acd : 88                       dey
9ace : c07f                     cpy #$7f
                                tst_y $7e,fn
9ad0 : 08              >            php         ;save flags
9ad1 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9ad3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ad5 : 68              >            pla         ;load status
9ad6 : 48              >            pha
                       >            cmp_flag fn
9ad7 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ad9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9adb : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
9adc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9ade : 48              >            pha         ;use stack to load status
9adf : a080            >            ldy #$80     ;precharge index y
9ae1 : 28              >            plp
                        
9ae2 : c07f                     cpy #$7f
                                tst_stat ~fnz
9ae4 : 08              >            php         ;save status
9ae5 : 68              >            pla         ;use stack to retrieve status
9ae6 : 48              >            pha
                       >            cmp_flag ~fnz
9ae7 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ae9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9aeb : 28              >            plp         ;restore status
                        
9aec : 88                       dey
9aed : c07f                     cpy #$7f
                                tst_stat ~fn
9aef : 08              >            php         ;save status
9af0 : 68              >            pla         ;use stack to retrieve status
9af1 : 48              >            pha
                       >            cmp_flag ~fn
9af2 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9af4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9af6 : 28              >            plp         ;restore status
                        
9af7 : 88                       dey
9af8 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
9afa : 08              >            php         ;save flags
9afb : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9afd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9aff : 68              >            pla         ;load status
9b00 : 48              >            pha
                       >            cmp_flag ~fzc
9b01 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b03 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b05 : 28              >            plp         ;restore status
                        
                                next_test
9b06 : ad0002          >            lda test_case   ;previous test
9b09 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
9b0b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
9b0d : a91c            >            lda #test_num   ;*** next tests' number
9b0f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
9b12 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9b14 : 48              >            pha         ;use stack to load status
9b15 : a980            >            lda #$80     ;precharge accu
9b17 : 28              >            plp
                        
9b18 : c50f                     cmp zp7f
                                tst_a $80,fc
9b1a : 08              >            php         ;save flags
9b1b : c980            >            cmp #$80     ;test result
                       >            trap_ne
9b1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b1f : 68              >            pla         ;load status
9b20 : 48              >            pha
                       >            cmp_flag fc
9b21 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b23 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b25 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9b26 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9b28 : 48              >            pha         ;use stack to load status
9b29 : a97f            >            lda #$7f     ;precharge accu
9b2b : 28              >            plp
                        
9b2c : c50f                     cmp zp7f
                                tst_a $7f,fzc
9b2e : 08              >            php         ;save flags
9b2f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9b31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b33 : 68              >            pla         ;load status
9b34 : 48              >            pha
                       >            cmp_flag fzc
9b35 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b37 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b39 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9b3a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9b3c : 48              >            pha         ;use stack to load status
9b3d : a97e            >            lda #$7e     ;precharge accu
9b3f : 28              >            plp
                        
9b40 : c50f                     cmp zp7f
                                tst_a $7e,fn
9b42 : 08              >            php         ;save flags
9b43 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9b45 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b47 : 68              >            pla         ;load status
9b48 : 48              >            pha
                       >            cmp_flag fn
9b49 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b4b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b4d : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9b4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9b50 : 48              >            pha         ;use stack to load status
9b51 : a980            >            lda #$80     ;precharge accu
9b53 : 28              >            plp
                        
9b54 : c50f                     cmp zp7f
                                tst_a $80,~fnz
9b56 : 08              >            php         ;save flags
9b57 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9b59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b5b : 68              >            pla         ;load status
9b5c : 48              >            pha
                       >            cmp_flag ~fnz
9b5d : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b5f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b61 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9b62 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9b64 : 48              >            pha         ;use stack to load status
9b65 : a97f            >            lda #$7f     ;precharge accu
9b67 : 28              >            plp
                        
9b68 : c50f                     cmp zp7f
                                tst_a $7f,~fn
9b6a : 08              >            php         ;save flags
9b6b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9b6d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b6f : 68              >            pla         ;load status
9b70 : 48              >            pha
                       >            cmp_flag ~fn
9b71 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b73 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b75 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9b76 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9b78 : 48              >            pha         ;use stack to load status
9b79 : a97e            >            lda #$7e     ;precharge accu
9b7b : 28              >            plp
                        
9b7c : c50f                     cmp zp7f
                                tst_a $7e,~fzc
9b7e : 08              >            php         ;save flags
9b7f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9b81 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b83 : 68              >            pla         ;load status
9b84 : 48              >            pha
                       >            cmp_flag ~fzc
9b85 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b87 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b89 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9b8a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9b8c : 48              >            pha         ;use stack to load status
9b8d : a980            >            lda #$80     ;precharge accu
9b8f : 28              >            plp
                        
9b90 : cd1c02                   cmp abs7f
                                tst_a $80,fc
9b93 : 08              >            php         ;save flags
9b94 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9b96 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b98 : 68              >            pla         ;load status
9b99 : 48              >            pha
                       >            cmp_flag fc
9b9a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b9c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b9e : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9b9f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9ba1 : 48              >            pha         ;use stack to load status
9ba2 : a97f            >            lda #$7f     ;precharge accu
9ba4 : 28              >            plp
                        
9ba5 : cd1c02                   cmp abs7f
                                tst_a $7f,fzc
9ba8 : 08              >            php         ;save flags
9ba9 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9bab : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bad : 68              >            pla         ;load status
9bae : 48              >            pha
                       >            cmp_flag fzc
9baf : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9bb1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bb3 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9bb4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9bb6 : 48              >            pha         ;use stack to load status
9bb7 : a97e            >            lda #$7e     ;precharge accu
9bb9 : 28              >            plp
                        
9bba : cd1c02                   cmp abs7f
                                tst_a $7e,fn
9bbd : 08              >            php         ;save flags
9bbe : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9bc0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bc2 : 68              >            pla         ;load status
9bc3 : 48              >            pha
                       >            cmp_flag fn
9bc4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9bc6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bc8 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9bc9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9bcb : 48              >            pha         ;use stack to load status
9bcc : a980            >            lda #$80     ;precharge accu
9bce : 28              >            plp
                        
9bcf : cd1c02                   cmp abs7f
                                tst_a $80,~fnz
9bd2 : 08              >            php         ;save flags
9bd3 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9bd5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bd7 : 68              >            pla         ;load status
9bd8 : 48              >            pha
                       >            cmp_flag ~fnz
9bd9 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9bdb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bdd : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9bde : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9be0 : 48              >            pha         ;use stack to load status
9be1 : a97f            >            lda #$7f     ;precharge accu
9be3 : 28              >            plp
                        
9be4 : cd1c02                   cmp abs7f
                                tst_a $7f,~fn
9be7 : 08              >            php         ;save flags
9be8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9bea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bec : 68              >            pla         ;load status
9bed : 48              >            pha
                       >            cmp_flag ~fn
9bee : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9bf0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bf2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9bf3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9bf5 : 48              >            pha         ;use stack to load status
9bf6 : a97e            >            lda #$7e     ;precharge accu
9bf8 : 28              >            plp
                        
9bf9 : cd1c02                   cmp abs7f
                                tst_a $7e,~fzc
9bfc : 08              >            php         ;save flags
9bfd : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9bff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c01 : 68              >            pla         ;load status
9c02 : 48              >            pha
                       >            cmp_flag ~fzc
9c03 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c05 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c07 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9c08 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9c0a : 48              >            pha         ;use stack to load status
9c0b : a980            >            lda #$80     ;precharge accu
9c0d : 28              >            plp
                        
9c0e : c97f                     cmp #$7f
                                tst_a $80,fc
9c10 : 08              >            php         ;save flags
9c11 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9c13 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c15 : 68              >            pla         ;load status
9c16 : 48              >            pha
                       >            cmp_flag fc
9c17 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c19 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c1b : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9c1c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9c1e : 48              >            pha         ;use stack to load status
9c1f : a97f            >            lda #$7f     ;precharge accu
9c21 : 28              >            plp
                        
9c22 : c97f                     cmp #$7f
                                tst_a $7f,fzc
9c24 : 08              >            php         ;save flags
9c25 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9c27 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c29 : 68              >            pla         ;load status
9c2a : 48              >            pha
                       >            cmp_flag fzc
9c2b : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c2d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c2f : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9c30 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9c32 : 48              >            pha         ;use stack to load status
9c33 : a97e            >            lda #$7e     ;precharge accu
9c35 : 28              >            plp
                        
9c36 : c97f                     cmp #$7f
                                tst_a $7e,fn
9c38 : 08              >            php         ;save flags
9c39 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9c3b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c3d : 68              >            pla         ;load status
9c3e : 48              >            pha
                       >            cmp_flag fn
9c3f : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c43 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9c44 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9c46 : 48              >            pha         ;use stack to load status
9c47 : a980            >            lda #$80     ;precharge accu
9c49 : 28              >            plp
                        
9c4a : c97f                     cmp #$7f
                                tst_a $80,~fnz
9c4c : 08              >            php         ;save flags
9c4d : c980            >            cmp #$80     ;test result
                       >            trap_ne
9c4f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c51 : 68              >            pla         ;load status
9c52 : 48              >            pha
                       >            cmp_flag ~fnz
9c53 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c55 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c57 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9c58 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9c5a : 48              >            pha         ;use stack to load status
9c5b : a97f            >            lda #$7f     ;precharge accu
9c5d : 28              >            plp
                        
9c5e : c97f                     cmp #$7f
                                tst_a $7f,~fn
9c60 : 08              >            php         ;save flags
9c61 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9c63 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c65 : 68              >            pla         ;load status
9c66 : 48              >            pha
                       >            cmp_flag ~fn
9c67 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c6b : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9c6c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9c6e : 48              >            pha         ;use stack to load status
9c6f : a97e            >            lda #$7e     ;precharge accu
9c71 : 28              >            plp
                        
9c72 : c97f                     cmp #$7f
                                tst_a $7e,~fzc
9c74 : 08              >            php         ;save flags
9c75 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9c77 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c79 : 68              >            pla         ;load status
9c7a : 48              >            pha
                       >            cmp_flag ~fzc
9c7b : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c7d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c7f : 28              >            plp         ;restore status
                        
                        
9c80 : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
9c82 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9c84 : 48              >            pha         ;use stack to load status
9c85 : a980            >            lda #$80     ;precharge accu
9c87 : 28              >            plp
                        
9c88 : d50b                     cmp zp1,x
                                tst_a $80,fc
9c8a : 08              >            php         ;save flags
9c8b : c980            >            cmp #$80     ;test result
                       >            trap_ne
9c8d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c8f : 68              >            pla         ;load status
9c90 : 48              >            pha
                       >            cmp_flag fc
9c91 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c95 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9c96 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9c98 : 48              >            pha         ;use stack to load status
9c99 : a97f            >            lda #$7f     ;precharge accu
9c9b : 28              >            plp
                        
9c9c : d50b                     cmp zp1,x
                                tst_a $7f,fzc
9c9e : 08              >            php         ;save flags
9c9f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9ca1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ca3 : 68              >            pla         ;load status
9ca4 : 48              >            pha
                       >            cmp_flag fzc
9ca5 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ca7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ca9 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9caa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9cac : 48              >            pha         ;use stack to load status
9cad : a97e            >            lda #$7e     ;precharge accu
9caf : 28              >            plp
                        
9cb0 : d50b                     cmp zp1,x
                                tst_a $7e,fn
9cb2 : 08              >            php         ;save flags
9cb3 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9cb5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cb7 : 68              >            pla         ;load status
9cb8 : 48              >            pha
                       >            cmp_flag fn
9cb9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9cbb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cbd : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9cbe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9cc0 : 48              >            pha         ;use stack to load status
9cc1 : a980            >            lda #$80     ;precharge accu
9cc3 : 28              >            plp
                        
9cc4 : d50b                     cmp zp1,x
                                tst_a $80,~fnz
9cc6 : 08              >            php         ;save flags
9cc7 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9cc9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ccb : 68              >            pla         ;load status
9ccc : 48              >            pha
                       >            cmp_flag ~fnz
9ccd : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ccf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cd1 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9cd2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9cd4 : 48              >            pha         ;use stack to load status
9cd5 : a97f            >            lda #$7f     ;precharge accu
9cd7 : 28              >            plp
                        
9cd8 : d50b                     cmp zp1,x
                                tst_a $7f,~fn
9cda : 08              >            php         ;save flags
9cdb : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9cdd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cdf : 68              >            pla         ;load status
9ce0 : 48              >            pha
                       >            cmp_flag ~fn
9ce1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ce3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ce5 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9ce6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9ce8 : 48              >            pha         ;use stack to load status
9ce9 : a97e            >            lda #$7e     ;precharge accu
9ceb : 28              >            plp
                        
9cec : d50b                     cmp zp1,x
                                tst_a $7e,~fzc
9cee : 08              >            php         ;save flags
9cef : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9cf1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cf3 : 68              >            pla         ;load status
9cf4 : 48              >            pha
                       >            cmp_flag ~fzc
9cf5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9cf7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cf9 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9cfa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9cfc : 48              >            pha         ;use stack to load status
9cfd : a980            >            lda #$80     ;precharge accu
9cff : 28              >            plp
                        
9d00 : dd1802                   cmp abs1,x
                                tst_a $80,fc
9d03 : 08              >            php         ;save flags
9d04 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9d06 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d08 : 68              >            pla         ;load status
9d09 : 48              >            pha
                       >            cmp_flag fc
9d0a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d0c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d0e : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9d0f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9d11 : 48              >            pha         ;use stack to load status
9d12 : a97f            >            lda #$7f     ;precharge accu
9d14 : 28              >            plp
                        
9d15 : dd1802                   cmp abs1,x
                                tst_a $7f,fzc
9d18 : 08              >            php         ;save flags
9d19 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9d1b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d1d : 68              >            pla         ;load status
9d1e : 48              >            pha
                       >            cmp_flag fzc
9d1f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d23 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9d24 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9d26 : 48              >            pha         ;use stack to load status
9d27 : a97e            >            lda #$7e     ;precharge accu
9d29 : 28              >            plp
                        
9d2a : dd1802                   cmp abs1,x
                                tst_a $7e,fn
9d2d : 08              >            php         ;save flags
9d2e : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9d30 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d32 : 68              >            pla         ;load status
9d33 : 48              >            pha
                       >            cmp_flag fn
9d34 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d36 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d38 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9d39 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9d3b : 48              >            pha         ;use stack to load status
9d3c : a980            >            lda #$80     ;precharge accu
9d3e : 28              >            plp
                        
9d3f : dd1802                   cmp abs1,x
                                tst_a $80,~fnz
9d42 : 08              >            php         ;save flags
9d43 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9d45 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d47 : 68              >            pla         ;load status
9d48 : 48              >            pha
                       >            cmp_flag ~fnz
9d49 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d4b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d4d : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9d4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9d50 : 48              >            pha         ;use stack to load status
9d51 : a97f            >            lda #$7f     ;precharge accu
9d53 : 28              >            plp
                        
9d54 : dd1802                   cmp abs1,x
                                tst_a $7f,~fn
9d57 : 08              >            php         ;save flags
9d58 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9d5a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d5c : 68              >            pla         ;load status
9d5d : 48              >            pha
                       >            cmp_flag ~fn
9d5e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d60 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d62 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9d63 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9d65 : 48              >            pha         ;use stack to load status
9d66 : a97e            >            lda #$7e     ;precharge accu
9d68 : 28              >            plp
                        
9d69 : dd1802                   cmp abs1,x
                                tst_a $7e,~fzc
9d6c : 08              >            php         ;save flags
9d6d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9d6f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d71 : 68              >            pla         ;load status
9d72 : 48              >            pha
                       >            cmp_flag ~fzc
9d73 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d75 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d77 : 28              >            plp         ;restore status
                        
                        
9d78 : a004                     ldy #4          ;with indexing by Y
9d7a : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
9d7c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9d7e : 48              >            pha         ;use stack to load status
9d7f : a980            >            lda #$80     ;precharge accu
9d81 : 28              >            plp
                        
9d82 : d91802                   cmp abs1,y
                                tst_a $80,fc
9d85 : 08              >            php         ;save flags
9d86 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9d88 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d8a : 68              >            pla         ;load status
9d8b : 48              >            pha
                       >            cmp_flag fc
9d8c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d8e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d90 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9d91 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9d93 : 48              >            pha         ;use stack to load status
9d94 : a97f            >            lda #$7f     ;precharge accu
9d96 : 28              >            plp
                        
9d97 : d91802                   cmp abs1,y
                                tst_a $7f,fzc
9d9a : 08              >            php         ;save flags
9d9b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9d9d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d9f : 68              >            pla         ;load status
9da0 : 48              >            pha
                       >            cmp_flag fzc
9da1 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9da3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9da5 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9da6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9da8 : 48              >            pha         ;use stack to load status
9da9 : a97e            >            lda #$7e     ;precharge accu
9dab : 28              >            plp
                        
9dac : d91802                   cmp abs1,y
                                tst_a $7e,fn
9daf : 08              >            php         ;save flags
9db0 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9db2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9db4 : 68              >            pla         ;load status
9db5 : 48              >            pha
                       >            cmp_flag fn
9db6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9db8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dba : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9dbb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9dbd : 48              >            pha         ;use stack to load status
9dbe : a980            >            lda #$80     ;precharge accu
9dc0 : 28              >            plp
                        
9dc1 : d91802                   cmp abs1,y
                                tst_a $80,~fnz
9dc4 : 08              >            php         ;save flags
9dc5 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9dc7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dc9 : 68              >            pla         ;load status
9dca : 48              >            pha
                       >            cmp_flag ~fnz
9dcb : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9dcd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dcf : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9dd0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9dd2 : 48              >            pha         ;use stack to load status
9dd3 : a97f            >            lda #$7f     ;precharge accu
9dd5 : 28              >            plp
                        
9dd6 : d91802                   cmp abs1,y
                                tst_a $7f,~fn
9dd9 : 08              >            php         ;save flags
9dda : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9ddc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dde : 68              >            pla         ;load status
9ddf : 48              >            pha
                       >            cmp_flag ~fn
9de0 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9de2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9de4 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9de5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9de7 : 48              >            pha         ;use stack to load status
9de8 : a97e            >            lda #$7e     ;precharge accu
9dea : 28              >            plp
                        
9deb : d91802                   cmp abs1,y
                                tst_a $7e,~fzc
9dee : 08              >            php         ;save flags
9def : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9df1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9df3 : 68              >            pla         ;load status
9df4 : 48              >            pha
                       >            cmp_flag ~fzc
9df5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9df7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9df9 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9dfa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9dfc : 48              >            pha         ;use stack to load status
9dfd : a980            >            lda #$80     ;precharge accu
9dff : 28              >            plp
                        
9e00 : c11c                     cmp (ind1,x)
                                tst_a $80,fc
9e02 : 08              >            php         ;save flags
9e03 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9e05 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e07 : 68              >            pla         ;load status
9e08 : 48              >            pha
                       >            cmp_flag fc
9e09 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e0b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e0d : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9e0e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9e10 : 48              >            pha         ;use stack to load status
9e11 : a97f            >            lda #$7f     ;precharge accu
9e13 : 28              >            plp
                        
9e14 : c11c                     cmp (ind1,x)
                                tst_a $7f,fzc
9e16 : 08              >            php         ;save flags
9e17 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9e19 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e1b : 68              >            pla         ;load status
9e1c : 48              >            pha
                       >            cmp_flag fzc
9e1d : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e1f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e21 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9e22 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9e24 : 48              >            pha         ;use stack to load status
9e25 : a97e            >            lda #$7e     ;precharge accu
9e27 : 28              >            plp
                        
9e28 : c11c                     cmp (ind1,x)
                                tst_a $7e,fn
9e2a : 08              >            php         ;save flags
9e2b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9e2d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e2f : 68              >            pla         ;load status
9e30 : 48              >            pha
                       >            cmp_flag fn
9e31 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e33 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e35 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9e36 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9e38 : 48              >            pha         ;use stack to load status
9e39 : a980            >            lda #$80     ;precharge accu
9e3b : 28              >            plp
                        
9e3c : c11c                     cmp (ind1,x)
                                tst_a $80,~fnz
9e3e : 08              >            php         ;save flags
9e3f : c980            >            cmp #$80     ;test result
                       >            trap_ne
9e41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e43 : 68              >            pla         ;load status
9e44 : 48              >            pha
                       >            cmp_flag ~fnz
9e45 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e47 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e49 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9e4a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9e4c : 48              >            pha         ;use stack to load status
9e4d : a97f            >            lda #$7f     ;precharge accu
9e4f : 28              >            plp
                        
9e50 : c11c                     cmp (ind1,x)
                                tst_a $7f,~fn
9e52 : 08              >            php         ;save flags
9e53 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9e55 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e57 : 68              >            pla         ;load status
9e58 : 48              >            pha
                       >            cmp_flag ~fn
9e59 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e5b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e5d : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9e5e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9e60 : 48              >            pha         ;use stack to load status
9e61 : a97e            >            lda #$7e     ;precharge accu
9e63 : 28              >            plp
                        
9e64 : c11c                     cmp (ind1,x)
                                tst_a $7e,~fzc
9e66 : 08              >            php         ;save flags
9e67 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9e69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e6b : 68              >            pla         ;load status
9e6c : 48              >            pha
                       >            cmp_flag ~fzc
9e6d : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e6f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e71 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9e72 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9e74 : 48              >            pha         ;use stack to load status
9e75 : a980            >            lda #$80     ;precharge accu
9e77 : 28              >            plp
                        
9e78 : d11c                     cmp (ind1),y
                                tst_a $80,fc
9e7a : 08              >            php         ;save flags
9e7b : c980            >            cmp #$80     ;test result
                       >            trap_ne
9e7d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e7f : 68              >            pla         ;load status
9e80 : 48              >            pha
                       >            cmp_flag fc
9e81 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e83 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e85 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9e86 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9e88 : 48              >            pha         ;use stack to load status
9e89 : a97f            >            lda #$7f     ;precharge accu
9e8b : 28              >            plp
                        
9e8c : d11c                     cmp (ind1),y
                                tst_a $7f,fzc
9e8e : 08              >            php         ;save flags
9e8f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9e91 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e93 : 68              >            pla         ;load status
9e94 : 48              >            pha
                       >            cmp_flag fzc
9e95 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e97 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e99 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9e9a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9e9c : 48              >            pha         ;use stack to load status
9e9d : a97e            >            lda #$7e     ;precharge accu
9e9f : 28              >            plp
                        
9ea0 : d11c                     cmp (ind1),y
                                tst_a $7e,fn
9ea2 : 08              >            php         ;save flags
9ea3 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9ea5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ea7 : 68              >            pla         ;load status
9ea8 : 48              >            pha
                       >            cmp_flag fn
9ea9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9eab : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ead : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9eae : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9eb0 : 48              >            pha         ;use stack to load status
9eb1 : a980            >            lda #$80     ;precharge accu
9eb3 : 28              >            plp
                        
9eb4 : d11c                     cmp (ind1),y
                                tst_a $80,~fnz
9eb6 : 08              >            php         ;save flags
9eb7 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9eb9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ebb : 68              >            pla         ;load status
9ebc : 48              >            pha
                       >            cmp_flag ~fnz
9ebd : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ebf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ec1 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9ec2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9ec4 : 48              >            pha         ;use stack to load status
9ec5 : a97f            >            lda #$7f     ;precharge accu
9ec7 : 28              >            plp
                        
9ec8 : d11c                     cmp (ind1),y
                                tst_a $7f,~fn
9eca : 08              >            php         ;save flags
9ecb : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9ecd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ecf : 68              >            pla         ;load status
9ed0 : 48              >            pha
                       >            cmp_flag ~fn
9ed1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ed3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ed5 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9ed6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9ed8 : 48              >            pha         ;use stack to load status
9ed9 : a97e            >            lda #$7e     ;precharge accu
9edb : 28              >            plp
                        
9edc : d11c                     cmp (ind1),y
                                tst_a $7e,~fzc
9ede : 08              >            php         ;save flags
9edf : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9ee1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ee3 : 68              >            pla         ;load status
9ee4 : 48              >            pha
                       >            cmp_flag ~fzc
9ee5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ee7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ee9 : 28              >            plp         ;restore status
                        
                                next_test
9eea : ad0002          >            lda test_case   ;previous test
9eed : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
9eef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
9ef1 : a91d            >            lda #test_num   ;*** next tests' number
9ef3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
9ef6 : a205                     ldx #5
9ef8 :                  tasl
                                set_ax zps,0
                       >            load_flag 0
9ef8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9efa : 48              >            pha         ;use stack to load status
9efb : b509            >            lda zps,x    ;precharge accu
9efd : 28              >            plp
                        
9efe : 0a                       asl a
                                tst_ax rASL,fASL,0
9eff : 08              >            php         ;save flags
9f00 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
9f03 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f05 : 68              >            pla         ;load status
                       >            eor_flag 0
9f06 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9f08 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
9f0b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f0d : ca                       dex
9f0e : 10e8                     bpl tasl
9f10 : a205                     ldx #5
9f12 :                  tasl1
                                set_ax zps,$ff
                       >            load_flag $ff
9f12 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9f14 : 48              >            pha         ;use stack to load status
9f15 : b509            >            lda zps,x    ;precharge accu
9f17 : 28              >            plp
                        
9f18 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
9f19 : 08              >            php         ;save flags
9f1a : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
9f1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f1f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9f20 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9f22 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
9f25 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f27 : ca                       dex
9f28 : 10e8                     bpl tasl1
                        
9f2a : a205                     ldx #5
9f2c :                  tlsr
                                set_ax zps,0
                       >            load_flag 0
9f2c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9f2e : 48              >            pha         ;use stack to load status
9f2f : b509            >            lda zps,x    ;precharge accu
9f31 : 28              >            plp
                        
9f32 : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
9f33 : 08              >            php         ;save flags
9f34 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
9f37 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f39 : 68              >            pla         ;load status
                       >            eor_flag 0
9f3a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9f3c : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
9f3f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f41 : ca                       dex
9f42 : 10e8                     bpl tlsr
9f44 : a205                     ldx #5
9f46 :                  tlsr1
                                set_ax zps,$ff
                       >            load_flag $ff
9f46 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9f48 : 48              >            pha         ;use stack to load status
9f49 : b509            >            lda zps,x    ;precharge accu
9f4b : 28              >            plp
                        
9f4c : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
9f4d : 08              >            php         ;save flags
9f4e : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
9f51 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f53 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9f54 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9f56 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
9f59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f5b : ca                       dex
9f5c : 10e8                     bpl tlsr1
                        
9f5e : a205                     ldx #5
9f60 :                  trol
                                set_ax zps,0
                       >            load_flag 0
9f60 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9f62 : 48              >            pha         ;use stack to load status
9f63 : b509            >            lda zps,x    ;precharge accu
9f65 : 28              >            plp
                        
9f66 : 2a                       rol a
                                tst_ax rROL,fROL,0
9f67 : 08              >            php         ;save flags
9f68 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
9f6b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f6d : 68              >            pla         ;load status
                       >            eor_flag 0
9f6e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9f70 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
9f73 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f75 : ca                       dex
9f76 : 10e8                     bpl trol
9f78 : a205                     ldx #5
9f7a :                  trol1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
9f7a : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
9f7c : 48              >            pha         ;use stack to load status
9f7d : b509            >            lda zps,x    ;precharge accu
9f7f : 28              >            plp
                        
9f80 : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
9f81 : 08              >            php         ;save flags
9f82 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
9f85 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f87 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9f88 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9f8a : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
9f8d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f8f : ca                       dex
9f90 : 10e8                     bpl trol1
                        
9f92 : a205                     ldx #5
9f94 :                  trolc
                                set_ax zps,fc
                       >            load_flag fc
9f94 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
9f96 : 48              >            pha         ;use stack to load status
9f97 : b509            >            lda zps,x    ;precharge accu
9f99 : 28              >            plp
                        
9f9a : 2a                       rol a
                                tst_ax rROLc,fROLc,0
9f9b : 08              >            php         ;save flags
9f9c : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
9f9f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9fa1 : 68              >            pla         ;load status
                       >            eor_flag 0
9fa2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9fa4 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
9fa7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9fa9 : ca                       dex
9faa : 10e8                     bpl trolc
9fac : a205                     ldx #5
9fae :                  trolc1
                                set_ax zps,$ff
                       >            load_flag $ff
9fae : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9fb0 : 48              >            pha         ;use stack to load status
9fb1 : b509            >            lda zps,x    ;precharge accu
9fb3 : 28              >            plp
                        
9fb4 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
9fb5 : 08              >            php         ;save flags
9fb6 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
9fb9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9fbb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9fbc : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9fbe : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
9fc1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9fc3 : ca                       dex
9fc4 : 10e8                     bpl trolc1
                        
9fc6 : a205                     ldx #5
9fc8 :                  tror
                                set_ax zps,0
                       >            load_flag 0
9fc8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9fca : 48              >            pha         ;use stack to load status
9fcb : b509            >            lda zps,x    ;precharge accu
9fcd : 28              >            plp
                        
9fce : 6a                       ror a
                                tst_ax rROR,fROR,0
9fcf : 08              >            php         ;save flags
9fd0 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
9fd3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9fd5 : 68              >            pla         ;load status
                       >            eor_flag 0
9fd6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9fd8 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
9fdb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9fdd : ca                       dex
9fde : 10e8                     bpl tror
9fe0 : a205                     ldx #5
9fe2 :                  tror1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
9fe2 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
9fe4 : 48              >            pha         ;use stack to load status
9fe5 : b509            >            lda zps,x    ;precharge accu
9fe7 : 28              >            plp
                        
9fe8 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
9fe9 : 08              >            php         ;save flags
9fea : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
9fed : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9fef : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9ff0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9ff2 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
9ff5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9ff7 : ca                       dex
9ff8 : 10e8                     bpl tror1
                        
9ffa : a205                     ldx #5
9ffc :                  trorc
                                set_ax zps,fc
                       >            load_flag fc
9ffc : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
9ffe : 48              >            pha         ;use stack to load status
9fff : b509            >            lda zps,x    ;precharge accu
a001 : 28              >            plp
                        
a002 : 6a                       ror a
                                tst_ax rRORc,fRORc,0
a003 : 08              >            php         ;save flags
a004 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a007 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a009 : 68              >            pla         ;load status
                       >            eor_flag 0
a00a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a00c : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
a00f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a011 : ca                       dex
a012 : 10e8                     bpl trorc
a014 : a205                     ldx #5
a016 :                  trorc1
                                set_ax zps,$ff
                       >            load_flag $ff
a016 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a018 : 48              >            pha         ;use stack to load status
a019 : b509            >            lda zps,x    ;precharge accu
a01b : 28              >            plp
                        
a01c : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
a01d : 08              >            php         ;save flags
a01e : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a021 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a023 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a024 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a026 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
a029 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a02b : ca                       dex
a02c : 10e8                     bpl trorc1
                                next_test
a02e : ad0002          >            lda test_case   ;previous test
a031 : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a033 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
a035 : a91e            >            lda #test_num   ;*** next tests' number
a037 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
a03a : a205                     ldx #5
a03c :                  tasl2
                                set_z zps,0
                       >            load_flag 0
a03c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a03e : 48              >            pha         ;use stack to load status
a03f : b509            >            lda zps,x    ;load to zeropage
a041 : 8502            >            sta zpt
a043 : 28              >            plp
                        
a044 : 0602                     asl zpt
                                tst_z rASL,fASL,0
a046 : 08              >            php         ;save flags
a047 : a502            >            lda zpt
a049 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a04c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a04e : 68              >            pla         ;load status
                       >            eor_flag 0
a04f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a051 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a054 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a056 : ca                       dex
a057 : 10e3                     bpl tasl2
a059 : a205                     ldx #5
a05b :                  tasl3
                                set_z zps,$ff
                       >            load_flag $ff
a05b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a05d : 48              >            pha         ;use stack to load status
a05e : b509            >            lda zps,x    ;load to zeropage
a060 : 8502            >            sta zpt
a062 : 28              >            plp
                        
a063 : 0602                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
a065 : 08              >            php         ;save flags
a066 : a502            >            lda zpt
a068 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a06b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a06d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a06e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a070 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a073 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a075 : ca                       dex
a076 : 10e3                     bpl tasl3
                        
a078 : a205                     ldx #5
a07a :                  tlsr2
                                set_z zps,0
                       >            load_flag 0
a07a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a07c : 48              >            pha         ;use stack to load status
a07d : b509            >            lda zps,x    ;load to zeropage
a07f : 8502            >            sta zpt
a081 : 28              >            plp
                        
a082 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,0
a084 : 08              >            php         ;save flags
a085 : a502            >            lda zpt
a087 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a08a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a08c : 68              >            pla         ;load status
                       >            eor_flag 0
a08d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a08f : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a092 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a094 : ca                       dex
a095 : 10e3                     bpl tlsr2
a097 : a205                     ldx #5
a099 :                  tlsr3
                                set_z zps,$ff
                       >            load_flag $ff
a099 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a09b : 48              >            pha         ;use stack to load status
a09c : b509            >            lda zps,x    ;load to zeropage
a09e : 8502            >            sta zpt
a0a0 : 28              >            plp
                        
a0a1 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
a0a3 : 08              >            php         ;save flags
a0a4 : a502            >            lda zpt
a0a6 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a0a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a0ab : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a0ac : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a0ae : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a0b1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a0b3 : ca                       dex
a0b4 : 10e3                     bpl tlsr3
                        
a0b6 : a205                     ldx #5
a0b8 :                  trol2
                                set_z zps,0
                       >            load_flag 0
a0b8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a0ba : 48              >            pha         ;use stack to load status
a0bb : b509            >            lda zps,x    ;load to zeropage
a0bd : 8502            >            sta zpt
a0bf : 28              >            plp
                        
a0c0 : 2602                     rol zpt
                                tst_z rROL,fROL,0
a0c2 : 08              >            php         ;save flags
a0c3 : a502            >            lda zpt
a0c5 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a0c8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a0ca : 68              >            pla         ;load status
                       >            eor_flag 0
a0cb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a0cd : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a0d0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a0d2 : ca                       dex
a0d3 : 10e3                     bpl trol2
a0d5 : a205                     ldx #5
a0d7 :                  trol3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
a0d7 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a0d9 : 48              >            pha         ;use stack to load status
a0da : b509            >            lda zps,x    ;load to zeropage
a0dc : 8502            >            sta zpt
a0de : 28              >            plp
                        
a0df : 2602                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
a0e1 : 08              >            php         ;save flags
a0e2 : a502            >            lda zpt
a0e4 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a0e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a0e9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a0ea : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a0ec : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a0ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a0f1 : ca                       dex
a0f2 : 10e3                     bpl trol3
                        
a0f4 : a205                     ldx #5
a0f6 :                  trolc2
                                set_z zps,fc
                       >            load_flag fc
a0f6 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a0f8 : 48              >            pha         ;use stack to load status
a0f9 : b509            >            lda zps,x    ;load to zeropage
a0fb : 8502            >            sta zpt
a0fd : 28              >            plp
                        
a0fe : 2602                     rol zpt
                                tst_z rROLc,fROLc,0
a100 : 08              >            php         ;save flags
a101 : a502            >            lda zpt
a103 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a106 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a108 : 68              >            pla         ;load status
                       >            eor_flag 0
a109 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a10b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a10e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a110 : ca                       dex
a111 : 10e3                     bpl trolc2
a113 : a205                     ldx #5
a115 :                  trolc3
                                set_z zps,$ff
                       >            load_flag $ff
a115 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a117 : 48              >            pha         ;use stack to load status
a118 : b509            >            lda zps,x    ;load to zeropage
a11a : 8502            >            sta zpt
a11c : 28              >            plp
                        
a11d : 2602                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
a11f : 08              >            php         ;save flags
a120 : a502            >            lda zpt
a122 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a125 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a127 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a128 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a12a : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a12d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a12f : ca                       dex
a130 : 10e3                     bpl trolc3
                        
a132 : a205                     ldx #5
a134 :                  tror2
                                set_z zps,0
                       >            load_flag 0
a134 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a136 : 48              >            pha         ;use stack to load status
a137 : b509            >            lda zps,x    ;load to zeropage
a139 : 8502            >            sta zpt
a13b : 28              >            plp
                        
a13c : 6602                     ror zpt
                                tst_z rROR,fROR,0
a13e : 08              >            php         ;save flags
a13f : a502            >            lda zpt
a141 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a144 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a146 : 68              >            pla         ;load status
                       >            eor_flag 0
a147 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a149 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a14c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a14e : ca                       dex
a14f : 10e3                     bpl tror2
a151 : a205                     ldx #5
a153 :                  tror3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
a153 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a155 : 48              >            pha         ;use stack to load status
a156 : b509            >            lda zps,x    ;load to zeropage
a158 : 8502            >            sta zpt
a15a : 28              >            plp
                        
a15b : 6602                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
a15d : 08              >            php         ;save flags
a15e : a502            >            lda zpt
a160 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a163 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a165 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a166 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a168 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a16b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a16d : ca                       dex
a16e : 10e3                     bpl tror3
                        
a170 : a205                     ldx #5
a172 :                  trorc2
                                set_z zps,fc
                       >            load_flag fc
a172 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a174 : 48              >            pha         ;use stack to load status
a175 : b509            >            lda zps,x    ;load to zeropage
a177 : 8502            >            sta zpt
a179 : 28              >            plp
                        
a17a : 6602                     ror zpt
                                tst_z rRORc,fRORc,0
a17c : 08              >            php         ;save flags
a17d : a502            >            lda zpt
a17f : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a182 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a184 : 68              >            pla         ;load status
                       >            eor_flag 0
a185 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a187 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a18a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a18c : ca                       dex
a18d : 10e3                     bpl trorc2
a18f : a205                     ldx #5
a191 :                  trorc3
                                set_z zps,$ff
                       >            load_flag $ff
a191 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a193 : 48              >            pha         ;use stack to load status
a194 : b509            >            lda zps,x    ;load to zeropage
a196 : 8502            >            sta zpt
a198 : 28              >            plp
                        
a199 : 6602                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
a19b : 08              >            php         ;save flags
a19c : a502            >            lda zpt
a19e : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a1a1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a1a3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a1a4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a1a6 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a1a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a1ab : ca                       dex
a1ac : 10e3                     bpl trorc3
                                next_test
a1ae : ad0002          >            lda test_case   ;previous test
a1b1 : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a1b3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
a1b5 : a91f            >            lda #test_num   ;*** next tests' number
a1b7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
a1ba : a205                     ldx #5
a1bc :                  tasl4
                                set_abs zps,0
                       >            load_flag 0
a1bc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a1be : 48              >            pha         ;use stack to load status
a1bf : b509            >            lda zps,x    ;load to memory
a1c1 : 8d0302          >            sta abst
a1c4 : 28              >            plp
                        
a1c5 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
a1c8 : 08              >            php         ;save flags
a1c9 : ad0302          >            lda abst
a1cc : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a1cf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a1d1 : 68              >            pla         ;load status
                       >            eor_flag 0
a1d2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a1d4 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a1d7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a1d9 : ca                       dex
a1da : 10e0                     bpl tasl4
a1dc : a205                     ldx #5
a1de :                  tasl5
                                set_abs zps,$ff
                       >            load_flag $ff
a1de : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a1e0 : 48              >            pha         ;use stack to load status
a1e1 : b509            >            lda zps,x    ;load to memory
a1e3 : 8d0302          >            sta abst
a1e6 : 28              >            plp
                        
a1e7 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
a1ea : 08              >            php         ;save flags
a1eb : ad0302          >            lda abst
a1ee : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a1f1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a1f3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a1f4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a1f6 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a1f9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a1fb : ca                       dex
a1fc : 10e0                     bpl tasl5
                        
a1fe : a205                     ldx #5
a200 :                  tlsr4
                                set_abs zps,0
                       >            load_flag 0
a200 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a202 : 48              >            pha         ;use stack to load status
a203 : b509            >            lda zps,x    ;load to memory
a205 : 8d0302          >            sta abst
a208 : 28              >            plp
                        
a209 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
a20c : 08              >            php         ;save flags
a20d : ad0302          >            lda abst
a210 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a213 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a215 : 68              >            pla         ;load status
                       >            eor_flag 0
a216 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a218 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a21b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a21d : ca                       dex
a21e : 10e0                     bpl tlsr4
a220 : a205                     ldx #5
a222 :                  tlsr5
                                set_abs zps,$ff
                       >            load_flag $ff
a222 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a224 : 48              >            pha         ;use stack to load status
a225 : b509            >            lda zps,x    ;load to memory
a227 : 8d0302          >            sta abst
a22a : 28              >            plp
                        
a22b : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
a22e : 08              >            php         ;save flags
a22f : ad0302          >            lda abst
a232 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a235 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a237 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a238 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a23a : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a23d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a23f : ca                       dex
a240 : 10e0                     bpl tlsr5
                        
a242 : a205                     ldx #5
a244 :                  trol4
                                set_abs zps,0
                       >            load_flag 0
a244 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a246 : 48              >            pha         ;use stack to load status
a247 : b509            >            lda zps,x    ;load to memory
a249 : 8d0302          >            sta abst
a24c : 28              >            plp
                        
a24d : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
a250 : 08              >            php         ;save flags
a251 : ad0302          >            lda abst
a254 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a257 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a259 : 68              >            pla         ;load status
                       >            eor_flag 0
a25a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a25c : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a25f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a261 : ca                       dex
a262 : 10e0                     bpl trol4
a264 : a205                     ldx #5
a266 :                  trol5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
a266 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a268 : 48              >            pha         ;use stack to load status
a269 : b509            >            lda zps,x    ;load to memory
a26b : 8d0302          >            sta abst
a26e : 28              >            plp
                        
a26f : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
a272 : 08              >            php         ;save flags
a273 : ad0302          >            lda abst
a276 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a279 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a27b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a27c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a27e : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a281 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a283 : ca                       dex
a284 : 10e0                     bpl trol5
                        
a286 : a205                     ldx #5
a288 :                  trolc4
                                set_abs zps,fc
                       >            load_flag fc
a288 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a28a : 48              >            pha         ;use stack to load status
a28b : b509            >            lda zps,x    ;load to memory
a28d : 8d0302          >            sta abst
a290 : 28              >            plp
                        
a291 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
a294 : 08              >            php         ;save flags
a295 : ad0302          >            lda abst
a298 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a29b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a29d : 68              >            pla         ;load status
                       >            eor_flag 0
a29e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a2a0 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a2a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a2a5 : ca                       dex
a2a6 : 10e0                     bpl trolc4
a2a8 : a205                     ldx #5
a2aa :                  trolc5
                                set_abs zps,$ff
                       >            load_flag $ff
a2aa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a2ac : 48              >            pha         ;use stack to load status
a2ad : b509            >            lda zps,x    ;load to memory
a2af : 8d0302          >            sta abst
a2b2 : 28              >            plp
                        
a2b3 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
a2b6 : 08              >            php         ;save flags
a2b7 : ad0302          >            lda abst
a2ba : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a2bd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a2bf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a2c0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a2c2 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a2c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a2c7 : ca                       dex
a2c8 : 10e0                     bpl trolc5
                        
a2ca : a205                     ldx #5
a2cc :                  tror4
                                set_abs zps,0
                       >            load_flag 0
a2cc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a2ce : 48              >            pha         ;use stack to load status
a2cf : b509            >            lda zps,x    ;load to memory
a2d1 : 8d0302          >            sta abst
a2d4 : 28              >            plp
                        
a2d5 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
a2d8 : 08              >            php         ;save flags
a2d9 : ad0302          >            lda abst
a2dc : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a2df : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a2e1 : 68              >            pla         ;load status
                       >            eor_flag 0
a2e2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a2e4 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a2e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a2e9 : ca                       dex
a2ea : 10e0                     bpl tror4
a2ec : a205                     ldx #5
a2ee :                  tror5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
a2ee : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a2f0 : 48              >            pha         ;use stack to load status
a2f1 : b509            >            lda zps,x    ;load to memory
a2f3 : 8d0302          >            sta abst
a2f6 : 28              >            plp
                        
a2f7 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
a2fa : 08              >            php         ;save flags
a2fb : ad0302          >            lda abst
a2fe : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a301 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a303 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a304 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a306 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a309 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a30b : ca                       dex
a30c : 10e0                     bpl tror5
                        
a30e : a205                     ldx #5
a310 :                  trorc4
                                set_abs zps,fc
                       >            load_flag fc
a310 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a312 : 48              >            pha         ;use stack to load status
a313 : b509            >            lda zps,x    ;load to memory
a315 : 8d0302          >            sta abst
a318 : 28              >            plp
                        
a319 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
a31c : 08              >            php         ;save flags
a31d : ad0302          >            lda abst
a320 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a323 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a325 : 68              >            pla         ;load status
                       >            eor_flag 0
a326 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a328 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a32b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a32d : ca                       dex
a32e : 10e0                     bpl trorc4
a330 : a205                     ldx #5
a332 :                  trorc5
                                set_abs zps,$ff
                       >            load_flag $ff
a332 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a334 : 48              >            pha         ;use stack to load status
a335 : b509            >            lda zps,x    ;load to memory
a337 : 8d0302          >            sta abst
a33a : 28              >            plp
                        
a33b : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
a33e : 08              >            php         ;save flags
a33f : ad0302          >            lda abst
a342 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a345 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a347 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a348 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a34a : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a34d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a34f : ca                       dex
a350 : 10e0                     bpl trorc5
                                next_test
a352 : ad0002          >            lda test_case   ;previous test
a355 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a357 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
a359 : a920            >            lda #test_num   ;*** next tests' number
a35b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
a35e : a205                     ldx #5
a360 :                  tasl6
                                set_zx zps,0
                       >            load_flag 0
a360 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a362 : 48              >            pha         ;use stack to load status
a363 : b509            >            lda zps,x    ;load to indexed zeropage
a365 : 9502            >            sta zpt,x
a367 : 28              >            plp
                        
a368 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,0
a36a : 08              >            php         ;save flags
a36b : b502            >            lda zpt,x
a36d : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a370 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a372 : 68              >            pla         ;load status
                       >            eor_flag 0
a373 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a375 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a378 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a37a : ca                       dex
a37b : 10e3                     bpl tasl6
a37d : a205                     ldx #5
a37f :                  tasl7
                                set_zx zps,$ff
                       >            load_flag $ff
a37f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a381 : 48              >            pha         ;use stack to load status
a382 : b509            >            lda zps,x    ;load to indexed zeropage
a384 : 9502            >            sta zpt,x
a386 : 28              >            plp
                        
a387 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
a389 : 08              >            php         ;save flags
a38a : b502            >            lda zpt,x
a38c : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a38f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a391 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a392 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a394 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a397 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a399 : ca                       dex
a39a : 10e3                     bpl tasl7
                        
a39c : a205                     ldx #5
a39e :                  tlsr6
                                set_zx zps,0
                       >            load_flag 0
a39e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a3a0 : 48              >            pha         ;use stack to load status
a3a1 : b509            >            lda zps,x    ;load to indexed zeropage
a3a3 : 9502            >            sta zpt,x
a3a5 : 28              >            plp
                        
a3a6 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
a3a8 : 08              >            php         ;save flags
a3a9 : b502            >            lda zpt,x
a3ab : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a3ae : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a3b0 : 68              >            pla         ;load status
                       >            eor_flag 0
a3b1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a3b3 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a3b6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a3b8 : ca                       dex
a3b9 : 10e3                     bpl tlsr6
a3bb : a205                     ldx #5
a3bd :                  tlsr7
                                set_zx zps,$ff
                       >            load_flag $ff
a3bd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a3bf : 48              >            pha         ;use stack to load status
a3c0 : b509            >            lda zps,x    ;load to indexed zeropage
a3c2 : 9502            >            sta zpt,x
a3c4 : 28              >            plp
                        
a3c5 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
a3c7 : 08              >            php         ;save flags
a3c8 : b502            >            lda zpt,x
a3ca : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a3cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a3cf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a3d0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a3d2 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a3d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a3d7 : ca                       dex
a3d8 : 10e3                     bpl tlsr7
                        
a3da : a205                     ldx #5
a3dc :                  trol6
                                set_zx zps,0
                       >            load_flag 0
a3dc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a3de : 48              >            pha         ;use stack to load status
a3df : b509            >            lda zps,x    ;load to indexed zeropage
a3e1 : 9502            >            sta zpt,x
a3e3 : 28              >            plp
                        
a3e4 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,0
a3e6 : 08              >            php         ;save flags
a3e7 : b502            >            lda zpt,x
a3e9 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a3ec : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a3ee : 68              >            pla         ;load status
                       >            eor_flag 0
a3ef : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a3f1 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a3f4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a3f6 : ca                       dex
a3f7 : 10e3                     bpl trol6
a3f9 : a205                     ldx #5
a3fb :                  trol7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
a3fb : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a3fd : 48              >            pha         ;use stack to load status
a3fe : b509            >            lda zps,x    ;load to indexed zeropage
a400 : 9502            >            sta zpt,x
a402 : 28              >            plp
                        
a403 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
a405 : 08              >            php         ;save flags
a406 : b502            >            lda zpt,x
a408 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a40b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a40d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a40e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a410 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a413 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a415 : ca                       dex
a416 : 10e3                     bpl trol7
                        
a418 : a205                     ldx #5
a41a :                  trolc6
                                set_zx zps,fc
                       >            load_flag fc
a41a : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a41c : 48              >            pha         ;use stack to load status
a41d : b509            >            lda zps,x    ;load to indexed zeropage
a41f : 9502            >            sta zpt,x
a421 : 28              >            plp
                        
a422 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,0
a424 : 08              >            php         ;save flags
a425 : b502            >            lda zpt,x
a427 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a42a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a42c : 68              >            pla         ;load status
                       >            eor_flag 0
a42d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a42f : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a432 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a434 : ca                       dex
a435 : 10e3                     bpl trolc6
a437 : a205                     ldx #5
a439 :                  trolc7
                                set_zx zps,$ff
                       >            load_flag $ff
a439 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a43b : 48              >            pha         ;use stack to load status
a43c : b509            >            lda zps,x    ;load to indexed zeropage
a43e : 9502            >            sta zpt,x
a440 : 28              >            plp
                        
a441 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
a443 : 08              >            php         ;save flags
a444 : b502            >            lda zpt,x
a446 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a449 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a44b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a44c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a44e : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a451 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a453 : ca                       dex
a454 : 10e3                     bpl trolc7
                        
a456 : a205                     ldx #5
a458 :                  tror6
                                set_zx zps,0
                       >            load_flag 0
a458 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a45a : 48              >            pha         ;use stack to load status
a45b : b509            >            lda zps,x    ;load to indexed zeropage
a45d : 9502            >            sta zpt,x
a45f : 28              >            plp
                        
a460 : 7602                     ror zpt,x
                                tst_zx rROR,fROR,0
a462 : 08              >            php         ;save flags
a463 : b502            >            lda zpt,x
a465 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a468 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a46a : 68              >            pla         ;load status
                       >            eor_flag 0
a46b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a46d : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a470 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a472 : ca                       dex
a473 : 10e3                     bpl tror6
a475 : a205                     ldx #5
a477 :                  tror7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
a477 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a479 : 48              >            pha         ;use stack to load status
a47a : b509            >            lda zps,x    ;load to indexed zeropage
a47c : 9502            >            sta zpt,x
a47e : 28              >            plp
                        
a47f : 7602                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
a481 : 08              >            php         ;save flags
a482 : b502            >            lda zpt,x
a484 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a487 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a489 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a48a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a48c : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a48f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a491 : ca                       dex
a492 : 10e3                     bpl tror7
                        
a494 : a205                     ldx #5
a496 :                  trorc6
                                set_zx zps,fc
                       >            load_flag fc
a496 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a498 : 48              >            pha         ;use stack to load status
a499 : b509            >            lda zps,x    ;load to indexed zeropage
a49b : 9502            >            sta zpt,x
a49d : 28              >            plp
                        
a49e : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,0
a4a0 : 08              >            php         ;save flags
a4a1 : b502            >            lda zpt,x
a4a3 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a4a6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a4a8 : 68              >            pla         ;load status
                       >            eor_flag 0
a4a9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a4ab : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a4ae : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a4b0 : ca                       dex
a4b1 : 10e3                     bpl trorc6
a4b3 : a205                     ldx #5
a4b5 :                  trorc7
                                set_zx zps,$ff
                       >            load_flag $ff
a4b5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a4b7 : 48              >            pha         ;use stack to load status
a4b8 : b509            >            lda zps,x    ;load to indexed zeropage
a4ba : 9502            >            sta zpt,x
a4bc : 28              >            plp
                        
a4bd : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
a4bf : 08              >            php         ;save flags
a4c0 : b502            >            lda zpt,x
a4c2 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a4c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a4c7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a4c8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a4ca : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a4cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a4cf : ca                       dex
a4d0 : 10e3                     bpl trorc7
                                next_test
a4d2 : ad0002          >            lda test_case   ;previous test
a4d5 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a4d7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
a4d9 : a921            >            lda #test_num   ;*** next tests' number
a4db : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
a4de : a205                     ldx #5
a4e0 :                  tasl8
                                set_absx zps,0
                       >            load_flag 0
a4e0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a4e2 : 48              >            pha         ;use stack to load status
a4e3 : b509            >            lda zps,x    ;load to indexed memory
a4e5 : 9d0302          >            sta abst,x
a4e8 : 28              >            plp
                        
a4e9 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
a4ec : 08              >            php         ;save flags
a4ed : bd0302          >            lda abst,x
a4f0 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a4f3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a4f5 : 68              >            pla         ;load status
                       >            eor_flag 0
a4f6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a4f8 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a4fb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a4fd : ca                       dex
a4fe : 10e0                     bpl tasl8
a500 : a205                     ldx #5
a502 :                  tasl9
                                set_absx zps,$ff
                       >            load_flag $ff
a502 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a504 : 48              >            pha         ;use stack to load status
a505 : b509            >            lda zps,x    ;load to indexed memory
a507 : 9d0302          >            sta abst,x
a50a : 28              >            plp
                        
a50b : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
a50e : 08              >            php         ;save flags
a50f : bd0302          >            lda abst,x
a512 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a515 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a517 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a518 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a51a : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a51d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a51f : ca                       dex
a520 : 10e0                     bpl tasl9
                        
a522 : a205                     ldx #5
a524 :                  tlsr8
                                set_absx zps,0
                       >            load_flag 0
a524 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a526 : 48              >            pha         ;use stack to load status
a527 : b509            >            lda zps,x    ;load to indexed memory
a529 : 9d0302          >            sta abst,x
a52c : 28              >            plp
                        
a52d : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
a530 : 08              >            php         ;save flags
a531 : bd0302          >            lda abst,x
a534 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a537 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a539 : 68              >            pla         ;load status
                       >            eor_flag 0
a53a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a53c : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a53f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a541 : ca                       dex
a542 : 10e0                     bpl tlsr8
a544 : a205                     ldx #5
a546 :                  tlsr9
                                set_absx zps,$ff
                       >            load_flag $ff
a546 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a548 : 48              >            pha         ;use stack to load status
a549 : b509            >            lda zps,x    ;load to indexed memory
a54b : 9d0302          >            sta abst,x
a54e : 28              >            plp
                        
a54f : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
a552 : 08              >            php         ;save flags
a553 : bd0302          >            lda abst,x
a556 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a559 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a55b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a55c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a55e : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a561 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a563 : ca                       dex
a564 : 10e0                     bpl tlsr9
                        
a566 : a205                     ldx #5
a568 :                  trol8
                                set_absx zps,0
                       >            load_flag 0
a568 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a56a : 48              >            pha         ;use stack to load status
a56b : b509            >            lda zps,x    ;load to indexed memory
a56d : 9d0302          >            sta abst,x
a570 : 28              >            plp
                        
a571 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
a574 : 08              >            php         ;save flags
a575 : bd0302          >            lda abst,x
a578 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a57b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a57d : 68              >            pla         ;load status
                       >            eor_flag 0
a57e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a580 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a583 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a585 : ca                       dex
a586 : 10e0                     bpl trol8
a588 : a205                     ldx #5
a58a :                  trol9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
a58a : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a58c : 48              >            pha         ;use stack to load status
a58d : b509            >            lda zps,x    ;load to indexed memory
a58f : 9d0302          >            sta abst,x
a592 : 28              >            plp
                        
a593 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
a596 : 08              >            php         ;save flags
a597 : bd0302          >            lda abst,x
a59a : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a59d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a59f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a5a0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a5a2 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a5a5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a5a7 : ca                       dex
a5a8 : 10e0                     bpl trol9
                        
a5aa : a205                     ldx #5
a5ac :                  trolc8
                                set_absx zps,fc
                       >            load_flag fc
a5ac : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a5ae : 48              >            pha         ;use stack to load status
a5af : b509            >            lda zps,x    ;load to indexed memory
a5b1 : 9d0302          >            sta abst,x
a5b4 : 28              >            plp
                        
a5b5 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
a5b8 : 08              >            php         ;save flags
a5b9 : bd0302          >            lda abst,x
a5bc : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a5bf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a5c1 : 68              >            pla         ;load status
                       >            eor_flag 0
a5c2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a5c4 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a5c7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a5c9 : ca                       dex
a5ca : 10e0                     bpl trolc8
a5cc : a205                     ldx #5
a5ce :                  trolc9
                                set_absx zps,$ff
                       >            load_flag $ff
a5ce : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a5d0 : 48              >            pha         ;use stack to load status
a5d1 : b509            >            lda zps,x    ;load to indexed memory
a5d3 : 9d0302          >            sta abst,x
a5d6 : 28              >            plp
                        
a5d7 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
a5da : 08              >            php         ;save flags
a5db : bd0302          >            lda abst,x
a5de : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a5e1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a5e3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a5e4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a5e6 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a5e9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a5eb : ca                       dex
a5ec : 10e0                     bpl trolc9
                        
a5ee : a205                     ldx #5
a5f0 :                  tror8
                                set_absx zps,0
                       >            load_flag 0
a5f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a5f2 : 48              >            pha         ;use stack to load status
a5f3 : b509            >            lda zps,x    ;load to indexed memory
a5f5 : 9d0302          >            sta abst,x
a5f8 : 28              >            plp
                        
a5f9 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
a5fc : 08              >            php         ;save flags
a5fd : bd0302          >            lda abst,x
a600 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a603 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a605 : 68              >            pla         ;load status
                       >            eor_flag 0
a606 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a608 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a60b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a60d : ca                       dex
a60e : 10e0                     bpl tror8
a610 : a205                     ldx #5
a612 :                  tror9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
a612 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a614 : 48              >            pha         ;use stack to load status
a615 : b509            >            lda zps,x    ;load to indexed memory
a617 : 9d0302          >            sta abst,x
a61a : 28              >            plp
                        
a61b : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
a61e : 08              >            php         ;save flags
a61f : bd0302          >            lda abst,x
a622 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a625 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a627 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a628 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a62a : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a62d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a62f : ca                       dex
a630 : 10e0                     bpl tror9
                        
a632 : a205                     ldx #5
a634 :                  trorc8
                                set_absx zps,fc
                       >            load_flag fc
a634 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a636 : 48              >            pha         ;use stack to load status
a637 : b509            >            lda zps,x    ;load to indexed memory
a639 : 9d0302          >            sta abst,x
a63c : 28              >            plp
                        
a63d : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
a640 : 08              >            php         ;save flags
a641 : bd0302          >            lda abst,x
a644 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a647 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a649 : 68              >            pla         ;load status
                       >            eor_flag 0
a64a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a64c : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a64f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a651 : ca                       dex
a652 : 10e0                     bpl trorc8
a654 : a205                     ldx #5
a656 :                  trorc9
                                set_absx zps,$ff
                       >            load_flag $ff
a656 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a658 : 48              >            pha         ;use stack to load status
a659 : b509            >            lda zps,x    ;load to indexed memory
a65b : 9d0302          >            sta abst,x
a65e : 28              >            plp
                        
a65f : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
a662 : 08              >            php         ;save flags
a663 : bd0302          >            lda abst,x
a666 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a669 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a66b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a66c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a66e : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a671 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a673 : ca                       dex
a674 : 10e0                     bpl trorc9
                                next_test
a676 : ad0002          >            lda test_case   ;previous test
a679 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a67b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
a67d : a922            >            lda #test_num   ;*** next tests' number
a67f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
a682 : a200                     ldx #0
a684 : a97e                     lda #$7e
a686 : 8502                     sta zpt
a688 :                  tinc    
                                set_stat 0
                       >            load_flag 0
a688 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a68a : 48              >            pha         ;use stack to load status
a68b : 28              >            plp
                        
a68c : e602                     inc zpt
                                tst_z rINC,fINC,0
a68e : 08              >            php         ;save flags
a68f : a502            >            lda zpt
a691 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a694 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a696 : 68              >            pla         ;load status
                       >            eor_flag 0
a697 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a699 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a69c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a69e : e8                       inx
a69f : e002                     cpx #2
a6a1 : d004                     bne tinc1
a6a3 : a9fe                     lda #$fe
a6a5 : 8502                     sta zpt
a6a7 : e005             tinc1   cpx #5
a6a9 : d0dd                     bne tinc
a6ab : ca                       dex
a6ac : e602                     inc zpt
a6ae :                  tdec    
                                set_stat 0
                       >            load_flag 0
a6ae : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a6b0 : 48              >            pha         ;use stack to load status
a6b1 : 28              >            plp
                        
a6b2 : c602                     dec zpt
                                tst_z rINC,fINC,0
a6b4 : 08              >            php         ;save flags
a6b5 : a502            >            lda zpt
a6b7 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a6ba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a6bc : 68              >            pla         ;load status
                       >            eor_flag 0
a6bd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a6bf : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a6c2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a6c4 : ca                       dex
a6c5 : 300a                     bmi tdec1
a6c7 : e001                     cpx #1
a6c9 : d0e3                     bne tdec
a6cb : a981                     lda #$81
a6cd : 8502                     sta zpt
a6cf : d0dd                     bne tdec
a6d1 :                  tdec1
a6d1 : a200                     ldx #0
a6d3 : a97e                     lda #$7e
a6d5 : 8502                     sta zpt
a6d7 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
a6d7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a6d9 : 48              >            pha         ;use stack to load status
a6da : 28              >            plp
                        
a6db : e602                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
a6dd : 08              >            php         ;save flags
a6de : a502            >            lda zpt
a6e0 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a6e3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a6e5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a6e6 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a6e8 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a6eb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a6ed : e8                       inx
a6ee : e002                     cpx #2
a6f0 : d004                     bne tinc11
a6f2 : a9fe                     lda #$fe
a6f4 : 8502                     sta zpt
a6f6 : e005             tinc11  cpx #5
a6f8 : d0dd                     bne tinc10
a6fa : ca                       dex
a6fb : e602                     inc zpt
a6fd :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
a6fd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a6ff : 48              >            pha         ;use stack to load status
a700 : 28              >            plp
                        
a701 : c602                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
a703 : 08              >            php         ;save flags
a704 : a502            >            lda zpt
a706 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a709 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a70b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a70c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a70e : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a711 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a713 : ca                       dex
a714 : 300a                     bmi tdec11
a716 : e001                     cpx #1
a718 : d0e3                     bne tdec10
a71a : a981                     lda #$81
a71c : 8502                     sta zpt
a71e : d0dd                     bne tdec10
a720 :                  tdec11
                                next_test
a720 : ad0002          >            lda test_case   ;previous test
a723 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a725 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
a727 : a923            >            lda #test_num   ;*** next tests' number
a729 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
a72c : a200                     ldx #0
a72e : a97e                     lda #$7e
a730 : 8d0302                   sta abst
a733 :                  tinc2    
                                set_stat 0
                       >            load_flag 0
a733 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a735 : 48              >            pha         ;use stack to load status
a736 : 28              >            plp
                        
a737 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
a73a : 08              >            php         ;save flags
a73b : ad0302          >            lda abst
a73e : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a741 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a743 : 68              >            pla         ;load status
                       >            eor_flag 0
a744 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a746 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a749 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a74b : e8                       inx
a74c : e002                     cpx #2
a74e : d005                     bne tinc3
a750 : a9fe                     lda #$fe
a752 : 8d0302                   sta abst
a755 : e005             tinc3   cpx #5
a757 : d0da                     bne tinc2
a759 : ca                       dex
a75a : ee0302                   inc abst
a75d :                  tdec2    
                                set_stat 0
                       >            load_flag 0
a75d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a75f : 48              >            pha         ;use stack to load status
a760 : 28              >            plp
                        
a761 : ce0302                   dec abst
                                tst_abs rINC,fINC,0
a764 : 08              >            php         ;save flags
a765 : ad0302          >            lda abst
a768 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a76b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a76d : 68              >            pla         ;load status
                       >            eor_flag 0
a76e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a770 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a773 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a775 : ca                       dex
a776 : 300b                     bmi tdec3
a778 : e001                     cpx #1
a77a : d0e1                     bne tdec2
a77c : a981                     lda #$81
a77e : 8d0302                   sta abst
a781 : d0da                     bne tdec2
a783 :                  tdec3
a783 : a200                     ldx #0
a785 : a97e                     lda #$7e
a787 : 8d0302                   sta abst
a78a :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
a78a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a78c : 48              >            pha         ;use stack to load status
a78d : 28              >            plp
                        
a78e : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
a791 : 08              >            php         ;save flags
a792 : ad0302          >            lda abst
a795 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a798 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a79a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a79b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a79d : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a7a0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a7a2 : e8                       inx
a7a3 : e002                     cpx #2
a7a5 : d005                     bne tinc13
a7a7 : a9fe                     lda #$fe
a7a9 : 8d0302                   sta abst
a7ac : e005             tinc13   cpx #5
a7ae : d0da                     bne tinc12
a7b0 : ca                       dex
a7b1 : ee0302                   inc abst
a7b4 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
a7b4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a7b6 : 48              >            pha         ;use stack to load status
a7b7 : 28              >            plp
                        
a7b8 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
a7bb : 08              >            php         ;save flags
a7bc : ad0302          >            lda abst
a7bf : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a7c2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a7c4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a7c5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a7c7 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a7ca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a7cc : ca                       dex
a7cd : 300b                     bmi tdec13
a7cf : e001                     cpx #1
a7d1 : d0e1                     bne tdec12
a7d3 : a981                     lda #$81
a7d5 : 8d0302                   sta abst
a7d8 : d0da                     bne tdec12
a7da :                  tdec13
                                next_test
a7da : ad0002          >            lda test_case   ;previous test
a7dd : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a7df : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
a7e1 : a924            >            lda #test_num   ;*** next tests' number
a7e3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
a7e6 : a200                     ldx #0
a7e8 : a97e                     lda #$7e
a7ea : 9502             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
a7ec : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a7ee : 48              >            pha         ;use stack to load status
a7ef : 28              >            plp
                        
a7f0 : f602                     inc zpt,x
                                tst_zx rINC,fINC,0
a7f2 : 08              >            php         ;save flags
a7f3 : b502            >            lda zpt,x
a7f5 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a7f8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a7fa : 68              >            pla         ;load status
                       >            eor_flag 0
a7fb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a7fd : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a800 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a802 : b502                     lda zpt,x
a804 : e8                       inx
a805 : e002                     cpx #2
a807 : d002                     bne tinc5
a809 : a9fe                     lda #$fe
a80b : e005             tinc5   cpx #5
a80d : d0db                     bne tinc4
a80f : ca                       dex
a810 : a902                     lda #2
a812 : 9502             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
a814 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a816 : 48              >            pha         ;use stack to load status
a817 : 28              >            plp
                        
a818 : d602                     dec zpt,x
                                tst_zx rINC,fINC,0
a81a : 08              >            php         ;save flags
a81b : b502            >            lda zpt,x
a81d : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a820 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a822 : 68              >            pla         ;load status
                       >            eor_flag 0
a823 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a825 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a828 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a82a : b502                     lda zpt,x
a82c : ca                       dex
a82d : 3008                     bmi tdec5
a82f : e001                     cpx #1
a831 : d0df                     bne tdec4
a833 : a981                     lda #$81
a835 : d0db                     bne tdec4
a837 :                  tdec5
a837 : a200                     ldx #0
a839 : a97e                     lda #$7e
a83b : 9502             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
a83d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a83f : 48              >            pha         ;use stack to load status
a840 : 28              >            plp
                        
a841 : f602                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
a843 : 08              >            php         ;save flags
a844 : b502            >            lda zpt,x
a846 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a849 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a84b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a84c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a84e : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a851 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a853 : b502                     lda zpt,x
a855 : e8                       inx
a856 : e002                     cpx #2
a858 : d002                     bne tinc15
a85a : a9fe                     lda #$fe
a85c : e005             tinc15  cpx #5
a85e : d0db                     bne tinc14
a860 : ca                       dex
a861 : a902                     lda #2
a863 : 9502             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
a865 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a867 : 48              >            pha         ;use stack to load status
a868 : 28              >            plp
                        
a869 : d602                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
a86b : 08              >            php         ;save flags
a86c : b502            >            lda zpt,x
a86e : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a871 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a873 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a874 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a876 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a879 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a87b : b502                     lda zpt,x
a87d : ca                       dex
a87e : 3008                     bmi tdec15
a880 : e001                     cpx #1
a882 : d0df                     bne tdec14
a884 : a981                     lda #$81
a886 : d0db                     bne tdec14
a888 :                  tdec15
                                next_test
a888 : ad0002          >            lda test_case   ;previous test
a88b : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a88d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
a88f : a925            >            lda #test_num   ;*** next tests' number
a891 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
a894 : a200                     ldx #0
a896 : a97e                     lda #$7e
a898 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
a89b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a89d : 48              >            pha         ;use stack to load status
a89e : 28              >            plp
                        
a89f : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
a8a2 : 08              >            php         ;save flags
a8a3 : bd0302          >            lda abst,x
a8a6 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a8a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a8ab : 68              >            pla         ;load status
                       >            eor_flag 0
a8ac : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a8ae : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a8b1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a8b3 : bd0302                   lda abst,x
a8b6 : e8                       inx
a8b7 : e002                     cpx #2
a8b9 : d002                     bne tinc7
a8bb : a9fe                     lda #$fe
a8bd : e005             tinc7   cpx #5
a8bf : d0d7                     bne tinc6
a8c1 : ca                       dex
a8c2 : a902                     lda #2
a8c4 : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
a8c7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a8c9 : 48              >            pha         ;use stack to load status
a8ca : 28              >            plp
                        
a8cb : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
a8ce : 08              >            php         ;save flags
a8cf : bd0302          >            lda abst,x
a8d2 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a8d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a8d7 : 68              >            pla         ;load status
                       >            eor_flag 0
a8d8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a8da : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a8dd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a8df : bd0302                   lda abst,x
a8e2 : ca                       dex
a8e3 : 3008                     bmi tdec7
a8e5 : e001                     cpx #1
a8e7 : d0db                     bne tdec6
a8e9 : a981                     lda #$81
a8eb : d0d7                     bne tdec6
a8ed :                  tdec7
a8ed : a200                     ldx #0
a8ef : a97e                     lda #$7e
a8f1 : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
a8f4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a8f6 : 48              >            pha         ;use stack to load status
a8f7 : 28              >            plp
                        
a8f8 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
a8fb : 08              >            php         ;save flags
a8fc : bd0302          >            lda abst,x
a8ff : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a902 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a904 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a905 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a907 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a90a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a90c : bd0302                   lda abst,x
a90f : e8                       inx
a910 : e002                     cpx #2
a912 : d002                     bne tinc17
a914 : a9fe                     lda #$fe
a916 : e005             tinc17  cpx #5
a918 : d0d7                     bne tinc16
a91a : ca                       dex
a91b : a902                     lda #2
a91d : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
a920 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a922 : 48              >            pha         ;use stack to load status
a923 : 28              >            plp
                        
a924 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
a927 : 08              >            php         ;save flags
a928 : bd0302          >            lda abst,x
a92b : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a92e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a930 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a931 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a933 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a936 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a938 : bd0302                   lda abst,x
a93b : ca                       dex
a93c : 3008                     bmi tdec17
a93e : e001                     cpx #1
a940 : d0db                     bne tdec16
a942 : a981                     lda #$81
a944 : d0d7                     bne tdec16
a946 :                  tdec17
                                next_test
a946 : ad0002          >            lda test_case   ;previous test
a949 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a94b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
a94d : a926            >            lda #test_num   ;*** next tests' number
a94f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
a952 : a203                     ldx #3          ;immediate
a954 : b514             tand    lda zpAN,x
a956 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
a959 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a95b : 48              >            pha         ;use stack to load status
a95c : bd6b02          >            lda absANa,x    ;precharge accu
a95f : 28              >            plp
                        
a960 : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
a963 : 08              >            php         ;save flags
a964 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a967 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a969 : 68              >            pla         ;load status
                       >            eor_flag 0
a96a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a96c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a96f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a971 : ca                       dex
a972 : 10e0                     bpl tand
a974 : a203                     ldx #3
a976 : b514             tand1   lda zpAN,x
a978 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
a97b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a97d : 48              >            pha         ;use stack to load status
a97e : bd6b02          >            lda absANa,x    ;precharge accu
a981 : 28              >            plp
                        
a982 : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
a985 : 08              >            php         ;save flags
a986 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a989 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a98b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a98c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a98e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a991 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a993 : ca                       dex
a994 : 10e0                     bpl tand1
                            
a996 : a203                     ldx #3      ;zp
a998 : b514             tand2   lda zpAN,x
a99a : 8502                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
a99c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a99e : 48              >            pha         ;use stack to load status
a99f : bd6b02          >            lda absANa,x    ;precharge accu
a9a2 : 28              >            plp
                        
a9a3 : 2502                     and zpt
                                tst_ax  absrlo,absflo,0
a9a5 : 08              >            php         ;save flags
a9a6 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a9a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a9ab : 68              >            pla         ;load status
                       >            eor_flag 0
a9ac : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a9ae : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a9b1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a9b3 : ca                       dex
a9b4 : 10e2                     bpl tand2
a9b6 : a203                     ldx #3
a9b8 : b514             tand3   lda zpAN,x
a9ba : 8502                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
a9bc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a9be : 48              >            pha         ;use stack to load status
a9bf : bd6b02          >            lda absANa,x    ;precharge accu
a9c2 : 28              >            plp
                        
a9c3 : 2502                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
a9c5 : 08              >            php         ;save flags
a9c6 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a9c9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a9cb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a9cc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a9ce : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a9d1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a9d3 : ca                       dex
a9d4 : 10e2                     bpl tand3
                        
a9d6 : a203                     ldx #3      ;abs
a9d8 : b514             tand4   lda zpAN,x
a9da : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
a9dd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a9df : 48              >            pha         ;use stack to load status
a9e0 : bd6b02          >            lda absANa,x    ;precharge accu
a9e3 : 28              >            plp
                        
a9e4 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
a9e7 : 08              >            php         ;save flags
a9e8 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a9eb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a9ed : 68              >            pla         ;load status
                       >            eor_flag 0
a9ee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a9f0 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a9f3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a9f5 : ca                       dex
a9f6 : 10e0                     bpl tand4
a9f8 : a203                     ldx #3
a9fa : b514             tand5   lda zpAN,x
a9fc : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
a9ff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aa01 : 48              >            pha         ;use stack to load status
aa02 : bd6b02          >            lda absANa,x    ;precharge accu
aa05 : 28              >            plp
                        
aa06 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
aa09 : 08              >            php         ;save flags
aa0a : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aa0d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa0f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aa10 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aa12 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aa15 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa17 : ca                       dex
aa18 : 1002                     bpl tand6
                        
aa1a : a203                     ldx #3      ;zp,x
aa1c :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
aa1c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aa1e : 48              >            pha         ;use stack to load status
aa1f : bd6b02          >            lda absANa,x    ;precharge accu
aa22 : 28              >            plp
                        
aa23 : 3514                     and zpAN,x
                                tst_ax  absrlo,absflo,0
aa25 : 08              >            php         ;save flags
aa26 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aa29 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa2b : 68              >            pla         ;load status
                       >            eor_flag 0
aa2c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aa2e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aa31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa33 : ca                       dex
aa34 : 10e6                     bpl tand6
aa36 : a203                     ldx #3
aa38 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
aa38 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aa3a : 48              >            pha         ;use stack to load status
aa3b : bd6b02          >            lda absANa,x    ;precharge accu
aa3e : 28              >            plp
                        
aa3f : 3514                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
aa41 : 08              >            php         ;save flags
aa42 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aa45 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa47 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aa48 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aa4a : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aa4d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa4f : ca                       dex
aa50 : 10e6                     bpl tand7
                        
aa52 : a203                     ldx #3      ;abs,x
aa54 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
aa54 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aa56 : 48              >            pha         ;use stack to load status
aa57 : bd6b02          >            lda absANa,x    ;precharge accu
aa5a : 28              >            plp
                        
aa5b : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
aa5e : 08              >            php         ;save flags
aa5f : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aa62 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa64 : 68              >            pla         ;load status
                       >            eor_flag 0
aa65 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aa67 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aa6a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa6c : ca                       dex
aa6d : 10e5                     bpl tand8
aa6f : a203                     ldx #3
aa71 :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
aa71 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aa73 : 48              >            pha         ;use stack to load status
aa74 : bd6b02          >            lda absANa,x    ;precharge accu
aa77 : 28              >            plp
                        
aa78 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
aa7b : 08              >            php         ;save flags
aa7c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aa7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa81 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aa82 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aa84 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aa87 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa89 : ca                       dex
aa8a : 10e5                     bpl tand9
                        
aa8c : a003                     ldy #3      ;abs,y
aa8e :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
aa8e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aa90 : 48              >            pha         ;use stack to load status
aa91 : b96b02          >            lda absANa,y    ;precharge accu
aa94 : 28              >            plp
                        
aa95 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
aa98 : 08              >            php         ;save flags
aa99 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aa9c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa9e : 68              >            pla         ;load status
                       >            eor_flag 0
aa9f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aaa1 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aaa4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aaa6 : 88                       dey
aaa7 : 10e5                     bpl tand10
aaa9 : a003                     ldy #3
aaab :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
aaab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aaad : 48              >            pha         ;use stack to load status
aaae : b96b02          >            lda absANa,y    ;precharge accu
aab1 : 28              >            plp
                        
aab2 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
aab5 : 08              >            php         ;save flags
aab6 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aab9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aabb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aabc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aabe : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aac1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aac3 : 88                       dey
aac4 : 10e5                     bpl tand11
                        
aac6 : a206                     ldx #6      ;(zp,x)
aac8 : a003                     ldy #3
aaca :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
aaca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aacc : 48              >            pha         ;use stack to load status
aacd : b96b02          >            lda absANa,y    ;precharge accu
aad0 : 28              >            plp
                        
aad1 : 2132                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
aad3 : 08              >            php         ;save flags
aad4 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aad7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aad9 : 68              >            pla         ;load status
                       >            eor_flag 0
aada : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aadc : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aadf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aae1 : ca                       dex
aae2 : ca                       dex
aae3 : 88                       dey
aae4 : 10e4                     bpl tand12
aae6 : a206                     ldx #6
aae8 : a003                     ldy #3
aaea :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
aaea : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aaec : 48              >            pha         ;use stack to load status
aaed : b96b02          >            lda absANa,y    ;precharge accu
aaf0 : 28              >            plp
                        
aaf1 : 2132                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
aaf3 : 08              >            php         ;save flags
aaf4 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aaf7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aaf9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aafa : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aafc : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aaff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab01 : ca                       dex
ab02 : ca                       dex
ab03 : 88                       dey
ab04 : 10e4                     bpl tand13
                        
ab06 : a003                     ldy #3      ;(zp),y
ab08 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
ab08 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ab0a : 48              >            pha         ;use stack to load status
ab0b : b96b02          >            lda absANa,y    ;precharge accu
ab0e : 28              >            plp
                        
ab0f : 3132                     and (indAN),y
                                tst_ay  absrlo,absflo,0
ab11 : 08              >            php         ;save flags
ab12 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ab15 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab17 : 68              >            pla         ;load status
                       >            eor_flag 0
ab18 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ab1a : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ab1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab1f : 88                       dey
ab20 : 10e6                     bpl tand14
ab22 : a003                     ldy #3
ab24 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
ab24 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ab26 : 48              >            pha         ;use stack to load status
ab27 : b96b02          >            lda absANa,y    ;precharge accu
ab2a : 28              >            plp
                        
ab2b : 3132                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
ab2d : 08              >            php         ;save flags
ab2e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ab31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab33 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ab34 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ab36 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ab39 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab3b : 88                       dey
ab3c : 10e6                     bpl tand15
                                next_test
ab3e : ad0002          >            lda test_case   ;previous test
ab41 : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
ab43 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
ab45 : a927            >            lda #test_num   ;*** next tests' number
ab47 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
ab4a : a203                     ldx #3          ;immediate - self modifying code
ab4c : b518             teor    lda zpEO,x
ab4e : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
ab51 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ab53 : 48              >            pha         ;use stack to load status
ab54 : bd6f02          >            lda absEOa,x    ;precharge accu
ab57 : 28              >            plp
                        
ab58 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
ab5b : 08              >            php         ;save flags
ab5c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ab5f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab61 : 68              >            pla         ;load status
                       >            eor_flag 0
ab62 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ab64 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ab67 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab69 : ca                       dex
ab6a : 10e0                     bpl teor
ab6c : a203                     ldx #3
ab6e : b518             teor1   lda zpEO,x
ab70 : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ab73 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ab75 : 48              >            pha         ;use stack to load status
ab76 : bd6f02          >            lda absEOa,x    ;precharge accu
ab79 : 28              >            plp
                        
ab7a : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
ab7d : 08              >            php         ;save flags
ab7e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ab81 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab83 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ab84 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ab86 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ab89 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab8b : ca                       dex
ab8c : 10e0                     bpl teor1
                            
ab8e : a203                     ldx #3      ;zp
ab90 : b518             teor2    lda zpEO,x
ab92 : 8502                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
ab94 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ab96 : 48              >            pha         ;use stack to load status
ab97 : bd6f02          >            lda absEOa,x    ;precharge accu
ab9a : 28              >            plp
                        
ab9b : 4502                     eor zpt
                                tst_ax  absrlo,absflo,0
ab9d : 08              >            php         ;save flags
ab9e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aba1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aba3 : 68              >            pla         ;load status
                       >            eor_flag 0
aba4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aba6 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aba9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
abab : ca                       dex
abac : 10e2                     bpl teor2
abae : a203                     ldx #3
abb0 : b518             teor3   lda zpEO,x
abb2 : 8502                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
abb4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
abb6 : 48              >            pha         ;use stack to load status
abb7 : bd6f02          >            lda absEOa,x    ;precharge accu
abba : 28              >            plp
                        
abbb : 4502                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
abbd : 08              >            php         ;save flags
abbe : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
abc1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
abc3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
abc4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
abc6 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
abc9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
abcb : ca                       dex
abcc : 10e2                     bpl teor3
                        
abce : a203                     ldx #3      ;abs
abd0 : b518             teor4   lda zpEO,x
abd2 : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
abd5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
abd7 : 48              >            pha         ;use stack to load status
abd8 : bd6f02          >            lda absEOa,x    ;precharge accu
abdb : 28              >            plp
                        
abdc : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
abdf : 08              >            php         ;save flags
abe0 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
abe3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
abe5 : 68              >            pla         ;load status
                       >            eor_flag 0
abe6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
abe8 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
abeb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
abed : ca                       dex
abee : 10e0                     bpl teor4
abf0 : a203                     ldx #3
abf2 : b518             teor5   lda zpEO,x
abf4 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
abf7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
abf9 : 48              >            pha         ;use stack to load status
abfa : bd6f02          >            lda absEOa,x    ;precharge accu
abfd : 28              >            plp
                        
abfe : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
ac01 : 08              >            php         ;save flags
ac02 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ac05 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac07 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ac08 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ac0a : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ac0d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac0f : ca                       dex
ac10 : 1002                     bpl teor6
                        
ac12 : a203                     ldx #3      ;zp,x
ac14 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
ac14 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ac16 : 48              >            pha         ;use stack to load status
ac17 : bd6f02          >            lda absEOa,x    ;precharge accu
ac1a : 28              >            plp
                        
ac1b : 5518                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
ac1d : 08              >            php         ;save flags
ac1e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ac21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac23 : 68              >            pla         ;load status
                       >            eor_flag 0
ac24 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ac26 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ac29 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac2b : ca                       dex
ac2c : 10e6                     bpl teor6
ac2e : a203                     ldx #3
ac30 :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ac30 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ac32 : 48              >            pha         ;use stack to load status
ac33 : bd6f02          >            lda absEOa,x    ;precharge accu
ac36 : 28              >            plp
                        
ac37 : 5518                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
ac39 : 08              >            php         ;save flags
ac3a : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ac3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac3f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ac40 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ac42 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ac45 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac47 : ca                       dex
ac48 : 10e6                     bpl teor7
                        
ac4a : a203                     ldx #3      ;abs,x
ac4c :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
ac4c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ac4e : 48              >            pha         ;use stack to load status
ac4f : bd6f02          >            lda absEOa,x    ;precharge accu
ac52 : 28              >            plp
                        
ac53 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
ac56 : 08              >            php         ;save flags
ac57 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ac5a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac5c : 68              >            pla         ;load status
                       >            eor_flag 0
ac5d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ac5f : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ac62 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac64 : ca                       dex
ac65 : 10e5                     bpl teor8
ac67 : a203                     ldx #3
ac69 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ac69 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ac6b : 48              >            pha         ;use stack to load status
ac6c : bd6f02          >            lda absEOa,x    ;precharge accu
ac6f : 28              >            plp
                        
ac70 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
ac73 : 08              >            php         ;save flags
ac74 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ac77 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac79 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ac7a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ac7c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ac7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac81 : ca                       dex
ac82 : 10e5                     bpl teor9
                        
ac84 : a003                     ldy #3      ;abs,y
ac86 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
ac86 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ac88 : 48              >            pha         ;use stack to load status
ac89 : b96f02          >            lda absEOa,y    ;precharge accu
ac8c : 28              >            plp
                        
ac8d : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
ac90 : 08              >            php         ;save flags
ac91 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ac94 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac96 : 68              >            pla         ;load status
                       >            eor_flag 0
ac97 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ac99 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ac9c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac9e : 88                       dey
ac9f : 10e5                     bpl teor10
aca1 : a003                     ldy #3
aca3 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
aca3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aca5 : 48              >            pha         ;use stack to load status
aca6 : b96f02          >            lda absEOa,y    ;precharge accu
aca9 : 28              >            plp
                        
acaa : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
acad : 08              >            php         ;save flags
acae : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
acb1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
acb3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
acb4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
acb6 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
acb9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
acbb : 88                       dey
acbc : 10e5                     bpl teor11
                        
acbe : a206                     ldx #6      ;(zp,x)
acc0 : a003                     ldy #3
acc2 :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
acc2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
acc4 : 48              >            pha         ;use stack to load status
acc5 : b96f02          >            lda absEOa,y    ;precharge accu
acc8 : 28              >            plp
                        
acc9 : 413a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
accb : 08              >            php         ;save flags
accc : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
accf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
acd1 : 68              >            pla         ;load status
                       >            eor_flag 0
acd2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
acd4 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
acd7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
acd9 : ca                       dex
acda : ca                       dex
acdb : 88                       dey
acdc : 10e4                     bpl teor12
acde : a206                     ldx #6
ace0 : a003                     ldy #3
ace2 :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
ace2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ace4 : 48              >            pha         ;use stack to load status
ace5 : b96f02          >            lda absEOa,y    ;precharge accu
ace8 : 28              >            plp
                        
ace9 : 413a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
aceb : 08              >            php         ;save flags
acec : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
acef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
acf1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
acf2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
acf4 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
acf7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
acf9 : ca                       dex
acfa : ca                       dex
acfb : 88                       dey
acfc : 10e4                     bpl teor13
                        
acfe : a003                     ldy #3      ;(zp),y
ad00 :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
ad00 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ad02 : 48              >            pha         ;use stack to load status
ad03 : b96f02          >            lda absEOa,y    ;precharge accu
ad06 : 28              >            plp
                        
ad07 : 513a                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
ad09 : 08              >            php         ;save flags
ad0a : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ad0d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad0f : 68              >            pla         ;load status
                       >            eor_flag 0
ad10 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ad12 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ad15 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad17 : 88                       dey
ad18 : 10e6                     bpl teor14
ad1a : a003                     ldy #3
ad1c :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
ad1c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ad1e : 48              >            pha         ;use stack to load status
ad1f : b96f02          >            lda absEOa,y    ;precharge accu
ad22 : 28              >            plp
                        
ad23 : 513a                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
ad25 : 08              >            php         ;save flags
ad26 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ad29 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad2b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ad2c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ad2e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ad31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad33 : 88                       dey
ad34 : 10e6                     bpl teor15
                                next_test
ad36 : ad0002          >            lda test_case   ;previous test
ad39 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
ad3b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
ad3d : a928            >            lda #test_num   ;*** next tests' number
ad3f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
ad42 : a203                     ldx #3          ;immediate - self modifying code
ad44 : b510             tora    lda zpOR,x
ad46 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
ad49 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ad4b : 48              >            pha         ;use stack to load status
ad4c : bd6702          >            lda absORa,x    ;precharge accu
ad4f : 28              >            plp
                        
ad50 : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
ad53 : 08              >            php         ;save flags
ad54 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ad57 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad59 : 68              >            pla         ;load status
                       >            eor_flag 0
ad5a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ad5c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ad5f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad61 : ca                       dex
ad62 : 10e0                     bpl tora
ad64 : a203                     ldx #3
ad66 : b510             tora1   lda zpOR,x
ad68 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
ad6b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ad6d : 48              >            pha         ;use stack to load status
ad6e : bd6702          >            lda absORa,x    ;precharge accu
ad71 : 28              >            plp
                        
ad72 : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
ad75 : 08              >            php         ;save flags
ad76 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ad79 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad7b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ad7c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ad7e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ad81 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad83 : ca                       dex
ad84 : 10e0                     bpl tora1
                            
ad86 : a203                     ldx #3      ;zp
ad88 : b510             tora2   lda zpOR,x
ad8a : 8502                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
ad8c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ad8e : 48              >            pha         ;use stack to load status
ad8f : bd6702          >            lda absORa,x    ;precharge accu
ad92 : 28              >            plp
                        
ad93 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,0
ad95 : 08              >            php         ;save flags
ad96 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ad99 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad9b : 68              >            pla         ;load status
                       >            eor_flag 0
ad9c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ad9e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ada1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ada3 : ca                       dex
ada4 : 10e2                     bpl tora2
ada6 : a203                     ldx #3
ada8 : b510             tora3   lda zpOR,x
adaa : 8502                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
adac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
adae : 48              >            pha         ;use stack to load status
adaf : bd6702          >            lda absORa,x    ;precharge accu
adb2 : 28              >            plp
                        
adb3 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
adb5 : 08              >            php         ;save flags
adb6 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
adb9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
adbb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
adbc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
adbe : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
adc1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
adc3 : ca                       dex
adc4 : 10e2                     bpl tora3
                        
adc6 : a203                     ldx #3      ;abs
adc8 : b510             tora4   lda zpOR,x
adca : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
adcd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
adcf : 48              >            pha         ;use stack to load status
add0 : bd6702          >            lda absORa,x    ;precharge accu
add3 : 28              >            plp
                        
add4 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
add7 : 08              >            php         ;save flags
add8 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
addb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
addd : 68              >            pla         ;load status
                       >            eor_flag 0
adde : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ade0 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ade3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ade5 : ca                       dex
ade6 : 10e0                     bpl tora4
ade8 : a203                     ldx #3
adea : b510             tora5   lda zpOR,x
adec : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
adef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
adf1 : 48              >            pha         ;use stack to load status
adf2 : bd6702          >            lda absORa,x    ;precharge accu
adf5 : 28              >            plp
                        
adf6 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
adf9 : 08              >            php         ;save flags
adfa : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
adfd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
adff : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ae00 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ae02 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ae05 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae07 : ca                       dex
ae08 : 1002                     bpl tora6
                        
ae0a : a203                     ldx #3      ;zp,x
ae0c :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
ae0c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ae0e : 48              >            pha         ;use stack to load status
ae0f : bd6702          >            lda absORa,x    ;precharge accu
ae12 : 28              >            plp
                        
ae13 : 1510                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
ae15 : 08              >            php         ;save flags
ae16 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ae19 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae1b : 68              >            pla         ;load status
                       >            eor_flag 0
ae1c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ae1e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ae21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae23 : ca                       dex
ae24 : 10e6                     bpl tora6
ae26 : a203                     ldx #3
ae28 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
ae28 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ae2a : 48              >            pha         ;use stack to load status
ae2b : bd6702          >            lda absORa,x    ;precharge accu
ae2e : 28              >            plp
                        
ae2f : 1510                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
ae31 : 08              >            php         ;save flags
ae32 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ae35 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae37 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ae38 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ae3a : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ae3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae3f : ca                       dex
ae40 : 10e6                     bpl tora7
                        
ae42 : a203                     ldx #3      ;abs,x
ae44 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
ae44 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ae46 : 48              >            pha         ;use stack to load status
ae47 : bd6702          >            lda absORa,x    ;precharge accu
ae4a : 28              >            plp
                        
ae4b : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
ae4e : 08              >            php         ;save flags
ae4f : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ae52 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae54 : 68              >            pla         ;load status
                       >            eor_flag 0
ae55 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ae57 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ae5a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae5c : ca                       dex
ae5d : 10e5                     bpl tora8
ae5f : a203                     ldx #3
ae61 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
ae61 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ae63 : 48              >            pha         ;use stack to load status
ae64 : bd6702          >            lda absORa,x    ;precharge accu
ae67 : 28              >            plp
                        
ae68 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
ae6b : 08              >            php         ;save flags
ae6c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ae6f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae71 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ae72 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ae74 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ae77 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae79 : ca                       dex
ae7a : 10e5                     bpl tora9
                        
ae7c : a003                     ldy #3      ;abs,y
ae7e :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
ae7e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ae80 : 48              >            pha         ;use stack to load status
ae81 : b96702          >            lda absORa,y    ;precharge accu
ae84 : 28              >            plp
                        
ae85 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
ae88 : 08              >            php         ;save flags
ae89 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ae8c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae8e : 68              >            pla         ;load status
                       >            eor_flag 0
ae8f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ae91 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ae94 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae96 : 88                       dey
ae97 : 10e5                     bpl tora10
ae99 : a003                     ldy #3
ae9b :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
ae9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ae9d : 48              >            pha         ;use stack to load status
ae9e : b96702          >            lda absORa,y    ;precharge accu
aea1 : 28              >            plp
                        
aea2 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
aea5 : 08              >            php         ;save flags
aea6 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aea9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aeab : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aeac : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aeae : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aeb1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aeb3 : 88                       dey
aeb4 : 10e5                     bpl tora11
                        
aeb6 : a206                     ldx #6      ;(zp,x)
aeb8 : a003                     ldy #3
aeba :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
aeba : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aebc : 48              >            pha         ;use stack to load status
aebd : b96702          >            lda absORa,y    ;precharge accu
aec0 : 28              >            plp
                        
aec1 : 0142                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
aec3 : 08              >            php         ;save flags
aec4 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aec7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aec9 : 68              >            pla         ;load status
                       >            eor_flag 0
aeca : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aecc : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aecf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aed1 : ca                       dex
aed2 : ca                       dex
aed3 : 88                       dey
aed4 : 10e4                     bpl tora12
aed6 : a206                     ldx #6
aed8 : a003                     ldy #3
aeda :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
aeda : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aedc : 48              >            pha         ;use stack to load status
aedd : b96702          >            lda absORa,y    ;precharge accu
aee0 : 28              >            plp
                        
aee1 : 0142                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
aee3 : 08              >            php         ;save flags
aee4 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aee7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aee9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aeea : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aeec : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aeef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aef1 : ca                       dex
aef2 : ca                       dex
aef3 : 88                       dey
aef4 : 10e4                     bpl tora13
                        
aef6 : a003                     ldy #3      ;(zp),y
aef8 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
aef8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aefa : 48              >            pha         ;use stack to load status
aefb : b96702          >            lda absORa,y    ;precharge accu
aefe : 28              >            plp
                        
aeff : 1142                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
af01 : 08              >            php         ;save flags
af02 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
af05 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
af07 : 68              >            pla         ;load status
                       >            eor_flag 0
af08 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
af0a : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
af0d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
af0f : 88                       dey
af10 : 10e6                     bpl tora14
af12 : a003                     ldy #3
af14 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
af14 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
af16 : 48              >            pha         ;use stack to load status
af17 : b96702          >            lda absORa,y    ;precharge accu
af1a : 28              >            plp
                        
af1b : 1142                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
af1d : 08              >            php         ;save flags
af1e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
af21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
af23 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
af24 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
af26 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
af29 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
af2b : 88                       dey
af2c : 10e6                     bpl tora15
                            if I_flag = 3
af2e : 58                       cli
                            endif                
                                next_test
af2f : ad0002          >            lda test_case   ;previous test
af32 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
af34 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
af36 : a929            >            lda #test_num   ;*** next tests' number
af38 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
af3b : d8                       cld
af3c : a204                     ldx #ad2        ;for indexed test
af3e : a0ff                     ldy #$ff        ;max range
af40 : a900                     lda #0          ;start with adding zeroes & no carry
af42 : 8502                     sta adfc        ;carry in - for diag
af44 : 8503                     sta ad1         ;operand 1 - accumulator
af46 : 8504                     sta ad2         ;operand 2 - memory or immediate
af48 : 8d0302                   sta ada2        ;non zp
af4b : 8505                     sta adrl        ;expected result bits 0-7
af4d : 8506                     sta adrh        ;expected result bit 8 (carry out)
af4f : a9ff                     lda #$ff        ;complemented operand 2 for subtract
af51 : 8508                     sta sb2
af53 : 8d0402                   sta sba2        ;non zp
af56 : a902                     lda #2          ;expected Z-flag
af58 : 8507                     sta adrf
af5a : 18               tadd    clc             ;test with carry clear
af5b : 20e2af                   jsr chkadd
af5e : e602                     inc adfc        ;now with carry
af60 : e605                     inc adrl        ;result +1
af62 : 08                       php             ;save N & Z from low result
af63 : 08                       php
af64 : 68                       pla             ;accu holds expected flags
af65 : 2982                     and #$82        ;mask N & Z
af67 : 28                       plp
af68 : d002                     bne tadd1
af6a : e606                     inc adrh        ;result bit 8 - carry
af6c : 0506             tadd1   ora adrh        ;merge C to expected flags
af6e : 8507                     sta adrf        ;save expected flags except overflow
af70 : 38                       sec             ;test with carry set
af71 : 20e2af                   jsr chkadd
af74 : c602                     dec adfc        ;same for operand +1 but no carry
af76 : e603                     inc ad1
af78 : d0e0                     bne tadd        ;iterate op1
af7a : a900                     lda #0          ;preset result to op2 when op1 = 0
af7c : 8506                     sta adrh
af7e : ee0302                   inc ada2
af81 : e604                     inc ad2
af83 : 08                       php             ;save NZ as operand 2 becomes the new result
af84 : 68                       pla
af85 : 2982                     and #$82        ;mask N00000Z0
af87 : 8507                     sta adrf        ;no need to check carry as we are adding to 0
af89 : c608                     dec sb2         ;complement subtract operand 2
af8b : ce0402                   dec sba2
af8e : a504                     lda ad2         
af90 : 8505                     sta adrl
af92 : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
af94 : ad0002                   lda test_case
af97 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
af99 : d0fe            >        bne *         ;failed not equal (non zero)
                        
af9b : a9f0                     lda #$f0        ;mark opcode testing complete
af9d : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
afa0 : d8              >            cld
afa1 : a900            >            lda #0
afa3 : 8502            >            sta zpt         ;set low byte of indirect pointer
afa5 : 8505            >            sta zpt+3       ;checksum high byte
                       >          if disable_selfmod = 0
afa7 : 8d1981          >            sta range_adr   ;reset self modifying code
                       >          endif
afaa : 18              >            clc
afab : a209            >            ldx #zp_bss-zero_page ;zeropage - write test area
afad : 7500            >ccs32410      adc zero_page,x
afaf : 9003            >            bcc ccs22410
afb1 : e605            >            inc zpt+3       ;carry to high byte
afb3 : 18              >            clc
afb4 : e8              >ccs22410      inx
afb5 : d0f6            >            bne ccs32410
afb7 : a202            >            ldx #hi(abs1)   ;set high byte of indirect pointer
afb9 : 8603            >            stx zpt+1
afbb : a018            >            ldy #lo(abs1)   ;data after write & execute test area
afbd : 7102            >ccs52410      adc (zpt),y
afbf : 9003            >            bcc ccs42410
afc1 : e605            >            inc zpt+3       ;carry to high byte
afc3 : 18              >            clc
afc4 : c8              >ccs42410      iny
afc5 : d0f6            >            bne ccs52410
afc7 : e8              >            inx             ;advance RAM high address
afc8 : 8603            >            stx zpt+1
afca : e008            >            cpx #ram_top
afcc : d0ef            >            bne ccs52410
afce : 8504            >            sta zpt+2       ;checksum low is
afd0 : cd0102          >            cmp ram_chksm   ;checksum low expected
                       >            trap_ne         ;checksum mismatch
afd3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
afd5 : a505            >            lda zpt+3       ;checksum high is
afd7 : cd0202          >            cmp ram_chksm+1 ;checksum high expected
                       >            trap_ne         ;checksum mismatch
afda : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
afdc : 4cdcaf          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
afdf : 4c0080                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
afe2 : a507             chkadd  lda adrf        ;add V-flag if overflow
afe4 : 2983                     and #$83        ;keep N-----ZC / clear V
afe6 : 48                       pha
afe7 : a503                     lda ad1         ;test sign unequal between operands
afe9 : 4504                     eor ad2
afeb : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
afed : a503                     lda ad1         ;test sign equal between operands and result
afef : 4505                     eor adrl
aff1 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
aff3 : 68                       pla
aff4 : 0940                     ora #$40        ;set V
aff6 : 48                       pha
aff7 : 68               ckad1   pla
aff8 : 8507                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
affa : 08                       php             ;save carry for subtract
affb : a503                     lda ad1
affd : 6504                     adc ad2         ;perform add
afff : 08                       php          
b000 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b002 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b004 : 68                       pla             ;check flags
b005 : 29c3                     and #$c3        ;mask NV----ZC
b007 : c507                     cmp adrf
                                trap_ne         ;bad flags
b009 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b00b : 28                       plp
b00c : 08                       php             ;save carry for next add
b00d : a503                     lda ad1
b00f : e508                     sbc sb2         ;perform subtract
b011 : 08                       php          
b012 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b014 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b016 : 68                       pla             ;check flags
b017 : 29c3                     and #$c3        ;mask NV----ZC
b019 : c507                     cmp adrf
                                trap_ne         ;bad flags
b01b : d0fe            >        bne *         ;failed not equal (non zero)
                        
b01d : 28                       plp
                        ; binary ADC / SBC abs
b01e : 08                       php             ;save carry for subtract
b01f : a503                     lda ad1
b021 : 6d0302                   adc ada2        ;perform add
b024 : 08                       php          
b025 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b027 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b029 : 68                       pla             ;check flags
b02a : 29c3                     and #$c3        ;mask NV----ZC
b02c : c507                     cmp adrf
                                trap_ne         ;bad flags
b02e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b030 : 28                       plp
b031 : 08                       php             ;save carry for next add
b032 : a503                     lda ad1
b034 : ed0402                   sbc sba2        ;perform subtract
b037 : 08                       php          
b038 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b03a : d0fe            >        bne *         ;failed not equal (non zero)
                        
b03c : 68                       pla             ;check flags
b03d : 29c3                     and #$c3        ;mask NV----ZC
b03f : c507                     cmp adrf
                                trap_ne         ;bad flags
b041 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b043 : 28                       plp
                        ; binary ADC / SBC #
b044 : 08                       php             ;save carry for subtract
b045 : a504                     lda ad2
b047 : 8d1302                   sta ex_adci+1   ;set ADC # operand
b04a : a503                     lda ad1
b04c : 201202                   jsr ex_adci     ;execute ADC # in RAM
b04f : 08                       php          
b050 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b052 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b054 : 68                       pla             ;check flags
b055 : 29c3                     and #$c3        ;mask NV----ZC
b057 : c507                     cmp adrf
                                trap_ne         ;bad flags
b059 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b05b : 28                       plp
b05c : 08                       php             ;save carry for next add
b05d : a508                     lda sb2
b05f : 8d1602                   sta ex_sbci+1   ;set SBC # operand
b062 : a503                     lda ad1
b064 : 201502                   jsr ex_sbci     ;execute SBC # in RAM
b067 : 08                       php          
b068 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b06a : d0fe            >        bne *         ;failed not equal (non zero)
                        
b06c : 68                       pla             ;check flags
b06d : 29c3                     and #$c3        ;mask NV----ZC
b06f : c507                     cmp adrf
                                trap_ne         ;bad flags
b071 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b073 : 28                       plp
                        ; binary ADC / SBC zp,x
b074 : 08                       php             ;save carry for subtract
b075 : a503                     lda ad1
b077 : 7500                     adc 0,x         ;perform add
b079 : 08                       php          
b07a : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b07c : d0fe            >        bne *         ;failed not equal (non zero)
                        
b07e : 68                       pla             ;check flags
b07f : 29c3                     and #$c3        ;mask NV----ZC
b081 : c507                     cmp adrf
                                trap_ne         ;bad flags
b083 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b085 : 28                       plp
b086 : 08                       php             ;save carry for next add
b087 : a503                     lda ad1
b089 : f504                     sbc sb2-ad2,x   ;perform subtract
b08b : 08                       php          
b08c : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b08e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b090 : 68                       pla             ;check flags
b091 : 29c3                     and #$c3        ;mask NV----ZC
b093 : c507                     cmp adrf
                                trap_ne         ;bad flags
b095 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b097 : 28                       plp
                        ; binary ADC / SBC abs,x
b098 : 08                       php             ;save carry for subtract
b099 : a503                     lda ad1
b09b : 7dff01                   adc ada2-ad2,x  ;perform add
b09e : 08                       php          
b09f : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b0a1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0a3 : 68                       pla             ;check flags
b0a4 : 29c3                     and #$c3        ;mask NV----ZC
b0a6 : c507                     cmp adrf
                                trap_ne         ;bad flags
b0a8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0aa : 28                       plp
b0ab : 08                       php             ;save carry for next add
b0ac : a503                     lda ad1
b0ae : fd0002                   sbc sba2-ad2,x  ;perform subtract
b0b1 : 08                       php          
b0b2 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b0b4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0b6 : 68                       pla             ;check flags
b0b7 : 29c3                     and #$c3        ;mask NV----ZC
b0b9 : c507                     cmp adrf
                                trap_ne         ;bad flags
b0bb : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0bd : 28                       plp
                        ; binary ADC / SBC abs,y
b0be : 08                       php             ;save carry for subtract
b0bf : a503                     lda ad1
b0c1 : 790401                   adc ada2-$ff,y  ;perform add
b0c4 : 08                       php          
b0c5 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b0c7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0c9 : 68                       pla             ;check flags
b0ca : 29c3                     and #$c3        ;mask NV----ZC
b0cc : c507                     cmp adrf
                                trap_ne         ;bad flags
b0ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0d0 : 28                       plp
b0d1 : 08                       php             ;save carry for next add
b0d2 : a503                     lda ad1
b0d4 : f90501                   sbc sba2-$ff,y  ;perform subtract
b0d7 : 08                       php          
b0d8 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b0da : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0dc : 68                       pla             ;check flags
b0dd : 29c3                     and #$c3        ;mask NV----ZC
b0df : c507                     cmp adrf
                                trap_ne         ;bad flags
b0e1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0e3 : 28                       plp
                        ; binary ADC / SBC (zp,x)
b0e4 : 08                       php             ;save carry for subtract
b0e5 : a503                     lda ad1
b0e7 : 6146                     adc (lo adi2-ad2,x) ;perform add
b0e9 : 08                       php          
b0ea : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b0ec : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0ee : 68                       pla             ;check flags
b0ef : 29c3                     and #$c3        ;mask NV----ZC
b0f1 : c507                     cmp adrf
                                trap_ne         ;bad flags
b0f3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0f5 : 28                       plp
b0f6 : 08                       php             ;save carry for next add
b0f7 : a503                     lda ad1
b0f9 : e148                     sbc (lo sbi2-ad2,x) ;perform subtract
b0fb : 08                       php          
b0fc : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b0fe : d0fe            >        bne *         ;failed not equal (non zero)
                        
b100 : 68                       pla             ;check flags
b101 : 29c3                     and #$c3        ;mask NV----ZC
b103 : c507                     cmp adrf
                                trap_ne         ;bad flags
b105 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b107 : 28                       plp
                        ; binary ADC / SBC (abs),y
b108 : 08                       php             ;save carry for subtract
b109 : a503                     lda ad1
b10b : 714e                     adc (adiy2),y   ;perform add
b10d : 08                       php          
b10e : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b110 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b112 : 68                       pla             ;check flags
b113 : 29c3                     and #$c3        ;mask NV----ZC
b115 : c507                     cmp adrf
                                trap_ne         ;bad flags
b117 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b119 : 28                       plp
b11a : 08                       php             ;save carry for next add
b11b : a503                     lda ad1
b11d : f150                     sbc (sbiy2),y   ;perform subtract
b11f : 08                       php          
b120 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b122 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b124 : 68                       pla             ;check flags
b125 : 29c3                     and #$c3        ;mask NV----ZC
b127 : c507                     cmp adrf
                                trap_ne         ;bad flags
b129 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b12b : 28                       plp
b12c : 60                       rts
                        
                        ; target for the jump absolute test
b12d : 88                       dey
b12e : 88                       dey
b12f :                  test_far
b12f : 08                       php             ;either SP or Y count will fail, if we do not hit
b130 : 88                       dey
b131 : 88                       dey
b132 : 88                       dey
b133 : 28                       plp
                                trap_cs         ;flags loaded?
b134 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
b136 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
b138 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
b13a : f0fe            >        beq *           ;failed equal (zero)
                        
b13c : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
b13e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b140 : e041                     cpx #'A'
                                trap_ne        
b142 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b144 : c04f                     cpy #('R'-3)
                                trap_ne
b146 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b148 : 48                       pha             ;save a,x
b149 : 8a                       txa
b14a : 48                       pha
b14b : ba                       tsx
b14c : e0fd                     cpx #$fd        ;check SP
                                trap_ne
b14e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b150 : 68                       pla             ;restore x
b151 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
b152 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
b154 : 48              >            pha         ;use stack to load status
b155 : 28              >            plp
                        
b156 : 68                       pla             ;restore a
b157 : e8                       inx             ;return registers with modifications
b158 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
b15a : 4c4285                   jmp far_ret
                                
                        ; target for the jump indirect test
b15d : 00                       align
b15e : 67b1             ptr_tst_ind dw test_ind
b160 : 9785             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
b162 : 4c62b1          >        jmp *           ;failed anyway
                        
b165 : 88                       dey
b166 : 88                       dey
b167 :                  test_ind
b167 : 08                       php             ;either SP or Y count will fail, if we do not hit
b168 : 88                       dey
b169 : 88                       dey
b16a : 88                       dey
b16b : 28                       plp
                                trap_cs         ;flags loaded?
b16c : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
b16e : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
b170 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
b172 : f0fe            >        beq *           ;failed equal (zero)
                        
b174 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
b176 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b178 : e04e                     cpx #'N'
                                trap_ne        
b17a : d0fe            >        bne *         ;failed not equal (non zero)
                        
b17c : c041                     cpy #('D'-3)
                                trap_ne
b17e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b180 : 48                       pha             ;save a,x
b181 : 8a                       txa
b182 : 48                       pha
b183 : ba                       tsx
b184 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
b186 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b188 : 68                       pla             ;restore x
b189 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
b18a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
b18c : 48              >            pha         ;use stack to load status
b18d : 28              >            plp
                        
b18e : 68                       pla             ;restore a
b18f : e8                       inx             ;return registers with modifications
b190 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
b192 : 6c60b1                   jmp (ptr_ind_ret)
                                trap            ;runover protection
b195 : 4c95b1          >        jmp *           ;failed anyway
                        
b198 : 4c0080                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
b19b : 88                       dey
b19c : 88                       dey
b19d :                  test_jsr
b19d : 08                       php             ;either SP or Y count will fail, if we do not hit
b19e : 88                       dey
b19f : 88                       dey
b1a0 : 88                       dey
b1a1 : 28                       plp
                                trap_cs         ;flags loaded?
b1a2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
b1a4 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
b1a6 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
b1a8 : f0fe            >        beq *           ;failed equal (zero)
                        
b1aa : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
b1ac : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1ae : e053                     cpx #'S'
                                trap_ne        
b1b0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1b2 : c04f                     cpy #('R'-3)
                                trap_ne
b1b4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1b6 : 48                       pha             ;save a,x
b1b7 : 8a                       txa
b1b8 : 48                       pha       
b1b9 : ba                       tsx             ;sp -4? (return addr,a,x)
b1ba : e0fb                     cpx #$fb
                                trap_ne
b1bc : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1be : adff01                   lda $1ff        ;propper return on stack
b1c1 : c985                     cmp #hi(jsr_ret)
                                trap_ne
b1c3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1c5 : adfe01                   lda $1fe
b1c8 : c9cd                     cmp #lo(jsr_ret)
                                trap_ne
b1ca : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
b1cc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
b1ce : 48              >            pha         ;use stack to load status
b1cf : 28              >            plp
                        
b1d0 : 68                       pla             ;pull x,a
b1d1 : aa                       tax
b1d2 : 68                       pla
b1d3 : e8                       inx             ;return registers with modifications
b1d4 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
b1d6 : 60                       rts
                                trap            ;runover protection
b1d7 : 4cd7b1          >        jmp *           ;failed anyway
                        
b1da : 4c0080                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
b1dd :                  nmi_trap
                                trap            ;check stack for conditions at NMI
b1dd : 4cddb1          >        jmp *           ;failed anyway
                        
b1e0 : 4c0080                   jmp start       ;catastrophic error - cannot continue
b1e3 :                  res_trap
                                trap            ;unexpected RESET
b1e3 : 4ce3b1          >        jmp *           ;failed anyway
                        
b1e6 : 4c0080                   jmp start       ;catastrophic error - cannot continue
                                
b1e9 : 88                       dey
b1ea : 88                       dey
b1eb :                  irq_trap                ;BRK test or unextpected BRK or IRQ
b1eb : 08                       php             ;either SP or Y count will fail, if we do not hit
b1ec : 88                       dey
b1ed : 88                       dey
b1ee : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
b1ef : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
b1f1 : f042                     beq break2
b1f3 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
b1f5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1f7 : e052                     cpx #'R'
                                trap_ne        
b1f9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1fb : c048                     cpy #'K'-3
                                trap_ne
b1fd : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1ff : 8500                     sta irq_a       ;save registers during break test
b201 : 8601                     stx irq_x
b203 : ba                       tsx             ;test break on stack
b204 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
b207 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
b209 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b20b : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
b20c : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
b20e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b210 : ba                       tsx
b211 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
b213 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b215 : adff01                   lda $1ff        ;propper return on stack
b218 : c986                     cmp #hi(brk_ret0)
                                trap_ne
b21a : d0fe            >        bne *         ;failed not equal (non zero)
                        
b21c : adfe01                   lda $1fe
b21f : c904                     cmp #lo(brk_ret0)
                                trap_ne
b221 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                load_flag $ff
b223 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
b225 : 48                       pha
b226 : a601                     ldx irq_x
b228 : e8                       inx             ;return registers with modifications
b229 : a500                     lda irq_a
b22b : 49aa                     eor #$aa
b22d : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
b22e : 40                       rti
                                trap            ;runover protection
b22f : 4c2fb2          >        jmp *           ;failed anyway
                        
b232 : 4c0080                   jmp start       ;catastrophic error - cannot continue
                                
b235 :                  break2                  ;BRK pass 2        
b235 : e0ad                     cpx #$ff-'R'
                                trap_ne        
b237 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b239 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
b23b : d0fe            >        bne *         ;failed not equal (non zero)
                        
b23d : 8500                     sta irq_a       ;save registers during break test
b23f : 8601                     stx irq_x
b241 : ba                       tsx             ;test break on stack
b242 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
b245 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
b247 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b249 : 68                       pla
b24a : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
b24c : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
b24e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b250 : ba                       tsx
b251 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
b253 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b255 : adff01                   lda $1ff        ;propper return on stack
b258 : c986                     cmp #hi(brk_ret1)
                                trap_ne
b25a : d0fe            >        bne *         ;failed not equal (non zero)
                        
b25c : adfe01                   lda $1fe
b25f : c92a                     cmp #lo(brk_ret1)
                                trap_ne
b261 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                load_flag intdis
b263 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
b265 : 48                       pha      
b266 : a601                     ldx irq_x
b268 : e8                       inx             ;return registers with modifications
b269 : a500                     lda irq_a
b26b : 49aa                     eor #$aa
b26d : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
b26e : 40                       rti
                                trap            ;runover protection
b26f : 4c6fb2          >        jmp *           ;failed anyway
                        
b272 : 4c0080                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zps_    db  $80,1           ;additional shift pattern to test zero result & flag
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
                        rASL_                               ;expected result ASL & ROL -carry
                        rROL_   db  0,2,$86,$04,$82,0
                        rROLc_  db  1,3,$87,$05,$83,1       ;expected result ROL +carry
                        rLSR_                               ;expected result LSR & ROR -carry
                        rROR_   db  $40,0,$61,$41,$20,0
                        rRORc_  db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                               ;expected flags for shifts
                        fROL_   db  fzc,0,fnc,fc,fn,fz      ;no carry in
                        fROLc_  db  fc,0,fnc,fc,fn,0        ;carry in 
                        fLSR_
                        fROR_   db  0,fzc,fc,0,fc,fz        ;no carry in
                        fRORc_  db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80           ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80         ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0             ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff         ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
fffa =                          org $fffa       ;vectors
fffa : ddb1                     dw  nmi_trap
fffc : e3b1                     dw  res_trap
fffe : ebb1                     dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0000 through $ffff.
Total size 65536 bytes.
Program start address is at $8000 (32768).
