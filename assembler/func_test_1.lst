AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
-------------------------------------------------------- func_test_1.a65 ---------------------------------------------------------

6114 lines read, no errors in pass 1.
                        
                        
                        ;as65.exe -l ../func_test_1.a65 -m -h0 -l -w
                        
                        
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2020  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 05-jan-2020
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 written by Frank A. Kingswood
                        ; The assembler as65_142.zip can be obtained from my GitHub repository 
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        ;   05-jan-2020  fixed shifts not testing zero result and flag when last 1-bit
                        ;                is shifted out
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $52 (82) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
0000 =                  zero_page = $0  
                        
                        ;data_segment memory start address, $7B (123) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13.1kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
8000 =                  code_segment = $8000
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0001 =                  disable_decimal = 1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                        		endm
                        trap_ne macro
                                bne *         ;failed not equal (non zero)
                        		endm
                        trap_cs macro
                                bcs *           ;failed carry set
                        		endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                        		endm
                        trap_mi macro
                                bmi *         ;failed minus (bit 7 set)
                        		endm
                        trap_pl macro
                                bpl *          ;failed plus (bit 7 clear)
                        		endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                        		endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                        		endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;break test interrupt save
0000 : 00               irq_a   ds  1               ;a register
0001 : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0002 :                  zpt                         ;6 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0002 : 00               adfc    ds  1               ;carry flag before op
0003 : 00               ad1     ds  1               ;operand 1 - accumulator
0004 : 00               ad2     ds  1               ;operand 2 - memory / immediate
0005 : 00               adrl    ds  1               ;expected result bits 0-7
0006 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0007 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0008 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0009 :                  zp_bss
0009 : 8001             zps     db  $80,1           ;additional shift pattern to test zero result & flag
000b : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000f : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0010 : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0014 : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0018 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
001c : 1802             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
001e : 1902                     dw  abs1+1
0020 : 1a02                     dw  abs1+2
0022 : 1b02                     dw  abs1+3
0024 : 1c02                     dw  abs7f
0026 : 2001             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0028 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
002a : 0402                     dw  abst+1
002c : 0502                     dw  abst+2
002e : 0602                     dw  abst+3
0030 : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0032 : 5f02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0034 : 6002                     dw  absAN+1
0036 : 6102                     dw  absAN+2
0038 : 6202                     dw  absAN+3
003a : 6302             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
003c : 6402                     dw  absEO+1
003e : 6502                     dw  absEO+2
0040 : 6602                     dw  absEO+3
0042 : 5b02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0044 : 5c02                     dw  absOR+1
0046 : 5d02                     dw  absOR+2
0048 : 5e02                     dw  absOR+3
                        ;add/subtract indirect pointers
004a : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
004c : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
004e : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0050 : 0501             sbiy2   dw  sba2-$ff
0052 :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;6 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 00000000                 ds  4               ;fill remaining bytes
0209 :                  data_bss
                            if load_data_direct = 1
0209 : 2900             ex_andi and #0              ;execute immediate opcodes
020b : 60                       rts
020c : 4900             ex_eori eor #0              ;execute immediate opcodes
020e : 60                       rts
020f : 0900             ex_orai ora #0              ;execute immediate opcodes
0211 : 60                       rts
0212 : 6900             ex_adci adc #0              ;execute immediate opcodes
0214 : 60                       rts
0215 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0217 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
0218 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021c : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021d : 80800002         fLDx    db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
0221 :                  rASL                                ;expected result ASL & ROL -carry
0221 : 000286048200     rROL    db  0,2,$86,$04,$82,0
0227 : 010387058301     rROLc   db  1,3,$87,$05,$83,1       ;expected result ROL +carry
022d :                  rLSR                                ;expected result LSR & ROR -carry
022d : 400061412000     rROR    db  $40,0,$61,$41,$20,0
0233 : c080e1c1a080     rRORc   db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
0239 :                  fASL                                ;expected flags for shifts
0239 : 030081018002     fROL    db  fzc,0,fnc,fc,fn,fz      ;no carry in
023f : 010081018000     fROLc   db  fc,0,fnc,fc,fn,0        ;carry in 
0245 :                  fLSR 
0245 : 000301000102     fROR    db  0,fzc,fc,0,fc,fz        ;no carry in
024b : 808181808180     fRORc   db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
0251 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
0256 : 0080800200       fINC    db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
025b : 001f7180         absOR   db  0,$1f,$71,$80           ;test pattern for OR
025f : 0fff7f80         absAN   db  $0f,$ff,$7f,$80         ;test pattern for AND
0263 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
0267 : 00f11f00         absORa  db  0,$f1,$1f,0             ;test pattern for OR
026b : f0ffffff         absANa  db  $f0,$ff,$ff,$ff         ;test pattern for AND
026f : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
0273 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0277 : 02800080         absflo  db  fz,fn,0,fn
027b :                  data_bss_end
                        
                        
                                code
8000 =                          org code_segment
8000 : d8               start   cld
8001 : a2ff                     ldx #$ff
8003 : 9a                       txs
8004 : a900                     lda #0          ;*** test 0 = initialize
8006 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
8009 : a205                     ldx #5
800b : 4c3380                   jmp psb_test
800e :                  psb_bwok
800e : a005                     ldy #5
8010 : d008                     bne psb_forw
                                trap        ;branch should be taken
8012 : 4c1280          >        jmp *           ;failed anyway
                        
8015 : 88                       dey         ;forward landing zone
8016 : 88                       dey
8017 : 88                       dey
8018 : 88                       dey
8019 : 88                       dey
801a :                  psb_forw
801a : 88                       dey
801b : 88                       dey
801c : 88                       dey
801d : 88                       dey
801e : 88                       dey
801f : f017                     beq psb_fwok
                                trap        ;forward offset
8021 : 4c2180          >        jmp *           ;failed anyway
                        
                        
8024 : ca                       dex         ;backward landing zone
8025 : ca                       dex
8026 : ca                       dex
8027 : ca                       dex
8028 : ca                       dex
8029 :                  psb_back
8029 : ca                       dex
802a : ca                       dex
802b : ca                       dex
802c : ca                       dex
802d : ca                       dex
802e : f0de                     beq psb_bwok
                                trap        ;backward offset
8030 : 4c3080          >        jmp *           ;failed anyway
                        
8033 :                  psb_test
8033 : d0f4                     bne psb_back
                                trap        ;branch should be taken
8035 : 4c3580          >        jmp *           ;failed anyway
                        
8038 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
8038 : ad0002          >            lda test_case   ;previous test
803b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
803d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
803f : a901            >            lda #test_num   ;*** next tests' number
8041 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
8044 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
8046 :                  range_loop
8046 : 88                       dey             ;next relative address
8047 : 98                       tya
8048 : aa                       tax             ;precharge count to end of loop
8049 : 1008                     bpl range_fw    ;calculate relative address
804b : 18                       clc             ;avoid branch self or to relative address of branch
804c : 6902                     adc #2
804e : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
804f : ea                       nop
8050 : ea                       nop
8051 : ea                       nop
8052 : ea                       nop
8053 :                  range_fw
8053 : ea                       nop
8054 : ea                       nop
8055 : ea                       nop
8056 : ea                       nop
8057 : ea                       nop
8058 : 497f                     eor #$7f        ;complement except sign
805a : 8de680                   sta range_adr   ;load into test target
805d : a900                     lda #0          ;should set zero flag in status register
805f : 4ce580                   jmp range_op
                                
8062 : ca                       dex             ; offset landing zone - backward branch too far
8063 : ca                       dex
8064 : ca                       dex
8065 : ca                       dex
8066 : ca                       dex
                                ;relative address target field with branch under test in the middle
8067 : ca                       dex             ;-128 - max backward
8068 : ca                       dex
8069 : ca                       dex
806a : ca                       dex
806b : ca                       dex
806c : ca                       dex
806d : ca                       dex
806e : ca                       dex
806f : ca                       dex             ;-120
8070 : ca                       dex
8071 : ca                       dex
8072 : ca                       dex
8073 : ca                       dex
8074 : ca                       dex
8075 : ca                       dex
8076 : ca                       dex
8077 : ca                       dex
8078 : ca                       dex
8079 : ca                       dex             ;-110
807a : ca                       dex
807b : ca                       dex
807c : ca                       dex
807d : ca                       dex
807e : ca                       dex
807f : ca                       dex
8080 : ca                       dex
8081 : ca                       dex
8082 : ca                       dex
8083 : ca                       dex             ;-100
8084 : ca                       dex
8085 : ca                       dex
8086 : ca                       dex
8087 : ca                       dex
8088 : ca                       dex
8089 : ca                       dex
808a : ca                       dex
808b : ca                       dex
808c : ca                       dex
808d : ca                       dex             ;-90
808e : ca                       dex
808f : ca                       dex
8090 : ca                       dex
8091 : ca                       dex
8092 : ca                       dex
8093 : ca                       dex
8094 : ca                       dex
8095 : ca                       dex
8096 : ca                       dex
8097 : ca                       dex             ;-80
8098 : ca                       dex
8099 : ca                       dex
809a : ca                       dex
809b : ca                       dex
809c : ca                       dex
809d : ca                       dex
809e : ca                       dex
809f : ca                       dex
80a0 : ca                       dex
80a1 : ca                       dex             ;-70
80a2 : ca                       dex
80a3 : ca                       dex
80a4 : ca                       dex
80a5 : ca                       dex
80a6 : ca                       dex
80a7 : ca                       dex
80a8 : ca                       dex
80a9 : ca                       dex
80aa : ca                       dex
80ab : ca                       dex             ;-60
80ac : ca                       dex
80ad : ca                       dex
80ae : ca                       dex
80af : ca                       dex
80b0 : ca                       dex
80b1 : ca                       dex
80b2 : ca                       dex
80b3 : ca                       dex
80b4 : ca                       dex
80b5 : ca                       dex             ;-50
80b6 : ca                       dex
80b7 : ca                       dex
80b8 : ca                       dex
80b9 : ca                       dex
80ba : ca                       dex
80bb : ca                       dex
80bc : ca                       dex
80bd : ca                       dex
80be : ca                       dex
80bf : ca                       dex             ;-40
80c0 : ca                       dex
80c1 : ca                       dex
80c2 : ca                       dex
80c3 : ca                       dex
80c4 : ca                       dex
80c5 : ca                       dex
80c6 : ca                       dex
80c7 : ca                       dex
80c8 : ca                       dex
80c9 : ca                       dex             ;-30
80ca : ca                       dex
80cb : ca                       dex
80cc : ca                       dex
80cd : ca                       dex
80ce : ca                       dex
80cf : ca                       dex
80d0 : ca                       dex
80d1 : ca                       dex
80d2 : ca                       dex
80d3 : ca                       dex             ;-20
80d4 : ca                       dex
80d5 : ca                       dex
80d6 : ca                       dex
80d7 : ca                       dex
80d8 : ca                       dex
80d9 : ca                       dex
80da : ca                       dex
80db : ca                       dex
80dc : ca                       dex
80dd : ca                       dex             ;-10
80de : ca                       dex
80df : ca                       dex
80e0 : ca                       dex
80e1 : ca                       dex
80e2 : ca                       dex
80e3 : ca                       dex
80e4 : ca                       dex             ;-3
80e5 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
80e6 =                  range_adr   = *+1       ;modifiable relative address
80e5 : f03e                     beq *+64        ;+64 if called without modification
80e7 : ca                       dex             ;+0
80e8 : ca                       dex
80e9 : ca                       dex
80ea : ca                       dex
80eb : ca                       dex
80ec : ca                       dex
80ed : ca                       dex
80ee : ca                       dex
80ef : ca                       dex
80f0 : ca                       dex
80f1 : ca                       dex             ;+10
80f2 : ca                       dex
80f3 : ca                       dex
80f4 : ca                       dex
80f5 : ca                       dex
80f6 : ca                       dex
80f7 : ca                       dex
80f8 : ca                       dex
80f9 : ca                       dex
80fa : ca                       dex
80fb : ca                       dex             ;+20
80fc : ca                       dex
80fd : ca                       dex
80fe : ca                       dex
80ff : ca                       dex
8100 : ca                       dex
8101 : ca                       dex
8102 : ca                       dex
8103 : ca                       dex
8104 : ca                       dex
8105 : ca                       dex             ;+30
8106 : ca                       dex
8107 : ca                       dex
8108 : ca                       dex
8109 : ca                       dex
810a : ca                       dex
810b : ca                       dex
810c : ca                       dex
810d : ca                       dex
810e : ca                       dex
810f : ca                       dex             ;+40
8110 : ca                       dex
8111 : ca                       dex
8112 : ca                       dex
8113 : ca                       dex
8114 : ca                       dex
8115 : ca                       dex
8116 : ca                       dex
8117 : ca                       dex
8118 : ca                       dex
8119 : ca                       dex             ;+50
811a : ca                       dex
811b : ca                       dex
811c : ca                       dex
811d : ca                       dex
811e : ca                       dex
811f : ca                       dex
8120 : ca                       dex
8121 : ca                       dex
8122 : ca                       dex
8123 : ca                       dex             ;+60
8124 : ca                       dex
8125 : ca                       dex
8126 : ca                       dex
8127 : ca                       dex
8128 : ca                       dex
8129 : ca                       dex
812a : ca                       dex
812b : ca                       dex
812c : ca                       dex
812d : ca                       dex             ;+70
812e : ca                       dex
812f : ca                       dex
8130 : ca                       dex
8131 : ca                       dex
8132 : ca                       dex
8133 : ca                       dex
8134 : ca                       dex
8135 : ca                       dex
8136 : ca                       dex
8137 : ca                       dex             ;+80
8138 : ca                       dex
8139 : ca                       dex
813a : ca                       dex
813b : ca                       dex
813c : ca                       dex
813d : ca                       dex
813e : ca                       dex
813f : ca                       dex
8140 : ca                       dex
8141 : ca                       dex             ;+90
8142 : ca                       dex
8143 : ca                       dex
8144 : ca                       dex
8145 : ca                       dex
8146 : ca                       dex
8147 : ca                       dex
8148 : ca                       dex
8149 : ca                       dex
814a : ca                       dex
814b : ca                       dex             ;+100
814c : ca                       dex
814d : ca                       dex
814e : ca                       dex
814f : ca                       dex
8150 : ca                       dex
8151 : ca                       dex
8152 : ca                       dex
8153 : ca                       dex
8154 : ca                       dex
8155 : ca                       dex             ;+110
8156 : ca                       dex
8157 : ca                       dex
8158 : ca                       dex
8159 : ca                       dex
815a : ca                       dex
815b : ca                       dex
815c : ca                       dex
815d : ca                       dex
815e : ca                       dex
815f : ca                       dex             ;+120
8160 : ca                       dex
8161 : ca                       dex
8162 : ca                       dex
8163 : ca                       dex
8164 : ca                       dex
8165 : ca                       dex
8166 : ea                       nop             ;offset landing zone - forward branch too far
8167 : ea                       nop
8168 : ea                       nop
8169 : ea                       nop
816a : ea                       nop
816b : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
816d : 4c6d81          >        jmp *           ;failed anyway
                        
8170 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
8171 : ea                       nop
8172 : ea                       nop
8173 : ea                       nop
8174 : ea                       nop
8175 :                  range_ok
8175 : ea                       nop
8176 : ea                       nop
8177 : ea                       nop
8178 : ea                       nop
8179 : ea                       nop
817a : c000                     cpy #0
817c : f003                     beq range_end   
817e : 4c4680                   jmp range_loop
8181 :                  range_end               ;range test successful
                            endif
                                next_test
8181 : ad0002          >            lda test_case   ;previous test
8184 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8186 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
8188 : a902            >            lda #test_num   ;*** next tests' number
818a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
818d : c001                     cpy #1          ;testing BNE true
818f : d003                     bne test_bne
                                trap 
8191 : 4c9181          >        jmp *           ;failed anyway
                        
8194 :                  test_bne
8194 : a900                     lda #0 
8196 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
8198 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
819a : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
819c : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
819e : c901                     cmp #1
                                trap_eq 
81a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
81a2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
81a4 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
81a6 : aa                       tax 
81a7 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
81a9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
81ab : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
81ad : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
81af : e001                     cpx #1
                                trap_eq 
81b1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
81b3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
81b5 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
81b7 : a8                       tay 
81b8 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
81ba : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
81bc : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
81be : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
81c0 : c001                     cpy #1
                                trap_eq 
81c2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
81c4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
81c6 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                next_test
81c8 : ad0002          >            lda test_case   ;previous test
81cb : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
81cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
81cf : a903            >            lda #test_num   ;*** next tests' number
81d1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
81d4 : a2ff                     ldx #$ff        ;initialize stack
81d6 : 9a                       txs
81d7 : a955                     lda #$55
81d9 : 48                       pha
81da : a9aa                     lda #$aa
81dc : 48                       pha
81dd : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
81e0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
81e2 : ba                       tsx
81e3 : 8a                       txa             ;overwrite accu
81e4 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
81e6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
81e8 : 68                       pla
81e9 : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
81eb : d0fe            >        bne *         ;failed not equal (non zero)
                        
81ed : 68                       pla
81ee : c955                     cmp #$55
                                trap_ne
81f0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
81f2 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
81f5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
81f7 : ba                       tsx
81f8 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
81fa : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
81fc : ad0002          >            lda test_case   ;previous test
81ff : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8201 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
8203 : a904            >            lda #test_num   ;*** next tests' number
8205 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
8208 : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
820a : 48              >            pha         ;use stack to load status
820b : 28              >            plp
                        
820c : 101a                     bpl nbr1        ;branches should not be taken
820e : 501b                     bvc nbr2
8210 : 901c                     bcc nbr3
8212 : d01d                     bne nbr4
8214 : 3003                     bmi br1         ;branches should be taken
                                trap 
8216 : 4c1682          >        jmp *           ;failed anyway
                        
8219 : 7003             br1     bvs br2
                                trap 
821b : 4c1b82          >        jmp *           ;failed anyway
                        
821e : b003             br2     bcs br3
                                trap 
8220 : 4c2082          >        jmp *           ;failed anyway
                        
8223 : f00f             br3     beq br4
                                trap 
8225 : 4c2582          >        jmp *           ;failed anyway
                        
8228 :                  nbr1
                                trap            ;previous bpl taken 
8228 : 4c2882          >        jmp *           ;failed anyway
                        
822b :                  nbr2
                                trap            ;previous bvc taken
822b : 4c2b82          >        jmp *           ;failed anyway
                        
822e :                  nbr3
                                trap            ;previous bcc taken
822e : 4c2e82          >        jmp *           ;failed anyway
                        
8231 :                  nbr4
                                trap            ;previous bne taken
8231 : 4c3182          >        jmp *           ;failed anyway
                        
8234 : 08               br4     php
8235 : ba                       tsx
8236 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
8238 : d0fe            >        bne *         ;failed not equal (non zero)
                        
823a : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
823b : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
823d : d0fe            >        bne *         ;failed not equal (non zero)
                        
823f : ba                       tsx
8240 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
8242 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
8244 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
8246 : 48              >            pha         ;use stack to load status
8247 : 28              >            plp
                        
8248 : 301a                     bmi nbr11       ;branches should not be taken
824a : 701b                     bvs nbr12
824c : b01c                     bcs nbr13
824e : f01d                     beq nbr14
8250 : 1003                     bpl br11        ;branches should be taken
                                trap 
8252 : 4c5282          >        jmp *           ;failed anyway
                        
8255 : 5003             br11    bvc br12
                                trap 
8257 : 4c5782          >        jmp *           ;failed anyway
                        
825a : 9003             br12    bcc br13
                                trap 
825c : 4c5c82          >        jmp *           ;failed anyway
                        
825f : d00f             br13    bne br14
                                trap 
8261 : 4c6182          >        jmp *           ;failed anyway
                        
8264 :                  nbr11
                                trap            ;previous bmi taken 
8264 : 4c6482          >        jmp *           ;failed anyway
                        
8267 :                  nbr12
                                trap            ;previous bvs taken 
8267 : 4c6782          >        jmp *           ;failed anyway
                        
826a :                  nbr13
                                trap            ;previous bcs taken 
826a : 4c6a82          >        jmp *           ;failed anyway
                        
826d :                  nbr14
                                trap            ;previous beq taken 
826d : 4c6d82          >        jmp *           ;failed anyway
                        
8270 : 08               br14    php
8271 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
8272 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                ;cmp #0
                        		trap_ne
8274 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
8276 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
8278 : 48              >            pha         ;use stack to load status
8279 : 28              >            plp
                        
827a : d002                     bne brzs1
827c : f003                     beq brzs2
827e :                  brzs1
                                trap            ;branch zero/non zero
827e : 4c7e82          >        jmp *           ;failed anyway
                        
8281 : b002             brzs2   bcs brzs3
8283 : 9003                     bcc brzs4
8285 :                  brzs3
                                trap            ;branch carry/no carry
8285 : 4c8582          >        jmp *           ;failed anyway
                        
8288 : 3002             brzs4   bmi brzs5
828a : 1003                     bpl brzs6
828c :                  brzs5
                                trap            ;branch minus/plus
828c : 4c8c82          >        jmp *           ;failed anyway
                        
828f : 7002             brzs6   bvs brzs7
8291 : 5003                     bvc brzs8
8293 :                  brzs7
                                trap            ;branch overflow/no overflow
8293 : 4c9382          >        jmp *           ;failed anyway
                        
8296 :                  brzs8
                                set_stat carry
                       >            load_flag carry
8296 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
8298 : 48              >            pha         ;use stack to load status
8299 : 28              >            plp
                        
829a : f002                     beq brcs1
829c : d003                     bne brcs2
829e :                  brcs1
                                trap            ;branch zero/non zero
829e : 4c9e82          >        jmp *           ;failed anyway
                        
82a1 : 9002             brcs2   bcc brcs3
82a3 : b003                     bcs brcs4
82a5 :                  brcs3
                                trap            ;branch carry/no carry
82a5 : 4ca582          >        jmp *           ;failed anyway
                        
82a8 : 3002             brcs4   bmi brcs5
82aa : 1003                     bpl brcs6
82ac :                  brcs5
                                trap            ;branch minus/plus
82ac : 4cac82          >        jmp *           ;failed anyway
                        
82af : 7002             brcs6   bvs brcs7
82b1 : 5003                     bvc brcs8
82b3 :                  brcs7
                                trap            ;branch overflow/no overflow
82b3 : 4cb382          >        jmp *           ;failed anyway
                        
                        
82b6 :                  brcs8
                                set_stat minus
                       >            load_flag minus
82b6 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
82b8 : 48              >            pha         ;use stack to load status
82b9 : 28              >            plp
                        
82ba : f002                     beq brmi1
82bc : d003                     bne brmi2
82be :                  brmi1
                                trap            ;branch zero/non zero
82be : 4cbe82          >        jmp *           ;failed anyway
                        
82c1 : b002             brmi2   bcs brmi3
82c3 : 9003                     bcc brmi4
82c5 :                  brmi3
                                trap            ;branch carry/no carry
82c5 : 4cc582          >        jmp *           ;failed anyway
                        
82c8 : 1002             brmi4   bpl brmi5
82ca : 3003                     bmi brmi6
82cc :                  brmi5
                                trap            ;branch minus/plus
82cc : 4ccc82          >        jmp *           ;failed anyway
                        
82cf : 7002             brmi6   bvs brmi7
82d1 : 5003                     bvc brmi8
82d3 :                  brmi7
                                trap            ;branch overflow/no overflow
82d3 : 4cd382          >        jmp *           ;failed anyway
                        
82d6 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
82d6 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
82d8 : 48              >            pha         ;use stack to load status
82d9 : 28              >            plp
                        
82da : f002                     beq brvs1
82dc : d003                     bne brvs2
82de :                  brvs1
                                trap            ;branch zero/non zero
82de : 4cde82          >        jmp *           ;failed anyway
                        
82e1 : b002             brvs2   bcs brvs3
82e3 : 9003                     bcc brvs4
82e5 :                  brvs3
                                trap            ;branch carry/no carry
82e5 : 4ce582          >        jmp *           ;failed anyway
                        
82e8 : 3002             brvs4   bmi brvs5
82ea : 1003                     bpl brvs6
82ec :                  brvs5
                                trap            ;branch minus/plus
82ec : 4cec82          >        jmp *           ;failed anyway
                        
82ef : 5002             brvs6   bvc brvs7
82f1 : 7003                     bvs brvs8
82f3 :                  brvs7
                                trap            ;branch overflow/no overflow
82f3 : 4cf382          >        jmp *           ;failed anyway
                        
82f6 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
82f6 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
82f8 : 48              >            pha         ;use stack to load status
82f9 : 28              >            plp
                        
82fa : f002                     beq brzc1
82fc : d003                     bne brzc2
82fe :                  brzc1
                                trap            ;branch zero/non zero
82fe : 4cfe82          >        jmp *           ;failed anyway
                        
8301 : 9002             brzc2   bcc brzc3
8303 : b003                     bcs brzc4
8305 :                  brzc3
                                trap            ;branch carry/no carry
8305 : 4c0583          >        jmp *           ;failed anyway
                        
8308 : 1002             brzc4   bpl brzc5
830a : 3003                     bmi brzc6
830c :                  brzc5
                                trap            ;branch minus/plus
830c : 4c0c83          >        jmp *           ;failed anyway
                        
830f : 5002             brzc6   bvc brzc7
8311 : 7003                     bvs brzc8
8313 :                  brzc7
                                trap            ;branch overflow/no overflow
8313 : 4c1383          >        jmp *           ;failed anyway
                        
8316 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
8316 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
8318 : 48              >            pha         ;use stack to load status
8319 : 28              >            plp
                        
831a : d002                     bne brcc1
831c : f003                     beq brcc2
831e :                  brcc1
                                trap            ;branch zero/non zero
831e : 4c1e83          >        jmp *           ;failed anyway
                        
8321 : b002             brcc2   bcs brcc3
8323 : 9003                     bcc brcc4
8325 :                  brcc3
                                trap            ;branch carry/no carry
8325 : 4c2583          >        jmp *           ;failed anyway
                        
8328 : 1002             brcc4   bpl brcc5
832a : 3003                     bmi brcc6
832c :                  brcc5
                                trap            ;branch minus/plus
832c : 4c2c83          >        jmp *           ;failed anyway
                        
832f : 5002             brcc6   bvc brcc7
8331 : 7003                     bvs brcc8
8333 :                  brcc7
                                trap            ;branch overflow/no overflow
8333 : 4c3383          >        jmp *           ;failed anyway
                        
8336 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
8336 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
8338 : 48              >            pha         ;use stack to load status
8339 : 28              >            plp
                        
833a : d002                     bne brpl1
833c : f003                     beq brpl2
833e :                  brpl1
                                trap            ;branch zero/non zero
833e : 4c3e83          >        jmp *           ;failed anyway
                        
8341 : 9002             brpl2   bcc brpl3
8343 : b003                     bcs brpl4
8345 :                  brpl3
                                trap            ;branch carry/no carry
8345 : 4c4583          >        jmp *           ;failed anyway
                        
8348 : 3002             brpl4   bmi brpl5
834a : 1003                     bpl brpl6
834c :                  brpl5
                                trap            ;branch minus/plus
834c : 4c4c83          >        jmp *           ;failed anyway
                        
834f : 5002             brpl6   bvc brpl7
8351 : 7003                     bvs brpl8
8353 :                  brpl7
                                trap            ;branch overflow/no overflow
8353 : 4c5383          >        jmp *           ;failed anyway
                        
8356 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
8356 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
8358 : 48              >            pha         ;use stack to load status
8359 : 28              >            plp
                        
835a : d002                     bne brvc1
835c : f003                     beq brvc2
835e :                  brvc1
                                trap            ;branch zero/non zero
835e : 4c5e83          >        jmp *           ;failed anyway
                        
8361 : 9002             brvc2   bcc brvc3
8363 : b003                     bcs brvc4
8365 :                  brvc3
                                trap            ;branch carry/no carry
8365 : 4c6583          >        jmp *           ;failed anyway
                        
8368 : 1002             brvc4   bpl brvc5
836a : 3003                     bmi brvc6
836c :                  brvc5
                                trap            ;branch minus/plus
836c : 4c6c83          >        jmp *           ;failed anyway
                        
836f : 7002             brvc6   bvs brvc7
8371 : 5003                     bvc brvc8
8373 :                  brvc7
                                trap            ;branch overflow/no overflow
8373 : 4c7383          >        jmp *           ;failed anyway
                        
8376 :                  brvc8
                                next_test
8376 : ad0002          >            lda test_case   ;previous test
8379 : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
837b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
837d : a905            >            lda #test_num   ;*** next tests' number
837f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
8382 : a255                     ldx #$55        ;x & y protected
8384 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
8386 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
8388 : 48              >            pha         ;use stack to load status
8389 : a901            >            lda #1     ;precharge accu
838b : 28              >            plp
                        
838c : 48                       pha
                                tst_a 1,$ff
838d : 08              >            php         ;save flags
838e : c901            >            cmp #1     ;test result
                       >            trap_ne
8390 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8392 : 68              >            pla         ;load status
8393 : 48              >            pha
                       >            cmp_flag $ff
8394 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8396 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8398 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
8399 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
839b : 48              >            pha         ;use stack to load status
839c : a900            >            lda #0     ;precharge accu
839e : 28              >            plp
                        
839f : 48                       pha
                                tst_a 0,0
83a0 : 08              >            php         ;save flags
83a1 : c900            >            cmp #0     ;test result
                       >            trap_ne
83a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83a5 : 68              >            pla         ;load status
83a6 : 48              >            pha
                       >            cmp_flag 0
83a7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
83a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83ab : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
83ac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
83ae : 48              >            pha         ;use stack to load status
83af : a9ff            >            lda #$ff     ;precharge accu
83b1 : 28              >            plp
                        
83b2 : 48                       pha
                                tst_a $ff,$ff
83b3 : 08              >            php         ;save flags
83b4 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
83b6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83b8 : 68              >            pla         ;load status
83b9 : 48              >            pha
                       >            cmp_flag $ff
83ba : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
83bc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83be : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
83bf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
83c1 : 48              >            pha         ;use stack to load status
83c2 : a901            >            lda #1     ;precharge accu
83c4 : 28              >            plp
                        
83c5 : 48                       pha
                                tst_a 1,0
83c6 : 08              >            php         ;save flags
83c7 : c901            >            cmp #1     ;test result
                       >            trap_ne
83c9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83cb : 68              >            pla         ;load status
83cc : 48              >            pha
                       >            cmp_flag 0
83cd : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
83cf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83d1 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
83d2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
83d4 : 48              >            pha         ;use stack to load status
83d5 : a900            >            lda #0     ;precharge accu
83d7 : 28              >            plp
                        
83d8 : 48                       pha
                                tst_a 0,$ff
83d9 : 08              >            php         ;save flags
83da : c900            >            cmp #0     ;test result
                       >            trap_ne
83dc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83de : 68              >            pla         ;load status
83df : 48              >            pha
                       >            cmp_flag $ff
83e0 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
83e2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83e4 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
83e5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
83e7 : 48              >            pha         ;use stack to load status
83e8 : a9ff            >            lda #$ff     ;precharge accu
83ea : 28              >            plp
                        
83eb : 48                       pha
                                tst_a $ff,0
83ec : 08              >            php         ;save flags
83ed : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
83ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83f1 : 68              >            pla         ;load status
83f2 : 48              >            pha
                       >            cmp_flag 0
83f3 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
83f5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
83f7 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
83f8 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
83fa : 48              >            pha         ;use stack to load status
83fb : a900            >            lda #0     ;precharge accu
83fd : 28              >            plp
                        
83fe : 68                       pla
                                tst_a $ff,$ff-zero
83ff : 08              >            php         ;save flags
8400 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
8402 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8404 : 68              >            pla         ;load status
8405 : 48              >            pha
                       >            cmp_flag $ff-zero
8406 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8408 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
840a : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
840b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
840d : 48              >            pha         ;use stack to load status
840e : a9ff            >            lda #$ff     ;precharge accu
8410 : 28              >            plp
                        
8411 : 68                       pla
                                tst_a 0,zero
8412 : 08              >            php         ;save flags
8413 : c900            >            cmp #0     ;test result
                       >            trap_ne
8415 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8417 : 68              >            pla         ;load status
8418 : 48              >            pha
                       >            cmp_flag zero
8419 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
841b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
841d : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
841e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8420 : 48              >            pha         ;use stack to load status
8421 : a9fe            >            lda #$fe     ;precharge accu
8423 : 28              >            plp
                        
8424 : 68                       pla
                                tst_a 1,$ff-zero-minus
8425 : 08              >            php         ;save flags
8426 : c901            >            cmp #1     ;test result
                       >            trap_ne
8428 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
842a : 68              >            pla         ;load status
842b : 48              >            pha
                       >            cmp_flag $ff-zero-minus
842c : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
842e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8430 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
8431 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8433 : 48              >            pha         ;use stack to load status
8434 : a900            >            lda #0     ;precharge accu
8436 : 28              >            plp
                        
8437 : 68                       pla
                                tst_a $ff,minus
8438 : 08              >            php         ;save flags
8439 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
843b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
843d : 68              >            pla         ;load status
843e : 48              >            pha
                       >            cmp_flag minus
843f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8441 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8443 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
8444 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8446 : 48              >            pha         ;use stack to load status
8447 : a9ff            >            lda #$ff     ;precharge accu
8449 : 28              >            plp
                        
844a : 68                       pla
                                tst_a 0,$ff-minus
844b : 08              >            php         ;save flags
844c : c900            >            cmp #0     ;test result
                       >            trap_ne
844e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8450 : 68              >            pla         ;load status
8451 : 48              >            pha
                       >            cmp_flag $ff-minus
8452 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8454 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8456 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
8457 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8459 : 48              >            pha         ;use stack to load status
845a : a9fe            >            lda #$fe     ;precharge accu
845c : 28              >            plp
                        
845d : 68                       pla
                                tst_a 1,0
845e : 08              >            php         ;save flags
845f : c901            >            cmp #1     ;test result
                       >            trap_ne
8461 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8463 : 68              >            pla         ;load status
8464 : 48              >            pha
                       >            cmp_flag 0
8465 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8467 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8469 : 28              >            plp         ;restore status
                        
846a : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
846c : d0fe            >        bne *         ;failed not equal (non zero)
                        
846e : c0aa                     cpy #$aa
                                trap_ne
8470 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
8472 : ad0002          >            lda test_case   ;previous test
8475 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8477 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
8479 : a906            >            lda #test_num   ;*** next tests' number
847b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
847e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8480 : 48              >            pha         ;use stack to load status
8481 : a93c            >            lda #$3c     ;precharge accu
8483 : 28              >            plp
                        
8484 : 49c3                     eor #$c3
                                tst_a $ff,fn
8486 : 08              >            php         ;save flags
8487 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
8489 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
848b : 68              >            pla         ;load status
848c : 48              >            pha
                       >            cmp_flag fn
848d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
848f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8491 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
8492 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8494 : 48              >            pha         ;use stack to load status
8495 : a9c3            >            lda #$c3     ;precharge accu
8497 : 28              >            plp
                        
8498 : 49c3                     eor #$c3
                                tst_a 0,fz
849a : 08              >            php         ;save flags
849b : c900            >            cmp #0     ;test result
                       >            trap_ne
849d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
849f : 68              >            pla         ;load status
84a0 : 48              >            pha
                       >            cmp_flag fz
84a1 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
84a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84a5 : 28              >            plp         ;restore status
                        
                                next_test
84a6 : ad0002          >            lda test_case   ;previous test
84a9 : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
84ab : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
84ad : a907            >            lda #test_num   ;*** next tests' number
84af : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
84b2 : a224                     ldx #$24
84b4 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
84b6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
84b8 : 48              >            pha         ;use stack to load status
84b9 : a918            >            lda #$18     ;precharge accu
84bb : 28              >            plp
                        
84bc : ea                       nop
                                tst_a $18,0
84bd : 08              >            php         ;save flags
84be : c918            >            cmp #$18     ;test result
                       >            trap_ne
84c0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84c2 : 68              >            pla         ;load status
84c3 : 48              >            pha
                       >            cmp_flag 0
84c4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
84c6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84c8 : 28              >            plp         ;restore status
                        
84c9 : e024                     cpx #$24
                                trap_ne
84cb : d0fe            >        bne *         ;failed not equal (non zero)
                        
84cd : c042                     cpy #$42
                                trap_ne
84cf : d0fe            >        bne *         ;failed not equal (non zero)
                        
84d1 : a2db                     ldx #$db
84d3 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
84d5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
84d7 : 48              >            pha         ;use stack to load status
84d8 : a9e7            >            lda #$e7     ;precharge accu
84da : 28              >            plp
                        
84db : ea                       nop
                                tst_a $e7,$ff
84dc : 08              >            php         ;save flags
84dd : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
84df : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84e1 : 68              >            pla         ;load status
84e2 : 48              >            pha
                       >            cmp_flag $ff
84e3 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
84e5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
84e7 : 28              >            plp         ;restore status
                        
84e8 : e0db                     cpx #$db
                                trap_ne
84ea : d0fe            >        bne *         ;failed not equal (non zero)
                        
84ec : c0bd                     cpy #$bd
                                trap_ne
84ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
84f0 : ad0002          >            lda test_case   ;previous test
84f3 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
84f5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
84f7 : a908            >            lda #test_num   ;*** next tests' number
84f9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
84fc : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
84fe : 48              >            pha         ;use stack to load status
84ff : 28              >            plp
                        
8500 : a946                     lda #'F'
8502 : a241                     ldx #'A'
8504 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
8506 : 4cc0b0                   jmp test_far
8509 : ea                       nop
850a : ea                       nop
                                trap_ne         ;runover protection
850b : d0fe            >        bne *         ;failed not equal (non zero)
                        
850d : e8                       inx
850e : e8                       inx
850f :                  far_ret 
                                trap_eq         ;returned flags OK?
850f : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
8511 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
8513 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
8515 : 50fe            >        bvc *           ;failed overflow clear
                        
8517 : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
8519 : d0fe            >        bne *         ;failed not equal (non zero)
                        
851b : e042                     cpx #('A'+1)
                                trap_ne
851d : d0fe            >        bne *         ;failed not equal (non zero)
                        
851f : c04f                     cpy #('R'-3)
                                trap_ne
8521 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8523 : ca                       dex
8524 : c8                       iny
8525 : c8                       iny
8526 : c8                       iny
8527 : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
8529 : 4c3285                   jmp test_near
852c : ea                       nop
852d : ea                       nop
                                trap_ne         ;runover protection
852e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8530 : e8                       inx
8531 : e8                       inx
8532 :                  test_near
                                trap_eq         ;passed flags OK?
8532 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
8534 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_cc
8536 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
8538 : 50fe            >        bvc *           ;failed overflow clear
                        
853a : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
853c : d0fe            >        bne *         ;failed not equal (non zero)
                        
853e : e041                     cpx #'A'
                                trap_ne
8540 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8542 : c052                     cpy #'R'
                                trap_ne
8544 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
8546 : ad0002          >            lda test_case   ;previous test
8549 : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
854b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
854d : a909            >            lda #test_num   ;*** next tests' number
854f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
8552 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8554 : 48              >            pha         ;use stack to load status
8555 : 28              >            plp
                        
8556 : a949                     lda #'I'
8558 : a24e                     ldx #'N'
855a : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
855c : 6ceeb0                   jmp (ptr_tst_ind)
855f : ea                       nop
                                trap_ne         ;runover protection
8560 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8562 : 88                       dey
8563 : 88                       dey
8564 :                  ind_ret 
8564 : 08                       php             ;either SP or Y count will fail, if we do not hit
8565 : 88                       dey
8566 : 88                       dey
8567 : 88                       dey
8568 : 28                       plp
                                trap_eq         ;returned flags OK?
8569 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
856b : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
856d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
856f : 50fe            >        bvc *           ;failed overflow clear
                        
8571 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
8573 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8575 : e04f                     cpx #('N'+1)
                                trap_ne
8577 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8579 : c03e                     cpy #('D'-6)
                                trap_ne
857b : d0fe            >        bne *         ;failed not equal (non zero)
                        
857d : ba                       tsx             ;SP check
857e : e0ff                     cpx #$ff
                                trap_ne
8580 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
8582 : ad0002          >            lda test_case   ;previous test
8585 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8587 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
8589 : a90a            >            lda #test_num   ;*** next tests' number
858b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
858e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8590 : 48              >            pha         ;use stack to load status
8591 : 28              >            plp
                        
8592 : a94a                     lda #'J'
8594 : a253                     ldx #'S'
8596 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
8598 : 202db1                   jsr test_jsr
859a =                  jsr_ret = *-1           ;last address of jsr = return address
859b : 08                       php             ;either SP or Y count will fail, if we do not hit
859c : 88                       dey
859d : 88                       dey
859e : 88                       dey
859f : 28                       plp
                                trap_eq         ;returned flags OK?
85a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
85a2 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
85a4 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
85a6 : 50fe            >        bvc *           ;failed overflow clear
                        
85a8 : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
85aa : d0fe            >        bne *         ;failed not equal (non zero)
                        
85ac : e054                     cpx #('S'+1)
                                trap_ne
85ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
85b0 : c04c                     cpy #('R'-6)
                                trap_ne
85b2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
85b4 : ba                       tsx             ;sp?
85b5 : e0ff                     cpx #$ff
                                trap_ne
85b7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
85b9 : ad0002          >            lda test_case   ;previous test
85bc : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
85be : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
85c0 : a90b            >            lda #test_num   ;*** next tests' number
85c2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
85c5 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
85c7 : 48                       pha
85c8 : a942                     lda #'B'
85ca : a252                     ldx #'R'
85cc : a04b                     ldy #'K'
85ce : 28                       plp             ;N=0, V=0, Z=0, C=0
85cf : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
85d0 : 88                       dey             ;should not be executed
85d1 :                  brk_ret0                ;address of break return
85d1 : 08                       php             ;either SP or Y count will fail, if we do not hit
85d2 : 88                       dey
85d3 : 88                       dey
85d4 : 88                       dey
85d5 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
85d7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
85d9 : e053                     cpx #'R'+1
                                trap_ne
85db : d0fe            >        bne *         ;failed not equal (non zero)
                        
85dd : c045                     cpy #'K'-6
                                trap_ne
85df : d0fe            >        bne *         ;failed not equal (non zero)
                        
85e1 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
85e2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
85e4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
85e6 : ba                       tsx             ;sp?
85e7 : e0ff                     cpx #$ff
                                trap_ne
85e9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
85eb : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
85ed : 48                       pha
85ee : a9bd                     lda #$ff-'B'
85f0 : a2ad                     ldx #$ff-'R'
85f2 : a0b4                     ldy #$ff-'K'
85f4 : 28                       plp             ;N=1, V=1, Z=1, C=1
85f5 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
85f6 : 88                       dey             ;should not be executed
85f7 :                  brk_ret1                ;address of break return
85f7 : 08                       php             ;either SP or Y count will fail, if we do not hit
85f8 : 88                       dey
85f9 : 88                       dey
85fa : 88                       dey
85fb : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
85fd : d0fe            >        bne *         ;failed not equal (non zero)
                        
85ff : e0ae                     cpx #$ff-'R'+1
                                trap_ne
8601 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8603 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
8605 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8607 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
8608 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
860a : d0fe            >        bne *         ;failed not equal (non zero)
                        
860c : ba                       tsx             ;sp?
860d : e0ff                     cpx #$ff
                                trap_ne
860f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
8611 : ad0002          >            lda test_case   ;previous test
8614 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8616 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
8618 : a90c            >            lda #test_num   ;*** next tests' number
861a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
861d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
861f : 48              >            pha         ;use stack to load status
8620 : 28              >            plp
                        
8621 : 18                       clc
                                tst_stat $ff-carry
8622 : 08              >            php         ;save status
8623 : 68              >            pla         ;use stack to retrieve status
8624 : 48              >            pha
                       >            cmp_flag $ff-carry
8625 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8627 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8629 : 28              >            plp         ;restore status
                        
862a : 38                       sec
                                tst_stat $ff
862b : 08              >            php         ;save status
862c : 68              >            pla         ;use stack to retrieve status
862d : 48              >            pha
                       >            cmp_flag $ff
862e : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8630 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8632 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
8633 : 58                       cli
                                tst_stat $ff-intdis
8634 : 08              >            php         ;save status
8635 : 68              >            pla         ;use stack to retrieve status
8636 : 48              >            pha
                       >            cmp_flag $ff-intdis
8637 : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8639 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
863b : 28              >            plp         ;restore status
                        
863c : 78                       sei
                                tst_stat $ff
863d : 08              >            php         ;save status
863e : 68              >            pla         ;use stack to retrieve status
863f : 48              >            pha
                       >            cmp_flag $ff
8640 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8642 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8644 : 28              >            plp         ;restore status
                        
                            endif
8645 : d8                       cld
                                tst_stat $ff-decmode
8646 : 08              >            php         ;save status
8647 : 68              >            pla         ;use stack to retrieve status
8648 : 48              >            pha
                       >            cmp_flag $ff-decmode
8649 : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
864b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
864d : 28              >            plp         ;restore status
                        
864e : f8                       sed
                                tst_stat $ff
864f : 08              >            php         ;save status
8650 : 68              >            pla         ;use stack to retrieve status
8651 : 48              >            pha
                       >            cmp_flag $ff
8652 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8654 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8656 : 28              >            plp         ;restore status
                        
8657 : b8                       clv
                                tst_stat $ff-overfl
8658 : 08              >            php         ;save status
8659 : 68              >            pla         ;use stack to retrieve status
865a : 48              >            pha
                       >            cmp_flag $ff-overfl
865b : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
865d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
865f : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
8660 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8662 : 48              >            pha         ;use stack to load status
8663 : 28              >            plp
                        
                                tst_stat 0
8664 : 08              >            php         ;save status
8665 : 68              >            pla         ;use stack to retrieve status
8666 : 48              >            pha
                       >            cmp_flag 0
8667 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8669 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
866b : 28              >            plp         ;restore status
                        
866c : 38                       sec
                                tst_stat carry
866d : 08              >            php         ;save status
866e : 68              >            pla         ;use stack to retrieve status
866f : 48              >            pha
                       >            cmp_flag carry
8670 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8672 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8674 : 28              >            plp         ;restore status
                        
8675 : 18                       clc
                                tst_stat 0  
8676 : 08              >            php         ;save status
8677 : 68              >            pla         ;use stack to retrieve status
8678 : 48              >            pha
                       >            cmp_flag 0  
8679 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
867b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
867d : 28              >            plp         ;restore status
                        
                            if I_flag = 3
867e : 78                       sei
                                tst_stat intdis
867f : 08              >            php         ;save status
8680 : 68              >            pla         ;use stack to retrieve status
8681 : 48              >            pha
                       >            cmp_flag intdis
8682 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8684 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8686 : 28              >            plp         ;restore status
                        
8687 : 58                       cli
                                tst_stat 0
8688 : 08              >            php         ;save status
8689 : 68              >            pla         ;use stack to retrieve status
868a : 48              >            pha
                       >            cmp_flag 0
868b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
868d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
868f : 28              >            plp         ;restore status
                        
                            endif  
8690 : f8                       sed
                                tst_stat decmode
8691 : 08              >            php         ;save status
8692 : 68              >            pla         ;use stack to retrieve status
8693 : 48              >            pha
                       >            cmp_flag decmode
8694 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8696 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8698 : 28              >            plp         ;restore status
                        
8699 : d8                       cld
                                tst_stat 0  
869a : 08              >            php         ;save status
869b : 68              >            pla         ;use stack to retrieve status
869c : 48              >            pha
                       >            cmp_flag 0  
869d : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
869f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86a1 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
86a2 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
86a4 : 48              >            pha         ;use stack to load status
86a5 : 28              >            plp
                        
                                tst_stat overfl
86a6 : 08              >            php         ;save status
86a7 : 68              >            pla         ;use stack to retrieve status
86a8 : 48              >            pha
                       >            cmp_flag overfl
86a9 : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86ab : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86ad : 28              >            plp         ;restore status
                        
86ae : b8                       clv
                                tst_stat 0
86af : 08              >            php         ;save status
86b0 : 68              >            pla         ;use stack to retrieve status
86b1 : 48              >            pha
                       >            cmp_flag 0
86b2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86b4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86b6 : 28              >            plp         ;restore status
                        
                                next_test
86b7 : ad0002          >            lda test_case   ;previous test
86ba : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
86bc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
86be : a90d            >            lda #test_num   ;*** next tests' number
86c0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
86c3 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
86c5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
86c7 : 48              >            pha         ;use stack to load status
86c8 : 28              >            plp
                        
86c9 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
86ca : 08              >            php         ;save flags
86cb : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
86cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86cf : 68              >            pla         ;load status
86d0 : 48              >            pha
                       >            cmp_flag $ff-zero
86d1 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86d3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86d5 : 28              >            plp         ;restore status
                        
86d6 : e8                       inx             ;00
                                tst_x 0,$ff-minus
86d7 : 08              >            php         ;save flags
86d8 : e000            >            cpx #0     ;test result
                       >            trap_ne
86da : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86dc : 68              >            pla         ;load status
86dd : 48              >            pha
                       >            cmp_flag $ff-minus
86de : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86e0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86e2 : 28              >            plp         ;restore status
                        
86e3 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
86e4 : 08              >            php         ;save flags
86e5 : e001            >            cpx #1     ;test result
                       >            trap_ne
86e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86e9 : 68              >            pla         ;load status
86ea : 48              >            pha
                       >            cmp_flag $ff-minus-zero
86eb : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86ed : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86ef : 28              >            plp         ;restore status
                        
86f0 : ca                       dex             ;00
                                tst_x 0,$ff-minus
86f1 : 08              >            php         ;save flags
86f2 : e000            >            cpx #0     ;test result
                       >            trap_ne
86f4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86f6 : 68              >            pla         ;load status
86f7 : 48              >            pha
                       >            cmp_flag $ff-minus
86f8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
86fa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
86fc : 28              >            plp         ;restore status
                        
86fd : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
86fe : 08              >            php         ;save flags
86ff : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
8701 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8703 : 68              >            pla         ;load status
8704 : 48              >            pha
                       >            cmp_flag $ff-zero
8705 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8707 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8709 : 28              >            plp         ;restore status
                        
870a : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
870b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
870d : 48              >            pha         ;use stack to load status
870e : 28              >            plp
                        
870f : e8                       inx             ;ff
                                tst_x $ff,minus
8710 : 08              >            php         ;save flags
8711 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
8713 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8715 : 68              >            pla         ;load status
8716 : 48              >            pha
                       >            cmp_flag minus
8717 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8719 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
871b : 28              >            plp         ;restore status
                        
871c : e8                       inx             ;00
                                tst_x 0,zero
871d : 08              >            php         ;save flags
871e : e000            >            cpx #0     ;test result
                       >            trap_ne
8720 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8722 : 68              >            pla         ;load status
8723 : 48              >            pha
                       >            cmp_flag zero
8724 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8726 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8728 : 28              >            plp         ;restore status
                        
8729 : e8                       inx             ;01
                                tst_x 1,0
872a : 08              >            php         ;save flags
872b : e001            >            cpx #1     ;test result
                       >            trap_ne
872d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
872f : 68              >            pla         ;load status
8730 : 48              >            pha
                       >            cmp_flag 0
8731 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8733 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8735 : 28              >            plp         ;restore status
                        
8736 : ca                       dex             ;00
                                tst_x 0,zero
8737 : 08              >            php         ;save flags
8738 : e000            >            cpx #0     ;test result
                       >            trap_ne
873a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
873c : 68              >            pla         ;load status
873d : 48              >            pha
                       >            cmp_flag zero
873e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8740 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8742 : 28              >            plp         ;restore status
                        
8743 : ca                       dex             ;ff
                                tst_x $ff,minus
8744 : 08              >            php         ;save flags
8745 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
8747 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8749 : 68              >            pla         ;load status
874a : 48              >            pha
                       >            cmp_flag minus
874b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
874d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
874f : 28              >            plp         ;restore status
                        
                        
8750 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
8752 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8754 : 48              >            pha         ;use stack to load status
8755 : 28              >            plp
                        
8756 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
8757 : 08              >            php         ;save flags
8758 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
875a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
875c : 68              >            pla         ;load status
875d : 48              >            pha
                       >            cmp_flag $ff-zero
875e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8760 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8762 : 28              >            plp         ;restore status
                        
8763 : c8                       iny             ;00
                                tst_y 0,$ff-minus
8764 : 08              >            php         ;save flags
8765 : c000            >            cpy #0     ;test result
                       >            trap_ne
8767 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8769 : 68              >            pla         ;load status
876a : 48              >            pha
                       >            cmp_flag $ff-minus
876b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
876d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
876f : 28              >            plp         ;restore status
                        
8770 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
8771 : 08              >            php         ;save flags
8772 : c001            >            cpy #1     ;test result
                       >            trap_ne
8774 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8776 : 68              >            pla         ;load status
8777 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
8778 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
877a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
877c : 28              >            plp         ;restore status
                        
877d : 88                       dey             ;00
                                tst_y 0,$ff-minus
877e : 08              >            php         ;save flags
877f : c000            >            cpy #0     ;test result
                       >            trap_ne
8781 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8783 : 68              >            pla         ;load status
8784 : 48              >            pha
                       >            cmp_flag $ff-minus
8785 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8787 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8789 : 28              >            plp         ;restore status
                        
878a : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
878b : 08              >            php         ;save flags
878c : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
878e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8790 : 68              >            pla         ;load status
8791 : 48              >            pha
                       >            cmp_flag $ff-zero
8792 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8794 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8796 : 28              >            plp         ;restore status
                        
8797 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
8798 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
879a : 48              >            pha         ;use stack to load status
879b : 28              >            plp
                        
879c : c8                       iny             ;ff
                                tst_y $ff,0+minus
879d : 08              >            php         ;save flags
879e : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
87a0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87a2 : 68              >            pla         ;load status
87a3 : 48              >            pha
                       >            cmp_flag 0+minus
87a4 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87a6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87a8 : 28              >            plp         ;restore status
                        
87a9 : c8                       iny             ;00
                                tst_y 0,zero
87aa : 08              >            php         ;save flags
87ab : c000            >            cpy #0     ;test result
                       >            trap_ne
87ad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87af : 68              >            pla         ;load status
87b0 : 48              >            pha
                       >            cmp_flag zero
87b1 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87b3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87b5 : 28              >            plp         ;restore status
                        
87b6 : c8                       iny             ;01
                                tst_y 1,0
87b7 : 08              >            php         ;save flags
87b8 : c001            >            cpy #1     ;test result
                       >            trap_ne
87ba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87bc : 68              >            pla         ;load status
87bd : 48              >            pha
                       >            cmp_flag 0
87be : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87c0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87c2 : 28              >            plp         ;restore status
                        
87c3 : 88                       dey             ;00
                                tst_y 0,zero
87c4 : 08              >            php         ;save flags
87c5 : c000            >            cpy #0     ;test result
                       >            trap_ne
87c7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87c9 : 68              >            pla         ;load status
87ca : 48              >            pha
                       >            cmp_flag zero
87cb : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87cf : 28              >            plp         ;restore status
                        
87d0 : 88                       dey             ;ff
                                tst_y $ff,minus
87d1 : 08              >            php         ;save flags
87d2 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
87d4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87d6 : 68              >            pla         ;load status
87d7 : 48              >            pha
                       >            cmp_flag minus
87d8 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87da : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87dc : 28              >            plp         ;restore status
                        
                                        
87dd : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
87df : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
87e1 : 48              >            pha         ;use stack to load status
87e2 : 28              >            plp
                        
87e3 : 8a                       txa
                                tst_a $ff,$ff-zero
87e4 : 08              >            php         ;save flags
87e5 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
87e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87e9 : 68              >            pla         ;load status
87ea : 48              >            pha
                       >            cmp_flag $ff-zero
87eb : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87ed : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87ef : 28              >            plp         ;restore status
                        
87f0 : 08                       php
87f1 : e8                       inx             ;00
87f2 : 28                       plp
87f3 : 8a                       txa
                                tst_a 0,$ff-minus
87f4 : 08              >            php         ;save flags
87f5 : c900            >            cmp #0     ;test result
                       >            trap_ne
87f7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87f9 : 68              >            pla         ;load status
87fa : 48              >            pha
                       >            cmp_flag $ff-minus
87fb : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
87fd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
87ff : 28              >            plp         ;restore status
                        
8800 : 08                       php
8801 : e8                       inx             ;01
8802 : 28                       plp
8803 : 8a                       txa
                                tst_a 1,$ff-minus-zero
8804 : 08              >            php         ;save flags
8805 : c901            >            cmp #1     ;test result
                       >            trap_ne
8807 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8809 : 68              >            pla         ;load status
880a : 48              >            pha
                       >            cmp_flag $ff-minus-zero
880b : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
880d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
880f : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
8810 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8812 : 48              >            pha         ;use stack to load status
8813 : 28              >            plp
                        
8814 : 8a                       txa
                                tst_a 1,0
8815 : 08              >            php         ;save flags
8816 : c901            >            cmp #1     ;test result
                       >            trap_ne
8818 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
881a : 68              >            pla         ;load status
881b : 48              >            pha
                       >            cmp_flag 0
881c : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
881e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8820 : 28              >            plp         ;restore status
                        
8821 : 08                       php
8822 : ca                       dex             ;00
8823 : 28                       plp
8824 : 8a                       txa
                                tst_a 0,zero
8825 : 08              >            php         ;save flags
8826 : c900            >            cmp #0     ;test result
                       >            trap_ne
8828 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
882a : 68              >            pla         ;load status
882b : 48              >            pha
                       >            cmp_flag zero
882c : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
882e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8830 : 28              >            plp         ;restore status
                        
8831 : 08                       php
8832 : ca                       dex             ;ff
8833 : 28                       plp
8834 : 8a                       txa
                                tst_a $ff,minus
8835 : 08              >            php         ;save flags
8836 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
8838 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
883a : 68              >            pla         ;load status
883b : 48              >            pha
                       >            cmp_flag minus
883c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
883e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8840 : 28              >            plp         ;restore status
                        
                                                
8841 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
8843 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8845 : 48              >            pha         ;use stack to load status
8846 : 28              >            plp
                        
8847 : 98                       tya
                                tst_a $ff,$ff-zero
8848 : 08              >            php         ;save flags
8849 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
884b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
884d : 68              >            pla         ;load status
884e : 48              >            pha
                       >            cmp_flag $ff-zero
884f : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8851 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8853 : 28              >            plp         ;restore status
                        
8854 : 08                       php
8855 : c8                       iny             ;00
8856 : 28                       plp
8857 : 98                       tya
                                tst_a 0,$ff-minus
8858 : 08              >            php         ;save flags
8859 : c900            >            cmp #0     ;test result
                       >            trap_ne
885b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
885d : 68              >            pla         ;load status
885e : 48              >            pha
                       >            cmp_flag $ff-minus
885f : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8861 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8863 : 28              >            plp         ;restore status
                        
8864 : 08                       php
8865 : c8                       iny             ;01
8866 : 28                       plp
8867 : 98                       tya
                                tst_a 1,$ff-minus-zero
8868 : 08              >            php         ;save flags
8869 : c901            >            cmp #1     ;test result
                       >            trap_ne
886b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
886d : 68              >            pla         ;load status
886e : 48              >            pha
                       >            cmp_flag $ff-minus-zero
886f : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8871 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8873 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
8874 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8876 : 48              >            pha         ;use stack to load status
8877 : 28              >            plp
                        
8878 : 98                       tya
                                tst_a 1,0
8879 : 08              >            php         ;save flags
887a : c901            >            cmp #1     ;test result
                       >            trap_ne
887c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
887e : 68              >            pla         ;load status
887f : 48              >            pha
                       >            cmp_flag 0
8880 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8882 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8884 : 28              >            plp         ;restore status
                        
8885 : 08                       php
8886 : 88                       dey             ;00
8887 : 28                       plp
8888 : 98                       tya
                                tst_a 0,zero
8889 : 08              >            php         ;save flags
888a : c900            >            cmp #0     ;test result
                       >            trap_ne
888c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
888e : 68              >            pla         ;load status
888f : 48              >            pha
                       >            cmp_flag zero
8890 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8892 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8894 : 28              >            plp         ;restore status
                        
8895 : 08                       php
8896 : 88                       dey             ;ff
8897 : 28                       plp
8898 : 98                       tya
                                tst_a $ff,minus
8899 : 08              >            php         ;save flags
889a : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
889c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
889e : 68              >            pla         ;load status
889f : 48              >            pha
                       >            cmp_flag minus
88a0 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88a2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88a4 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
88a5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
88a7 : 48                       pha
88a8 : a2ff                     ldx #$ff        ;ff
88aa : 8a                       txa
88ab : 28                       plp             
88ac : a8                       tay
                                tst_y $ff,$ff-zero
88ad : 08              >            php         ;save flags
88ae : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
88b0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88b2 : 68              >            pla         ;load status
88b3 : 48              >            pha
                       >            cmp_flag $ff-zero
88b4 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88b6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88b8 : 28              >            plp         ;restore status
                        
88b9 : 08                       php
88ba : e8                       inx             ;00
88bb : 8a                       txa
88bc : 28                       plp
88bd : a8                       tay
                                tst_y 0,$ff-minus
88be : 08              >            php         ;save flags
88bf : c000            >            cpy #0     ;test result
                       >            trap_ne
88c1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88c3 : 68              >            pla         ;load status
88c4 : 48              >            pha
                       >            cmp_flag $ff-minus
88c5 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88c7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88c9 : 28              >            plp         ;restore status
                        
88ca : 08                       php
88cb : e8                       inx             ;01
88cc : 8a                       txa
88cd : 28                       plp
88ce : a8                       tay
                                tst_y 1,$ff-minus-zero
88cf : 08              >            php         ;save flags
88d0 : c001            >            cpy #1     ;test result
                       >            trap_ne
88d2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88d4 : 68              >            pla         ;load status
88d5 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
88d6 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88d8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88da : 28              >            plp         ;restore status
                        
                                load_flag 0
88db : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
88dd : 48                       pha
88de : a900                     lda #0
88e0 : 8a                       txa
88e1 : 28                       plp
88e2 : a8                       tay
                                tst_y 1,0
88e3 : 08              >            php         ;save flags
88e4 : c001            >            cpy #1     ;test result
                       >            trap_ne
88e6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88e8 : 68              >            pla         ;load status
88e9 : 48              >            pha
                       >            cmp_flag 0
88ea : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88ec : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88ee : 28              >            plp         ;restore status
                        
88ef : 08                       php
88f0 : ca                       dex             ;00
88f1 : 8a                       txa
88f2 : 28                       plp
88f3 : a8                       tay
                                tst_y 0,zero
88f4 : 08              >            php         ;save flags
88f5 : c000            >            cpy #0     ;test result
                       >            trap_ne
88f7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88f9 : 68              >            pla         ;load status
88fa : 48              >            pha
                       >            cmp_flag zero
88fb : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
88fd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
88ff : 28              >            plp         ;restore status
                        
8900 : 08                       php
8901 : ca                       dex             ;ff
8902 : 8a                       txa
8903 : 28                       plp
8904 : a8                       tay
                                tst_y $ff,minus
8905 : 08              >            php         ;save flags
8906 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
8908 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
890a : 68              >            pla         ;load status
890b : 48              >            pha
                       >            cmp_flag minus
890c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
890e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8910 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
8911 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
8913 : 48                       pha
8914 : a0ff                     ldy #$ff        ;ff
8916 : 98                       tya
8917 : 28                       plp
8918 : aa                       tax
                                tst_x $ff,$ff-zero
8919 : 08              >            php         ;save flags
891a : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
891c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
891e : 68              >            pla         ;load status
891f : 48              >            pha
                       >            cmp_flag $ff-zero
8920 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8922 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8924 : 28              >            plp         ;restore status
                        
8925 : 08                       php
8926 : c8                       iny             ;00
8927 : 98                       tya
8928 : 28                       plp
8929 : aa                       tax
                                tst_x 0,$ff-minus
892a : 08              >            php         ;save flags
892b : e000            >            cpx #0     ;test result
                       >            trap_ne
892d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
892f : 68              >            pla         ;load status
8930 : 48              >            pha
                       >            cmp_flag $ff-minus
8931 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8933 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8935 : 28              >            plp         ;restore status
                        
8936 : 08                       php
8937 : c8                       iny             ;01
8938 : 98                       tya
8939 : 28                       plp
893a : aa                       tax
                                tst_x 1,$ff-minus-zero
893b : 08              >            php         ;save flags
893c : e001            >            cpx #1     ;test result
                       >            trap_ne
893e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8940 : 68              >            pla         ;load status
8941 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
8942 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8944 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8946 : 28              >            plp         ;restore status
                        
                                load_flag 0
8947 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
8949 : 48                       pha
894a : a900                     lda #0          ;preset status
894c : 98                       tya
894d : 28                       plp
894e : aa                       tax
                                tst_x 1,0
894f : 08              >            php         ;save flags
8950 : e001            >            cpx #1     ;test result
                       >            trap_ne
8952 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8954 : 68              >            pla         ;load status
8955 : 48              >            pha
                       >            cmp_flag 0
8956 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8958 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
895a : 28              >            plp         ;restore status
                        
895b : 08                       php
895c : 88                       dey             ;00
895d : 98                       tya
895e : 28                       plp
895f : aa                       tax
                                tst_x 0,zero
8960 : 08              >            php         ;save flags
8961 : e000            >            cpx #0     ;test result
                       >            trap_ne
8963 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8965 : 68              >            pla         ;load status
8966 : 48              >            pha
                       >            cmp_flag zero
8967 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
8969 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
896b : 28              >            plp         ;restore status
                        
896c : 08                       php
896d : 88                       dey             ;ff
896e : 98                       tya
896f : 28                       plp
8970 : aa                       tax
                                tst_x $ff,minus
8971 : 08              >            php         ;save flags
8972 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
8974 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
8976 : 68              >            pla         ;load status
8977 : 48              >            pha
                       >            cmp_flag minus
8978 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
897a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
897c : 28              >            plp         ;restore status
                        
                                next_test
897d : ad0002          >            lda test_case   ;previous test
8980 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8982 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
8984 : a90e            >            lda #test_num   ;*** next tests' number
8986 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
8989 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
898b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
898d : 48              >            pha         ;use stack to load status
898e : 28              >            plp
                        
898f : 9a                       txs
8990 : 08                       php
8991 : ad0101                   lda $101
                                cmp_flag $ff
8994 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8996 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8998 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
899a : 48              >            pha         ;use stack to load status
899b : 28              >            plp
                        
899c : 9a                       txs
899d : 08                       php
899e : ad0101                   lda $101
                                cmp_flag 0
89a1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89a3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
89a5 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
89a6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
89a8 : 48              >            pha         ;use stack to load status
89a9 : 28              >            plp
                        
89aa : 9a                       txs
89ab : 08                       php
89ac : ad0001                   lda $100
                                cmp_flag $ff
89af : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89b1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
89b3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
89b5 : 48              >            pha         ;use stack to load status
89b6 : 28              >            plp
                        
89b7 : 9a                       txs
89b8 : 08                       php
89b9 : ad0001                   lda $100
                                cmp_flag 0
89bc : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89be : d0fe            >        bne *         ;failed not equal (non zero)
                        
89c0 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
89c1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
89c3 : 48              >            pha         ;use stack to load status
89c4 : 28              >            plp
                        
89c5 : 9a                       txs
89c6 : 08                       php
89c7 : adff01                   lda $1ff
                                cmp_flag $ff
89ca : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89cc : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
89ce : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
89d0 : 48              >            pha         ;use stack to load status
89d1 : 28              >            plp
                        
89d2 : 9a                       txs
89d3 : 08                       php
89d4 : adff01                   lda $1ff
                                cmp_flag 0
89d7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
89d9 : a201                     ldx #1
89db : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
89dc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
89de : 48              >            pha         ;use stack to load status
89df : 28              >            plp
                        
89e0 : ba                       tsx             ;clears Z, N
89e1 : 08                       php             ;sp=00
89e2 : e001                     cpx #1
                                trap_ne
89e4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
89e6 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
89e9 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89eb : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
89ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
89ef : 48              >            pha         ;use stack to load status
89f0 : 28              >            plp
                        
89f1 : ba                       tsx             ;clears N, sets Z
89f2 : 08                       php             ;sp=ff
89f3 : e000                     cpx #0
                                trap_ne
89f5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
89f7 : ad0001                   lda $100
                                cmp_flag $ff-minus
89fa : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
89fc : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
89fe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8a00 : 48              >            pha         ;use stack to load status
8a01 : 28              >            plp
                        
8a02 : ba                       tsx             ;clears N, sets Z
8a03 : 08                       php             ;sp=fe
8a04 : e0ff                     cpx #$ff
                                trap_ne
8a06 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a08 : adff01                   lda $1ff
                                cmp_flag $ff-zero
8a0b : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a0d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
8a0f : a201                     ldx #1
8a11 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
8a12 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a14 : 48              >            pha         ;use stack to load status
8a15 : 28              >            plp
                        
8a16 : ba                       tsx             ;clears Z, N
8a17 : 08                       php             ;sp=00
8a18 : e001                     cpx #1
                                trap_ne
8a1a : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a1c : ad0101                   lda $101
                                cmp_flag 0
8a1f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a21 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8a23 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a25 : 48              >            pha         ;use stack to load status
8a26 : 28              >            plp
                        
8a27 : ba                       tsx             ;clears N, sets Z
8a28 : 08                       php             ;sp=ff
8a29 : e000                     cpx #0
                                trap_ne
8a2b : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a2d : ad0001                   lda $100
                                cmp_flag zero
8a30 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a32 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8a34 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a36 : 48              >            pha         ;use stack to load status
8a37 : 28              >            plp
                        
8a38 : ba                       tsx             ;clears N, sets Z
8a39 : 08                       php             ;sp=fe
8a3a : e0ff                     cpx #$ff
                                trap_ne
8a3c : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a3e : adff01                   lda $1ff
                                cmp_flag minus
8a41 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
8a43 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a45 : 68                       pla             ;sp=ff
                                next_test
8a46 : ad0002          >            lda test_case   ;previous test
8a49 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8a4b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
8a4d : a90f            >            lda #test_num   ;*** next tests' number
8a4f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
8a52 : a003                     ldy #3
8a54 :                  tldx    
                                set_stat 0
                       >            load_flag 0
8a54 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a56 : 48              >            pha         ;use stack to load status
8a57 : 28              >            plp
                        
8a58 : b60b                     ldx zp1,y
8a5a : 08                       php         ;test stores do not alter flags
8a5b : 8a                       txa
8a5c : 49c3                     eor #$c3
8a5e : 28                       plp
8a5f : 990302                   sta abst,y
8a62 : 08                       php         ;flags after load/store sequence
8a63 : 49c3                     eor #$c3
8a65 : d91802                   cmp abs1,y  ;test result
                                trap_ne
8a68 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a6a : 68                       pla         ;load status
                                eor_flag 0
8a6b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8a6d : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
8a70 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a72 : 88                       dey
8a73 : 10df                     bpl tldx                  
                        
8a75 : a003                     ldy #3
8a77 :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
8a77 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8a79 : 48              >            pha         ;use stack to load status
8a7a : 28              >            plp
                        
8a7b : b60b                     ldx zp1,y
8a7d : 08                       php         ;test stores do not alter flags
8a7e : 8a                       txa
8a7f : 49c3                     eor #$c3
8a81 : 28                       plp
8a82 : 990302                   sta abst,y
8a85 : 08                       php         ;flags after load/store sequence
8a86 : 49c3                     eor #$c3
8a88 : d91802                   cmp abs1,y  ;test result
                                trap_ne
8a8b : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a8d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8a8e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8a90 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
8a93 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8a95 : 88                       dey
8a96 : 10df                     bpl tldx1                  
                        
8a98 : a003                     ldy #3
8a9a :                  tldx2   
                                set_stat 0
                       >            load_flag 0
8a9a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8a9c : 48              >            pha         ;use stack to load status
8a9d : 28              >            plp
                        
8a9e : be1802                   ldx abs1,y
8aa1 : 08                       php         ;test stores do not alter flags
8aa2 : 8a                       txa
8aa3 : 49c3                     eor #$c3
8aa5 : aa                       tax
8aa6 : 28                       plp
8aa7 : 9602                     stx zpt,y
8aa9 : 08                       php         ;flags after load/store sequence
8aaa : 49c3                     eor #$c3
8aac : d90b00                   cmp zp1,y   ;test result
                                trap_ne
8aaf : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ab1 : 68                       pla         ;load status
                                eor_flag 0
8ab2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8ab4 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
8ab7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ab9 : 88                       dey
8aba : 10de                     bpl tldx2                  
                        
8abc : a003                     ldy #3
8abe :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
8abe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8ac0 : 48              >            pha         ;use stack to load status
8ac1 : 28              >            plp
                        
8ac2 : be1802                   ldx abs1,y
8ac5 : 08                       php         ;test stores do not alter flags
8ac6 : 8a                       txa
8ac7 : 49c3                     eor #$c3
8ac9 : aa                       tax
8aca : 28                       plp
8acb : 9602                     stx zpt,y
8acd : 08                       php         ;flags after load/store sequence
8ace : 49c3                     eor #$c3
8ad0 : d90b00                   cmp zp1,y   ;test result
                                trap_ne
8ad3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ad5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8ad6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8ad8 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
8adb : d0fe            >        bne *         ;failed not equal (non zero)
                        
8add : 88                       dey
8ade : 10de                     bpl tldx3
                                
8ae0 : a003                     ldy #3      ;testing store result
8ae2 : a200                     ldx #0
8ae4 : b90200           tstx    lda zpt,y
8ae7 : 49c3                     eor #$c3
8ae9 : d90b00                   cmp zp1,y
                                trap_ne     ;store to zp data
8aec : d0fe            >        bne *         ;failed not equal (non zero)
                        
8aee : 9602                     stx zpt,y   ;clear                
8af0 : b90302                   lda abst,y
8af3 : 49c3                     eor #$c3
8af5 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
8af8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8afa : 8a                       txa
8afb : 990302                   sta abst,y  ;clear                
8afe : 88                       dey
8aff : 10e3                     bpl tstx
                                next_test
8b01 : ad0002          >            lda test_case   ;previous test
8b04 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8b06 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
8b08 : a910            >            lda #test_num   ;*** next tests' number
8b0a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
8b0d : a0fd                     ldy #3+$fa
8b0f : b611             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
8b11 : 8a                       txa
8b12 : 990901                   sta abst-$fa,y      ;no STX abs,y!
8b15 : 88                       dey
8b16 : c0fa                     cpy #$fa
8b18 : b0f5                     bcs tldx4                  
8b1a : a0fd                     ldy #3+$fa
8b1c : be1e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
8b1f : 9608                     stx zpt-$fa&$ff,y
8b21 : 88                       dey
8b22 : c0fa                     cpy #$fa
8b24 : b0f6                     bcs tldx5                  
8b26 : a003                     ldy #3      ;testing wraparound result
8b28 : a200                     ldx #0
8b2a : b90200           tstx1   lda zpt,y
8b2d : d90b00                   cmp zp1,y
                                trap_ne     ;store to zp data
8b30 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b32 : 9602                     stx zpt,y   ;clear                
8b34 : b90302                   lda abst,y
8b37 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
8b3a : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b3c : 8a                       txa
8b3d : 990302                   sta abst,y  ;clear                
8b40 : 88                       dey
8b41 : 10e7                     bpl tstx1
                                next_test
8b43 : ad0002          >            lda test_case   ;previous test
8b46 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8b48 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
8b4a : a911            >            lda #test_num   ;*** next tests' number
8b4c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
8b4f : a203                     ldx #3
8b51 :                  tldy    
                                set_stat 0
                       >            load_flag 0
8b51 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8b53 : 48              >            pha         ;use stack to load status
8b54 : 28              >            plp
                        
8b55 : b40b                     ldy zp1,x
8b57 : 08                       php         ;test stores do not alter flags
8b58 : 98                       tya
8b59 : 49c3                     eor #$c3
8b5b : 28                       plp
8b5c : 9d0302                   sta abst,x
8b5f : 08                       php         ;flags after load/store sequence
8b60 : 49c3                     eor #$c3
8b62 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
8b65 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b67 : 68                       pla         ;load status
                                eor_flag 0
8b68 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8b6a : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
8b6d : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b6f : ca                       dex
8b70 : 10df                     bpl tldy                  
                        
8b72 : a203                     ldx #3
8b74 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
8b74 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8b76 : 48              >            pha         ;use stack to load status
8b77 : 28              >            plp
                        
8b78 : b40b                     ldy zp1,x
8b7a : 08                       php         ;test stores do not alter flags
8b7b : 98                       tya
8b7c : 49c3                     eor #$c3
8b7e : 28                       plp
8b7f : 9d0302                   sta abst,x
8b82 : 08                       php         ;flags after load/store sequence
8b83 : 49c3                     eor #$c3
8b85 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
8b88 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b8a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8b8b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8b8d : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
8b90 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8b92 : ca                       dex
8b93 : 10df                     bpl tldy1                  
                        
8b95 : a203                     ldx #3
8b97 :                  tldy2   
                                set_stat 0
                       >            load_flag 0
8b97 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8b99 : 48              >            pha         ;use stack to load status
8b9a : 28              >            plp
                        
8b9b : bc1802                   ldy abs1,x
8b9e : 08                       php         ;test stores do not alter flags
8b9f : 98                       tya
8ba0 : 49c3                     eor #$c3
8ba2 : a8                       tay
8ba3 : 28                       plp
8ba4 : 9402                     sty zpt,x
8ba6 : 08                       php         ;flags after load/store sequence
8ba7 : 49c3                     eor #$c3
8ba9 : d50b                     cmp zp1,x   ;test result
                                trap_ne
8bab : d0fe            >        bne *         ;failed not equal (non zero)
                        
8bad : 68                       pla         ;load status
                                eor_flag 0
8bae : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8bb0 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
8bb3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8bb5 : ca                       dex
8bb6 : 10df                     bpl tldy2                  
                        
8bb8 : a203                     ldx #3
8bba :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
8bba : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8bbc : 48              >            pha         ;use stack to load status
8bbd : 28              >            plp
                        
8bbe : bc1802                   ldy abs1,x
8bc1 : 08                       php         ;test stores do not alter flags
8bc2 : 98                       tya
8bc3 : 49c3                     eor #$c3
8bc5 : a8                       tay
8bc6 : 28                       plp
8bc7 : 9402                     sty zpt,x
8bc9 : 08                       php         ;flags after load/store sequence
8bca : 49c3                     eor #$c3
8bcc : d50b                     cmp zp1,x   ;test result
                                trap_ne
8bce : d0fe            >        bne *         ;failed not equal (non zero)
                        
8bd0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8bd1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8bd3 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
8bd6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8bd8 : ca                       dex
8bd9 : 10df                     bpl tldy3
                        
8bdb : a203                     ldx #3      ;testing store result
8bdd : a000                     ldy #0
8bdf : b502             tsty    lda zpt,x
8be1 : 49c3                     eor #$c3
8be3 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
8be5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8be7 : 9402                     sty zpt,x   ;clear                
8be9 : bd0302                   lda abst,x
8bec : 49c3                     eor #$c3
8bee : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
8bf1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8bf3 : 8a                       txa
8bf4 : 9d0302                   sta abst,x  ;clear                
8bf7 : ca                       dex
8bf8 : 10e5                     bpl tsty
                                next_test
8bfa : ad0002          >            lda test_case   ;previous test
8bfd : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8bff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
8c01 : a912            >            lda #test_num   ;*** next tests' number
8c03 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
8c06 : a2fd                     ldx #3+$fa
8c08 : b411             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
8c0a : 98                       tya
8c0b : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
8c0e : ca                       dex
8c0f : e0fa                     cpx #$fa
8c11 : b0f5                     bcs tldy4                  
8c13 : a2fd                     ldx #3+$fa
8c15 : bc1e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
8c18 : 9408                     sty zpt-$fa&$ff,x
8c1a : ca                       dex
8c1b : e0fa                     cpx #$fa
8c1d : b0f6                     bcs tldy5                  
8c1f : a203                     ldx #3      ;testing wraparound result
8c21 : a000                     ldy #0
8c23 : b502             tsty1   lda zpt,x
8c25 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
8c27 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c29 : 9402                     sty zpt,x   ;clear                
8c2b : bd0302                   lda abst,x
8c2e : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
8c31 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c33 : 8a                       txa
8c34 : 9d0302                   sta abst,x  ;clear                
8c37 : ca                       dex
8c38 : 10e9                     bpl tsty1
                                next_test
8c3a : ad0002          >            lda test_case   ;previous test
8c3d : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8c3f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
8c41 : a913            >            lda #test_num   ;*** next tests' number
8c43 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
8c46 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
8c48 : 48              >            pha         ;use stack to load status
8c49 : 28              >            plp
                        
8c4a : a60b                     ldx zp1
8c4c : 08                       php         ;test stores do not alter flags
8c4d : 8a                       txa
8c4e : 49c3                     eor #$c3
8c50 : aa                       tax
8c51 : 28                       plp
8c52 : 8e0302                   stx abst
8c55 : 08                       php         ;flags after load/store sequence
8c56 : 49c3                     eor #$c3
8c58 : aa                       tax
8c59 : e0c3                     cpx #$c3    ;test result
                                trap_ne
8c5b : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c5d : 68                       pla         ;load status
                                eor_flag 0
8c5e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8c60 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8c63 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8c65 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8c67 : 48              >            pha         ;use stack to load status
8c68 : 28              >            plp
                        
8c69 : a60c                     ldx zp1+1
8c6b : 08                       php         ;test stores do not alter flags
8c6c : 8a                       txa
8c6d : 49c3                     eor #$c3
8c6f : aa                       tax
8c70 : 28                       plp
8c71 : 8e0402                   stx abst+1
8c74 : 08                       php         ;flags after load/store sequence
8c75 : 49c3                     eor #$c3
8c77 : aa                       tax
8c78 : e082                     cpx #$82    ;test result
                                trap_ne
8c7a : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c7c : 68                       pla         ;load status
                                eor_flag 0
8c7d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8c7f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8c82 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8c84 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8c86 : 48              >            pha         ;use stack to load status
8c87 : 28              >            plp
                        
8c88 : a60d                     ldx zp1+2
8c8a : 08                       php         ;test stores do not alter flags
8c8b : 8a                       txa
8c8c : 49c3                     eor #$c3
8c8e : aa                       tax
8c8f : 28                       plp
8c90 : 8e0502                   stx abst+2
8c93 : 08                       php         ;flags after load/store sequence
8c94 : 49c3                     eor #$c3
8c96 : aa                       tax
8c97 : e041                     cpx #$41    ;test result
                                trap_ne
8c99 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8c9b : 68                       pla         ;load status
                                eor_flag 0
8c9c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8c9e : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8ca1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8ca3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8ca5 : 48              >            pha         ;use stack to load status
8ca6 : 28              >            plp
                        
8ca7 : a60e                     ldx zp1+3
8ca9 : 08                       php         ;test stores do not alter flags
8caa : 8a                       txa
8cab : 49c3                     eor #$c3
8cad : aa                       tax
8cae : 28                       plp
8caf : 8e0602                   stx abst+3
8cb2 : 08                       php         ;flags after load/store sequence
8cb3 : 49c3                     eor #$c3
8cb5 : aa                       tax
8cb6 : e000                     cpx #0      ;test result
                                trap_ne
8cb8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8cba : 68                       pla         ;load status
                                eor_flag 0
8cbb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8cbd : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8cc0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
8cc2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8cc4 : 48              >            pha         ;use stack to load status
8cc5 : 28              >            plp
                        
8cc6 : a60b                     ldx zp1  
8cc8 : 08                       php         ;test stores do not alter flags
8cc9 : 8a                       txa
8cca : 49c3                     eor #$c3
8ccc : aa                       tax
8ccd : 28                       plp
8cce : 8e0302                   stx abst  
8cd1 : 08                       php         ;flags after load/store sequence
8cd2 : 49c3                     eor #$c3
8cd4 : aa                       tax
8cd5 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
8cd7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8cd9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8cda : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8cdc : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8cdf : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8ce1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8ce3 : 48              >            pha         ;use stack to load status
8ce4 : 28              >            plp
                        
8ce5 : a60c                     ldx zp1+1
8ce7 : 08                       php         ;test stores do not alter flags
8ce8 : 8a                       txa
8ce9 : 49c3                     eor #$c3
8ceb : aa                       tax
8cec : 28                       plp
8ced : 8e0402                   stx abst+1
8cf0 : 08                       php         ;flags after load/store sequence
8cf1 : 49c3                     eor #$c3
8cf3 : aa                       tax
8cf4 : e082                     cpx #$82    ;test result
                                trap_ne
8cf6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8cf8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8cf9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8cfb : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8cfe : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8d00 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8d02 : 48              >            pha         ;use stack to load status
8d03 : 28              >            plp
                        
8d04 : a60d                     ldx zp1+2
8d06 : 08                       php         ;test stores do not alter flags
8d07 : 8a                       txa
8d08 : 49c3                     eor #$c3
8d0a : aa                       tax
8d0b : 28                       plp
8d0c : 8e0502                   stx abst+2
8d0f : 08                       php         ;flags after load/store sequence
8d10 : 49c3                     eor #$c3
8d12 : aa                       tax
8d13 : e041                     cpx #$41    ;test result
                                trap_ne     ;
8d15 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d17 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8d18 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8d1a : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8d1d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8d1f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8d21 : 48              >            pha         ;use stack to load status
8d22 : 28              >            plp
                        
8d23 : a60e                     ldx zp1+3
8d25 : 08                       php         ;test stores do not alter flags
8d26 : 8a                       txa
8d27 : 49c3                     eor #$c3
8d29 : aa                       tax
8d2a : 28                       plp
8d2b : 8e0602                   stx abst+3
8d2e : 08                       php         ;flags after load/store sequence
8d2f : 49c3                     eor #$c3
8d31 : aa                       tax
8d32 : e000                     cpx #0      ;test result
                                trap_ne
8d34 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d36 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8d37 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8d39 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8d3c : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
8d3e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8d40 : 48              >            pha         ;use stack to load status
8d41 : 28              >            plp
                        
8d42 : ae1802                   ldx abs1  
8d45 : 08                       php         ;test stores do not alter flags
8d46 : 8a                       txa
8d47 : 49c3                     eor #$c3
8d49 : aa                       tax
8d4a : 28                       plp
8d4b : 8602                     stx zpt  
8d4d : 08                       php         ;flags after load/store sequence
8d4e : 49c3                     eor #$c3
8d50 : c50b                     cmp zp1     ;test result
                                trap_ne
8d52 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d54 : 68                       pla         ;load status
                                eor_flag 0
8d55 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8d57 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8d5a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8d5c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8d5e : 48              >            pha         ;use stack to load status
8d5f : 28              >            plp
                        
8d60 : ae1902                   ldx abs1+1
8d63 : 08                       php         ;test stores do not alter flags
8d64 : 8a                       txa
8d65 : 49c3                     eor #$c3
8d67 : aa                       tax
8d68 : 28                       plp
8d69 : 8603                     stx zpt+1
8d6b : 08                       php         ;flags after load/store sequence
8d6c : 49c3                     eor #$c3
8d6e : c50c                     cmp zp1+1   ;test result
                                trap_ne
8d70 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d72 : 68                       pla         ;load status
                                eor_flag 0
8d73 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8d75 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8d78 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8d7a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8d7c : 48              >            pha         ;use stack to load status
8d7d : 28              >            plp
                        
8d7e : ae1a02                   ldx abs1+2
8d81 : 08                       php         ;test stores do not alter flags
8d82 : 8a                       txa
8d83 : 49c3                     eor #$c3
8d85 : aa                       tax
8d86 : 28                       plp
8d87 : 8604                     stx zpt+2
8d89 : 08                       php         ;flags after load/store sequence
8d8a : 49c3                     eor #$c3
8d8c : c50d                     cmp zp1+2   ;test result
                                trap_ne
8d8e : d0fe            >        bne *         ;failed not equal (non zero)
                        
8d90 : 68                       pla         ;load status
                                eor_flag 0
8d91 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8d93 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8d96 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8d98 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8d9a : 48              >            pha         ;use stack to load status
8d9b : 28              >            plp
                        
8d9c : ae1b02                   ldx abs1+3
8d9f : 08                       php         ;test stores do not alter flags
8da0 : 8a                       txa
8da1 : 49c3                     eor #$c3
8da3 : aa                       tax
8da4 : 28                       plp
8da5 : 8605                     stx zpt+3
8da7 : 08                       php         ;flags after load/store sequence
8da8 : 49c3                     eor #$c3
8daa : c50e                     cmp zp1+3   ;test result
                                trap_ne
8dac : d0fe            >        bne *         ;failed not equal (non zero)
                        
8dae : 68                       pla         ;load status
                                eor_flag 0
8daf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8db1 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8db4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
8db6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8db8 : 48              >            pha         ;use stack to load status
8db9 : 28              >            plp
                        
8dba : ae1802                   ldx abs1  
8dbd : 08                       php         ;test stores do not alter flags
8dbe : 8a                       txa
8dbf : 49c3                     eor #$c3
8dc1 : aa                       tax
8dc2 : 28                       plp
8dc3 : 8602                     stx zpt  
8dc5 : 08                       php         ;flags after load/store sequence
8dc6 : 49c3                     eor #$c3
8dc8 : aa                       tax
8dc9 : e40b                     cpx zp1     ;test result
                                trap_ne
8dcb : d0fe            >        bne *         ;failed not equal (non zero)
                        
8dcd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8dce : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8dd0 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8dd3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8dd5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8dd7 : 48              >            pha         ;use stack to load status
8dd8 : 28              >            plp
                        
8dd9 : ae1902                   ldx abs1+1
8ddc : 08                       php         ;test stores do not alter flags
8ddd : 8a                       txa
8dde : 49c3                     eor #$c3
8de0 : aa                       tax
8de1 : 28                       plp
8de2 : 8603                     stx zpt+1
8de4 : 08                       php         ;flags after load/store sequence
8de5 : 49c3                     eor #$c3
8de7 : aa                       tax
8de8 : e40c                     cpx zp1+1   ;test result
                                trap_ne
8dea : d0fe            >        bne *         ;failed not equal (non zero)
                        
8dec : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8ded : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8def : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8df2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8df4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8df6 : 48              >            pha         ;use stack to load status
8df7 : 28              >            plp
                        
8df8 : ae1a02                   ldx abs1+2
8dfb : 08                       php         ;test stores do not alter flags
8dfc : 8a                       txa
8dfd : 49c3                     eor #$c3
8dff : aa                       tax
8e00 : 28                       plp
8e01 : 8604                     stx zpt+2
8e03 : 08                       php         ;flags after load/store sequence
8e04 : 49c3                     eor #$c3
8e06 : aa                       tax
8e07 : e40d                     cpx zp1+2   ;test result
                                trap_ne
8e09 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e0b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8e0c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8e0e : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8e11 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8e13 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8e15 : 48              >            pha         ;use stack to load status
8e16 : 28              >            plp
                        
8e17 : ae1b02                   ldx abs1+3
8e1a : 08                       php         ;test stores do not alter flags
8e1b : 8a                       txa
8e1c : 49c3                     eor #$c3
8e1e : aa                       tax
8e1f : 28                       plp
8e20 : 8605                     stx zpt+3
8e22 : 08                       php         ;flags after load/store sequence
8e23 : 49c3                     eor #$c3
8e25 : aa                       tax
8e26 : e40e                     cpx zp1+3   ;test result
                                trap_ne
8e28 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e2a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8e2b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8e2d : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8e30 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
8e32 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
8e34 : 48              >            pha         ;use stack to load status
8e35 : 28              >            plp
                        
8e36 : a2c3                     ldx #$c3
8e38 : 08                       php
8e39 : ec1802                   cpx abs1    ;test result
                                trap_ne
8e3c : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e3e : 68                       pla         ;load status
                                eor_flag 0
8e3f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8e41 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8e44 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8e46 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8e48 : 48              >            pha         ;use stack to load status
8e49 : 28              >            plp
                        
8e4a : a282                     ldx #$82
8e4c : 08                       php
8e4d : ec1902                   cpx abs1+1  ;test result
                                trap_ne
8e50 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e52 : 68                       pla         ;load status
                                eor_flag 0
8e53 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8e55 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8e58 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8e5a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8e5c : 48              >            pha         ;use stack to load status
8e5d : 28              >            plp
                        
8e5e : a241                     ldx #$41
8e60 : 08                       php
8e61 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
8e64 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e66 : 68                       pla         ;load status
                                eor_flag 0
8e67 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8e69 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8e6c : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8e6e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8e70 : 48              >            pha         ;use stack to load status
8e71 : 28              >            plp
                        
8e72 : a200                     ldx #0
8e74 : 08                       php
8e75 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
8e78 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e7a : 68                       pla         ;load status
                                eor_flag 0
8e7b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8e7d : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8e80 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
8e82 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8e84 : 48              >            pha         ;use stack to load status
8e85 : 28              >            plp
                        
8e86 : a2c3                     ldx #$c3  
8e88 : 08                       php
8e89 : ec1802                   cpx abs1    ;test result
                                trap_ne
8e8c : d0fe            >        bne *         ;failed not equal (non zero)
                        
8e8e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8e8f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8e91 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8e94 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8e96 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8e98 : 48              >            pha         ;use stack to load status
8e99 : 28              >            plp
                        
8e9a : a282                     ldx #$82
8e9c : 08                       php
8e9d : ec1902                   cpx abs1+1  ;test result
                                trap_ne
8ea0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ea2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8ea3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8ea5 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8ea8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8eaa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8eac : 48              >            pha         ;use stack to load status
8ead : 28              >            plp
                        
8eae : a241                     ldx #$41
8eb0 : 08                       php
8eb1 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
8eb4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8eb6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8eb7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8eb9 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8ebc : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8ebe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8ec0 : 48              >            pha         ;use stack to load status
8ec1 : 28              >            plp
                        
8ec2 : a200                     ldx #0
8ec4 : 08                       php
8ec5 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
8ec8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8eca : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8ecb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8ecd : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8ed0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
8ed2 : a200                     ldx #0
8ed4 : a502                     lda zpt  
8ed6 : 49c3                     eor #$c3
8ed8 : c50b                     cmp zp1  
                                trap_ne     ;store to zp data
8eda : d0fe            >        bne *         ;failed not equal (non zero)
                        
8edc : 8602                     stx zpt     ;clear                
8ede : ad0302                   lda abst  
8ee1 : 49c3                     eor #$c3
8ee3 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
8ee6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ee8 : 8e0302                   stx abst    ;clear                
8eeb : a503                     lda zpt+1
8eed : 49c3                     eor #$c3
8eef : c50c                     cmp zp1+1
                                trap_ne     ;store to zp data
8ef1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8ef3 : 8603                     stx zpt+1   ;clear                
8ef5 : ad0402                   lda abst+1
8ef8 : 49c3                     eor #$c3
8efa : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
8efd : d0fe            >        bne *         ;failed not equal (non zero)
                        
8eff : 8e0402                   stx abst+1  ;clear                
8f02 : a504                     lda zpt+2
8f04 : 49c3                     eor #$c3
8f06 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp data
8f08 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f0a : 8604                     stx zpt+2   ;clear                
8f0c : ad0502                   lda abst+2
8f0f : 49c3                     eor #$c3
8f11 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
8f14 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f16 : 8e0502                   stx abst+2  ;clear                
8f19 : a505                     lda zpt+3
8f1b : 49c3                     eor #$c3
8f1d : c50e                     cmp zp1+3
                                trap_ne     ;store to zp data
8f1f : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f21 : 8605                     stx zpt+3   ;clear                
8f23 : ad0602                   lda abst+3
8f26 : 49c3                     eor #$c3
8f28 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
8f2b : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f2d : 8e0602                   stx abst+3  ;clear                
                                next_test
8f30 : ad0002          >            lda test_case   ;previous test
8f33 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
8f35 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
8f37 : a914            >            lda #test_num   ;*** next tests' number
8f39 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
8f3c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8f3e : 48              >            pha         ;use stack to load status
8f3f : 28              >            plp
                        
8f40 : a40b                     ldy zp1  
8f42 : 08                       php         ;test stores do not alter flags
8f43 : 98                       tya
8f44 : 49c3                     eor #$c3
8f46 : a8                       tay
8f47 : 28                       plp
8f48 : 8c0302                   sty abst  
8f4b : 08                       php         ;flags after load/store sequence
8f4c : 49c3                     eor #$c3
8f4e : a8                       tay
8f4f : c0c3                     cpy #$c3    ;test result
                                trap_ne
8f51 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f53 : 68                       pla         ;load status
                                eor_flag 0
8f54 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8f56 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8f59 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8f5b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8f5d : 48              >            pha         ;use stack to load status
8f5e : 28              >            plp
                        
8f5f : a40c                     ldy zp1+1
8f61 : 08                       php         ;test stores do not alter flags
8f62 : 98                       tya
8f63 : 49c3                     eor #$c3
8f65 : a8                       tay
8f66 : 28                       plp
8f67 : 8c0402                   sty abst+1
8f6a : 08                       php         ;flags after load/store sequence
8f6b : 49c3                     eor #$c3
8f6d : a8                       tay
8f6e : c082                     cpy #$82    ;test result
                                trap_ne
8f70 : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f72 : 68                       pla         ;load status
                                eor_flag 0
8f73 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8f75 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8f78 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8f7a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8f7c : 48              >            pha         ;use stack to load status
8f7d : 28              >            plp
                        
8f7e : a40d                     ldy zp1+2
8f80 : 08                       php         ;test stores do not alter flags
8f81 : 98                       tya
8f82 : 49c3                     eor #$c3
8f84 : a8                       tay
8f85 : 28                       plp
8f86 : 8c0502                   sty abst+2
8f89 : 08                       php         ;flags after load/store sequence
8f8a : 49c3                     eor #$c3
8f8c : a8                       tay
8f8d : c041                     cpy #$41    ;test result
                                trap_ne
8f8f : d0fe            >        bne *         ;failed not equal (non zero)
                        
8f91 : 68                       pla         ;load status
                                eor_flag 0
8f92 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8f94 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
8f97 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
8f99 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
8f9b : 48              >            pha         ;use stack to load status
8f9c : 28              >            plp
                        
8f9d : a40e                     ldy zp1+3
8f9f : 08                       php         ;test stores do not alter flags
8fa0 : 98                       tya
8fa1 : 49c3                     eor #$c3
8fa3 : a8                       tay
8fa4 : 28                       plp
8fa5 : 8c0602                   sty abst+3
8fa8 : 08                       php         ;flags after load/store sequence
8fa9 : 49c3                     eor #$c3
8fab : a8                       tay
8fac : c000                     cpy #0      ;test result
                                trap_ne
8fae : d0fe            >        bne *         ;failed not equal (non zero)
                        
8fb0 : 68                       pla         ;load status
                                eor_flag 0
8fb1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
8fb3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
8fb6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
8fb8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8fba : 48              >            pha         ;use stack to load status
8fbb : 28              >            plp
                        
8fbc : a40b                     ldy zp1  
8fbe : 08                       php         ;test stores do not alter flags
8fbf : 98                       tya
8fc0 : 49c3                     eor #$c3
8fc2 : a8                       tay
8fc3 : 28                       plp
8fc4 : 8c0302                   sty abst  
8fc7 : 08                       php         ;flags after load/store sequence
8fc8 : 49c3                     eor #$c3
8fca : a8                       tay
8fcb : c0c3                     cpy #$c3    ;test result
                                trap_ne
8fcd : d0fe            >        bne *         ;failed not equal (non zero)
                        
8fcf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8fd0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8fd2 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
8fd5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8fd7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8fd9 : 48              >            pha         ;use stack to load status
8fda : 28              >            plp
                        
8fdb : a40c                     ldy zp1+1
8fdd : 08                       php         ;test stores do not alter flags
8fde : 98                       tya
8fdf : 49c3                     eor #$c3
8fe1 : a8                       tay
8fe2 : 28                       plp
8fe3 : 8c0402                   sty abst+1
8fe6 : 08                       php         ;flags after load/store sequence
8fe7 : 49c3                     eor #$c3
8fe9 : a8                       tay
8fea : c082                     cpy #$82   ;test result
                                trap_ne
8fec : d0fe            >        bne *         ;failed not equal (non zero)
                        
8fee : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
8fef : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
8ff1 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
8ff4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
8ff6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
8ff8 : 48              >            pha         ;use stack to load status
8ff9 : 28              >            plp
                        
8ffa : a40d                     ldy zp1+2
8ffc : 08                       php         ;test stores do not alter flags
8ffd : 98                       tya
8ffe : 49c3                     eor #$c3
9000 : a8                       tay
9001 : 28                       plp
9002 : 8c0502                   sty abst+2
9005 : 08                       php         ;flags after load/store sequence
9006 : 49c3                     eor #$c3
9008 : a8                       tay
9009 : c041                     cpy #$41    ;test result
                                trap_ne
900b : d0fe            >        bne *         ;failed not equal (non zero)
                        
900d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
900e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9010 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
9013 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9015 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9017 : 48              >            pha         ;use stack to load status
9018 : 28              >            plp
                        
9019 : a40e                     ldy zp1+3
901b : 08                       php         ;test stores do not alter flags
901c : 98                       tya
901d : 49c3                     eor #$c3
901f : a8                       tay
9020 : 28                       plp
9021 : 8c0602                   sty abst+3
9024 : 08                       php         ;flags after load/store sequence
9025 : 49c3                     eor #$c3
9027 : a8                       tay
9028 : c000                     cpy #0      ;test result
                                trap_ne
902a : d0fe            >        bne *         ;failed not equal (non zero)
                        
902c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
902d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
902f : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9032 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
9034 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9036 : 48              >            pha         ;use stack to load status
9037 : 28              >            plp
                        
9038 : ac1802                   ldy abs1  
903b : 08                       php         ;test stores do not alter flags
903c : 98                       tya
903d : 49c3                     eor #$c3
903f : a8                       tay
9040 : 28                       plp
9041 : 8402                     sty zpt  
9043 : 08                       php         ;flags after load/store sequence
9044 : 49c3                     eor #$c3
9046 : a8                       tay
9047 : c40b                     cpy zp1     ;test result
                                trap_ne
9049 : d0fe            >        bne *         ;failed not equal (non zero)
                        
904b : 68                       pla         ;load status
                                eor_flag 0
904c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
904e : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
9051 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9053 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9055 : 48              >            pha         ;use stack to load status
9056 : 28              >            plp
                        
9057 : ac1902                   ldy abs1+1
905a : 08                       php         ;test stores do not alter flags
905b : 98                       tya
905c : 49c3                     eor #$c3
905e : a8                       tay
905f : 28                       plp
9060 : 8403                     sty zpt+1
9062 : 08                       php         ;flags after load/store sequence
9063 : 49c3                     eor #$c3
9065 : a8                       tay
9066 : c40c                     cpy zp1+1   ;test result
                                trap_ne
9068 : d0fe            >        bne *         ;failed not equal (non zero)
                        
906a : 68                       pla         ;load status
                                eor_flag 0
906b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
906d : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
9070 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9072 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9074 : 48              >            pha         ;use stack to load status
9075 : 28              >            plp
                        
9076 : ac1a02                   ldy abs1+2
9079 : 08                       php         ;test stores do not alter flags
907a : 98                       tya
907b : 49c3                     eor #$c3
907d : a8                       tay
907e : 28                       plp
907f : 8404                     sty zpt+2
9081 : 08                       php         ;flags after load/store sequence
9082 : 49c3                     eor #$c3
9084 : a8                       tay
9085 : c40d                     cpy zp1+2   ;test result
                                trap_ne
9087 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9089 : 68                       pla         ;load status
                                eor_flag 0
908a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
908c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
908f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9091 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9093 : 48              >            pha         ;use stack to load status
9094 : 28              >            plp
                        
9095 : ac1b02                   ldy abs1+3
9098 : 08                       php         ;test stores do not alter flags
9099 : 98                       tya
909a : 49c3                     eor #$c3
909c : a8                       tay
909d : 28                       plp
909e : 8405                     sty zpt+3
90a0 : 08                       php         ;flags after load/store sequence
90a1 : 49c3                     eor #$c3
90a3 : a8                       tay
90a4 : c40e                     cpy zp1+3   ;test result
                                trap_ne
90a6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
90a8 : 68                       pla         ;load status
                                eor_flag 0
90a9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
90ab : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
90ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
90b0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
90b2 : 48              >            pha         ;use stack to load status
90b3 : 28              >            plp
                        
90b4 : ac1802                   ldy abs1  
90b7 : 08                       php         ;test stores do not alter flags
90b8 : 98                       tya
90b9 : 49c3                     eor #$c3
90bb : a8                       tay
90bc : 28                       plp
90bd : 8402                     sty zpt  
90bf : 08                       php         ;flags after load/store sequence
90c0 : 49c3                     eor #$c3
90c2 : a8                       tay
90c3 : c50b                     cmp zp1     ;test result
                                trap_ne
90c5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
90c7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
90c8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
90ca : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
90cd : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
90cf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
90d1 : 48              >            pha         ;use stack to load status
90d2 : 28              >            plp
                        
90d3 : ac1902                   ldy abs1+1
90d6 : 08                       php         ;test stores do not alter flags
90d7 : 98                       tya
90d8 : 49c3                     eor #$c3
90da : a8                       tay
90db : 28                       plp
90dc : 8403                     sty zpt+1
90de : 08                       php         ;flags after load/store sequence
90df : 49c3                     eor #$c3
90e1 : a8                       tay
90e2 : c50c                     cmp zp1+1   ;test result
                                trap_ne
90e4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
90e6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
90e7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
90e9 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
90ec : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
90ee : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
90f0 : 48              >            pha         ;use stack to load status
90f1 : 28              >            plp
                        
90f2 : ac1a02                   ldy abs1+2
90f5 : 08                       php         ;test stores do not alter flags
90f6 : 98                       tya
90f7 : 49c3                     eor #$c3
90f9 : a8                       tay
90fa : 28                       plp
90fb : 8404                     sty zpt+2
90fd : 08                       php         ;flags after load/store sequence
90fe : 49c3                     eor #$c3
9100 : a8                       tay
9101 : c50d                     cmp zp1+2   ;test result
                                trap_ne
9103 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9105 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9106 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9108 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
910b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
910d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
910f : 48              >            pha         ;use stack to load status
9110 : 28              >            plp
                        
9111 : ac1b02                   ldy abs1+3
9114 : 08                       php         ;test stores do not alter flags
9115 : 98                       tya
9116 : 49c3                     eor #$c3
9118 : a8                       tay
9119 : 28                       plp
911a : 8405                     sty zpt+3
911c : 08                       php         ;flags after load/store sequence
911d : 49c3                     eor #$c3
911f : a8                       tay
9120 : c50e                     cmp zp1+3   ;test result
                                trap_ne
9122 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9124 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9125 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9127 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
912a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
912c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
912e : 48              >            pha         ;use stack to load status
912f : 28              >            plp
                        
9130 : a0c3                     ldy #$c3  
9132 : 08                       php
9133 : cc1802                   cpy abs1    ;test result
                                trap_ne
9136 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9138 : 68                       pla         ;load status
                                eor_flag 0
9139 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
913b : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
913e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9140 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9142 : 48              >            pha         ;use stack to load status
9143 : 28              >            plp
                        
9144 : a082                     ldy #$82
9146 : 08                       php
9147 : cc1902                   cpy abs1+1  ;test result
                                trap_ne
914a : d0fe            >        bne *         ;failed not equal (non zero)
                        
914c : 68                       pla         ;load status
                                eor_flag 0
914d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
914f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
9152 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9154 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9156 : 48              >            pha         ;use stack to load status
9157 : 28              >            plp
                        
9158 : a041                     ldy #$41
915a : 08                       php
915b : cc1a02                   cpy abs1+2  ;test result
                                trap_ne
915e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9160 : 68                       pla         ;load status
                                eor_flag 0
9161 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9163 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
9166 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9168 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
916a : 48              >            pha         ;use stack to load status
916b : 28              >            plp
                        
916c : a000                     ldy #0
916e : 08                       php
916f : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
9172 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9174 : 68                       pla         ;load status
                                eor_flag 0
9175 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9177 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
917a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
917c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
917e : 48              >            pha         ;use stack to load status
917f : 28              >            plp
                        
9180 : a0c3                     ldy #$c3  
9182 : 08                       php
9183 : cc1802                   cpy abs1    ;test result
                                trap_ne
9186 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9188 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9189 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
918b : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
918e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9190 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9192 : 48              >            pha         ;use stack to load status
9193 : 28              >            plp
                        
9194 : a082                     ldy #$82
9196 : 08                       php
9197 : cc1902                   cpy abs1+1  ;test result
                                trap_ne
919a : d0fe            >        bne *         ;failed not equal (non zero)
                        
919c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
919d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
919f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
91a2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
91a4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
91a6 : 48              >            pha         ;use stack to load status
91a7 : 28              >            plp
                        
91a8 : a041                     ldy #$41
91aa : 08                       php
91ab : cc1a02                   cpy abs1+2   ;test result
                                trap_ne
91ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
91b0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
91b1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
91b3 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
91b6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
91b8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
91ba : 48              >            pha         ;use stack to load status
91bb : 28              >            plp
                        
91bc : a000                     ldy #0
91be : 08                       php
91bf : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
91c2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
91c4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
91c5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
91c7 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
91ca : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
91cc : a000                     ldy #0
91ce : a502                     lda zpt  
91d0 : 49c3                     eor #$c3
91d2 : c50b                     cmp zp1  
                                trap_ne     ;store to zp   data
91d4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
91d6 : 8402                     sty zpt     ;clear                
91d8 : ad0302                   lda abst  
91db : 49c3                     eor #$c3
91dd : cd1802                   cmp abs1  
                                trap_ne     ;store to abs   data
91e0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
91e2 : 8c0302                   sty abst    ;clear                
91e5 : a503                     lda zpt+1
91e7 : 49c3                     eor #$c3
91e9 : c50c                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
91eb : d0fe            >        bne *         ;failed not equal (non zero)
                        
91ed : 8403                     sty zpt+1   ;clear                
91ef : ad0402                   lda abst+1
91f2 : 49c3                     eor #$c3
91f4 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
91f7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
91f9 : 8c0402                   sty abst+1  ;clear                
91fc : a504                     lda zpt+2
91fe : 49c3                     eor #$c3
9200 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
9202 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9204 : 8404                     sty zpt+2   ;clear                
9206 : ad0502                   lda abst+2
9209 : 49c3                     eor #$c3
920b : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
920e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9210 : 8c0502                   sty abst+2  ;clear                
9213 : a505                     lda zpt+3
9215 : 49c3                     eor #$c3
9217 : c50e                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
9219 : d0fe            >        bne *         ;failed not equal (non zero)
                        
921b : 8405                     sty zpt+3   ;clear                
921d : ad0602                   lda abst+3
9220 : 49c3                     eor #$c3
9222 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
9225 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9227 : 8c0602                   sty abst+3  ;clear                
                                next_test
922a : ad0002          >            lda test_case   ;previous test
922d : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
922f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
9231 : a915            >            lda #test_num   ;*** next tests' number
9233 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
9236 : a203                     ldx #3
9238 :                  tldax    
                                set_stat 0
                       >            load_flag 0
9238 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
923a : 48              >            pha         ;use stack to load status
923b : 28              >            plp
                        
923c : b50b                     lda zp1,x
923e : 08                       php         ;test stores do not alter flags
923f : 49c3                     eor #$c3
9241 : 28                       plp
9242 : 9d0302                   sta abst,x
9245 : 08                       php         ;flags after load/store sequence
9246 : 49c3                     eor #$c3
9248 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
924b : d0fe            >        bne *         ;failed not equal (non zero)
                        
924d : 68                       pla         ;load status
                                eor_flag 0
924e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9250 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
9253 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9255 : ca                       dex
9256 : 10e0                     bpl tldax                  
                        
9258 : a203                     ldx #3
925a :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
925a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
925c : 48              >            pha         ;use stack to load status
925d : 28              >            plp
                        
925e : b50b                     lda zp1,x
9260 : 08                       php         ;test stores do not alter flags
9261 : 49c3                     eor #$c3
9263 : 28                       plp
9264 : 9d0302                   sta abst,x
9267 : 08                       php         ;flags after load/store sequence
9268 : 49c3                     eor #$c3
926a : dd1802                   cmp abs1,x   ;test result
                                trap_ne
926d : d0fe            >        bne *         ;failed not equal (non zero)
                        
926f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9270 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9272 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
9275 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9277 : ca                       dex
9278 : 10e0                     bpl tldax1                  
                        
927a : a203                     ldx #3
927c :                  tldax2   
                                set_stat 0
                       >            load_flag 0
927c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
927e : 48              >            pha         ;use stack to load status
927f : 28              >            plp
                        
9280 : bd1802                   lda abs1,x
9283 : 08                       php         ;test stores do not alter flags
9284 : 49c3                     eor #$c3
9286 : 28                       plp
9287 : 9502                     sta zpt,x
9289 : 08                       php         ;flags after load/store sequence
928a : 49c3                     eor #$c3
928c : d50b                     cmp zp1,x   ;test result
                                trap_ne
928e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9290 : 68                       pla         ;load status
                                eor_flag 0
9291 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9293 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
9296 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9298 : ca                       dex
9299 : 10e1                     bpl tldax2                  
                        
929b : a203                     ldx #3
929d :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
929d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
929f : 48              >            pha         ;use stack to load status
92a0 : 28              >            plp
                        
92a1 : bd1802                   lda abs1,x
92a4 : 08                       php         ;test stores do not alter flags
92a5 : 49c3                     eor #$c3
92a7 : 28                       plp
92a8 : 9502                     sta zpt,x
92aa : 08                       php         ;flags after load/store sequence
92ab : 49c3                     eor #$c3
92ad : d50b                     cmp zp1,x   ;test result
                                trap_ne
92af : d0fe            >        bne *         ;failed not equal (non zero)
                        
92b1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
92b2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
92b4 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
92b7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92b9 : ca                       dex
92ba : 10e1                     bpl tldax3
                        
92bc : a203                     ldx #3      ;testing store result
92be : a000                     ldy #0
92c0 : b502             tstax   lda zpt,x
92c2 : 49c3                     eor #$c3
92c4 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
92c6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92c8 : 9402                     sty zpt,x   ;clear                
92ca : bd0302                   lda abst,x
92cd : 49c3                     eor #$c3
92cf : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
92d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
92d4 : 8a                       txa
92d5 : 9d0302                   sta abst,x  ;clear                
92d8 : ca                       dex
92d9 : 10e5                     bpl tstax
                                next_test
92db : ad0002          >            lda test_case   ;previous test
92de : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
92e0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
92e2 : a916            >            lda #test_num   ;*** next tests' number
92e4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
92e7 : a003                     ldy #3
92e9 :                  tlday    
                                set_stat 0
                       >            load_flag 0
92e9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
92eb : 48              >            pha         ;use stack to load status
92ec : 28              >            plp
                        
92ed : b11c                     lda (ind1),y
92ef : 08                       php         ;test stores do not alter flags
92f0 : 49c3                     eor #$c3
92f2 : 28                       plp
92f3 : 990302                   sta abst,y
92f6 : 08                       php         ;flags after load/store sequence
92f7 : 49c3                     eor #$c3
92f9 : d91802                   cmp abs1,y  ;test result
                                trap_ne
92fc : d0fe            >        bne *         ;failed not equal (non zero)
                        
92fe : 68                       pla         ;load status
                                eor_flag 0
92ff : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9301 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
9304 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9306 : 88                       dey
9307 : 10e0                     bpl tlday                  
                        
9309 : a003                     ldy #3
930b :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
930b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
930d : 48              >            pha         ;use stack to load status
930e : 28              >            plp
                        
930f : b11c                     lda (ind1),y
9311 : 08                       php         ;test stores do not alter flags
9312 : 49c3                     eor #$c3
9314 : 28                       plp
9315 : 990302                   sta abst,y
9318 : 08                       php         ;flags after load/store sequence
9319 : 49c3                     eor #$c3
931b : d91802                   cmp abs1,y  ;test result
                                trap_ne
931e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9320 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9321 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9323 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
9326 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9328 : 88                       dey
9329 : 10e0                     bpl tlday1                  
                        
932b : a003                     ldy #3      ;testing store result
932d : a200                     ldx #0
932f : b90302           tstay   lda abst,y
9332 : 49c3                     eor #$c3
9334 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
9337 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9339 : 8a                       txa
933a : 990302                   sta abst,y  ;clear                
933d : 88                       dey
933e : 10ef                     bpl tstay
                        
9340 : a003                     ldy #3
9342 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
9342 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9344 : 48              >            pha         ;use stack to load status
9345 : 28              >            plp
                        
9346 : b91802                   lda abs1,y
9349 : 08                       php         ;test stores do not alter flags
934a : 49c3                     eor #$c3
934c : 28                       plp
934d : 9128                     sta (indt),y
934f : 08                       php         ;flags after load/store sequence
9350 : 49c3                     eor #$c3
9352 : d11c                     cmp (ind1),y    ;test result
                                trap_ne
9354 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9356 : 68                       pla         ;load status
                                eor_flag 0
9357 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9359 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
935c : d0fe            >        bne *         ;failed not equal (non zero)
                        
935e : 88                       dey
935f : 10e1                     bpl tlday2                  
                        
9361 : a003                     ldy #3
9363 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
9363 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9365 : 48              >            pha         ;use stack to load status
9366 : 28              >            plp
                        
9367 : b91802                   lda abs1,y
936a : 08                       php         ;test stores do not alter flags
936b : 49c3                     eor #$c3
936d : 28                       plp
936e : 9128                     sta (indt),y
9370 : 08                       php         ;flags after load/store sequence
9371 : 49c3                     eor #$c3
9373 : d11c                     cmp (ind1),y   ;test result
                                trap_ne
9375 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9377 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9378 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
937a : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
937d : d0fe            >        bne *         ;failed not equal (non zero)
                        
937f : 88                       dey
9380 : 10e1                     bpl tlday3
                                
9382 : a003                     ldy #3      ;testing store result
9384 : a200                     ldx #0
9386 : b90302           tstay1  lda abst,y
9389 : 49c3                     eor #$c3
938b : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
938e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9390 : 8a                       txa
9391 : 990302                   sta abst,y  ;clear                
9394 : 88                       dey
9395 : 10ef                     bpl tstay1
                                
9397 : a206                     ldx #6
9399 : a003                     ldy #3
939b :                  tldax4   
                                set_stat 0
                       >            load_flag 0
939b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
939d : 48              >            pha         ;use stack to load status
939e : 28              >            plp
                        
939f : a11c                     lda (ind1,x)
93a1 : 08                       php         ;test stores do not alter flags
93a2 : 49c3                     eor #$c3
93a4 : 28                       plp
93a5 : 8128                     sta (indt,x)
93a7 : 08                       php         ;flags after load/store sequence
93a8 : 49c3                     eor #$c3
93aa : d91802                   cmp abs1,y  ;test result
                                trap_ne
93ad : d0fe            >        bne *         ;failed not equal (non zero)
                        
93af : 68                       pla         ;load status
                                eor_flag 0
93b0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
93b2 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
93b5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
93b7 : ca                       dex
93b8 : ca                       dex
93b9 : 88                       dey
93ba : 10df                     bpl tldax4                  
                        
93bc : a206                     ldx #6
93be : a003                     ldy #3
93c0 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
93c0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
93c2 : 48              >            pha         ;use stack to load status
93c3 : 28              >            plp
                        
93c4 : a11c                     lda (ind1,x)
93c6 : 08                       php         ;test stores do not alter flags
93c7 : 49c3                     eor #$c3
93c9 : 28                       plp
93ca : 8128                     sta (indt,x)
93cc : 08                       php         ;flags after load/store sequence
93cd : 49c3                     eor #$c3
93cf : d91802                   cmp abs1,y  ;test result
                                trap_ne
93d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
93d4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
93d5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
93d7 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
93da : d0fe            >        bne *         ;failed not equal (non zero)
                        
93dc : ca                       dex
93dd : ca                       dex
93de : 88                       dey
93df : 10df                     bpl tldax5
                        
93e1 : a003                     ldy #3      ;testing store result
93e3 : a200                     ldx #0
93e5 : b90302           tstay2  lda abst,y
93e8 : 49c3                     eor #$c3
93ea : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
93ed : d0fe            >        bne *         ;failed not equal (non zero)
                        
93ef : 8a                       txa
93f0 : 990302                   sta abst,y  ;clear                
93f3 : 88                       dey
93f4 : 10ef                     bpl tstay2
                                next_test
93f6 : ad0002          >            lda test_case   ;previous test
93f9 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
93fb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
93fd : a917            >            lda #test_num   ;*** next tests' number
93ff : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
9402 : a2fd                     ldx #3+$fa
9404 : b511             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
9406 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
9409 : ca                       dex
940a : e0fa                     cpx #$fa
940c : b0f6                     bcs tldax6                  
940e : a2fd                     ldx #3+$fa
9410 : bd1e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
9413 : 9508                     sta zpt-$fa&$ff,x
9415 : ca                       dex
9416 : e0fa                     cpx #$fa
9418 : b0f6                     bcs tldax7
                                                  
941a : a203                     ldx #3      ;testing wraparound result
941c : a000                     ldy #0
941e : b502             tstax1  lda zpt,x
9420 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
9422 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9424 : 9402                     sty zpt,x   ;clear                
9426 : bd0302                   lda abst,x
9429 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
942c : d0fe            >        bne *         ;failed not equal (non zero)
                        
942e : 8a                       txa
942f : 9d0302                   sta abst,x  ;clear                
9432 : ca                       dex
9433 : 10e9                     bpl tstax1
                        
9435 : a0fb                     ldy #3+$f8
9437 : a2fe                     ldx #6+$f8
9439 : a124             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
943b : 990b01                   sta abst-$f8,y
943e : ca                       dex
943f : ca                       dex
9440 : 88                       dey
9441 : c0f8                     cpy #$f8
9443 : b0f4                     bcs tlday4
9445 : a003                     ldy #3      ;testing wraparound result
9447 : a200                     ldx #0
9449 : b90302           tstay4  lda abst,y
944c : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
944f : d0fe            >        bne *         ;failed not equal (non zero)
                        
9451 : 8a                       txa
9452 : 990302                   sta abst,y  ;clear                
9455 : 88                       dey
9456 : 10f1                     bpl tstay4
                                
9458 : a0fb                     ldy #3+$f8
945a : b92001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
945d : 9130                     sta (inwt),y
945f : 88                       dey
9460 : c0f8                     cpy #$f8
9462 : b0f6                     bcs tlday5                  
9464 : a003                     ldy #3      ;testing wraparound result
9466 : a200                     ldx #0
9468 : b90302           tstay5  lda abst,y
946b : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
946e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9470 : 8a                       txa
9471 : 990302                   sta abst,y  ;clear                
9474 : 88                       dey
9475 : 10f1                     bpl tstay5
                        
9477 : a0fb                     ldy #3+$f8
9479 : a2fe                     ldx #6+$f8
947b : b126             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
947d : 8130                     sta (indt-$f8&$ff,x)
947f : ca                       dex
9480 : ca                       dex
9481 : 88                       dey
9482 : c0f8                     cpy #$f8
9484 : b0f5                     bcs tlday6
9486 : a003                     ldy #3      ;testing wraparound result
9488 : a200                     ldx #0
948a : b90302           tstay6  lda abst,y
948d : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
9490 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9492 : 8a                       txa
9493 : 990302                   sta abst,y  ;clear                
9496 : 88                       dey
9497 : 10f1                     bpl tstay6
                                next_test
9499 : ad0002          >            lda test_case   ;previous test
949c : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
949e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
94a0 : a918            >            lda #test_num   ;*** next tests' number
94a2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
94a5 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
94a7 : 48              >            pha         ;use stack to load status
94a8 : 28              >            plp
                        
94a9 : a50b                     lda zp1
94ab : 08                       php         ;test stores do not alter flags
94ac : 49c3                     eor #$c3
94ae : 28                       plp
94af : 8d0302                   sta abst
94b2 : 08                       php         ;flags after load/store sequence
94b3 : 49c3                     eor #$c3
94b5 : c9c3                     cmp #$c3    ;test result
                                trap_ne
94b7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
94b9 : 68                       pla         ;load status
                                eor_flag 0
94ba : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
94bc : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
94bf : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
94c1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
94c3 : 48              >            pha         ;use stack to load status
94c4 : 28              >            plp
                        
94c5 : a50c                     lda zp1+1
94c7 : 08                       php         ;test stores do not alter flags
94c8 : 49c3                     eor #$c3
94ca : 28                       plp
94cb : 8d0402                   sta abst+1
94ce : 08                       php         ;flags after load/store sequence
94cf : 49c3                     eor #$c3
94d1 : c982                     cmp #$82    ;test result
                                trap_ne
94d3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
94d5 : 68                       pla         ;load status
                                eor_flag 0
94d6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
94d8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
94db : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
94dd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
94df : 48              >            pha         ;use stack to load status
94e0 : 28              >            plp
                        
94e1 : a50d                     lda zp1+2
94e3 : 08                       php         ;test stores do not alter flags
94e4 : 49c3                     eor #$c3
94e6 : 28                       plp
94e7 : 8d0502                   sta abst+2
94ea : 08                       php         ;flags after load/store sequence
94eb : 49c3                     eor #$c3
94ed : c941                     cmp #$41    ;test result
                                trap_ne
94ef : d0fe            >        bne *         ;failed not equal (non zero)
                        
94f1 : 68                       pla         ;load status
                                eor_flag 0
94f2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
94f4 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
94f7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
94f9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
94fb : 48              >            pha         ;use stack to load status
94fc : 28              >            plp
                        
94fd : a50e                     lda zp1+3
94ff : 08                       php         ;test stores do not alter flags
9500 : 49c3                     eor #$c3
9502 : 28                       plp
9503 : 8d0602                   sta abst+3
9506 : 08                       php         ;flags after load/store sequence
9507 : 49c3                     eor #$c3
9509 : c900                     cmp #0      ;test result
                                trap_ne
950b : d0fe            >        bne *         ;failed not equal (non zero)
                        
950d : 68                       pla         ;load status
                                eor_flag 0
950e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9510 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9513 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9515 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9517 : 48              >            pha         ;use stack to load status
9518 : 28              >            plp
                        
9519 : a50b                     lda zp1  
951b : 08                       php         ;test stores do not alter flags
951c : 49c3                     eor #$c3
951e : 28                       plp
951f : 8d0302                   sta abst  
9522 : 08                       php         ;flags after load/store sequence
9523 : 49c3                     eor #$c3
9525 : c9c3                     cmp #$c3    ;test result
                                trap_ne
9527 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9529 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
952a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
952c : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
952f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9531 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9533 : 48              >            pha         ;use stack to load status
9534 : 28              >            plp
                        
9535 : a50c                     lda zp1+1
9537 : 08                       php         ;test stores do not alter flags
9538 : 49c3                     eor #$c3
953a : 28                       plp
953b : 8d0402                   sta abst+1
953e : 08                       php         ;flags after load/store sequence
953f : 49c3                     eor #$c3
9541 : c982                     cmp #$82    ;test result
                                trap_ne
9543 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9545 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9546 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9548 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
954b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
954d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
954f : 48              >            pha         ;use stack to load status
9550 : 28              >            plp
                        
9551 : a50d                     lda zp1+2
9553 : 08                       php         ;test stores do not alter flags
9554 : 49c3                     eor #$c3
9556 : 28                       plp
9557 : 8d0502                   sta abst+2
955a : 08                       php         ;flags after load/store sequence
955b : 49c3                     eor #$c3
955d : c941                     cmp #$41    ;test result
                                trap_ne
955f : d0fe            >        bne *         ;failed not equal (non zero)
                        
9561 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9562 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9564 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
9567 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9569 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
956b : 48              >            pha         ;use stack to load status
956c : 28              >            plp
                        
956d : a50e                     lda zp1+3
956f : 08                       php         ;test stores do not alter flags
9570 : 49c3                     eor #$c3
9572 : 28                       plp
9573 : 8d0602                   sta abst+3
9576 : 08                       php         ;flags after load/store sequence
9577 : 49c3                     eor #$c3
9579 : c900                     cmp #0      ;test result
                                trap_ne
957b : d0fe            >        bne *         ;failed not equal (non zero)
                        
957d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
957e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9580 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9583 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9585 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9587 : 48              >            pha         ;use stack to load status
9588 : 28              >            plp
                        
9589 : ad1802                   lda abs1  
958c : 08                       php         ;test stores do not alter flags
958d : 49c3                     eor #$c3
958f : 28                       plp
9590 : 8502                     sta zpt  
9592 : 08                       php         ;flags after load/store sequence
9593 : 49c3                     eor #$c3
9595 : c50b                     cmp zp1     ;test result
                                trap_ne
9597 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9599 : 68                       pla         ;load status
                                eor_flag 0
959a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
959c : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
959f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
95a1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
95a3 : 48              >            pha         ;use stack to load status
95a4 : 28              >            plp
                        
95a5 : ad1902                   lda abs1+1
95a8 : 08                       php         ;test stores do not alter flags
95a9 : 49c3                     eor #$c3
95ab : 28                       plp
95ac : 8503                     sta zpt+1
95ae : 08                       php         ;flags after load/store sequence
95af : 49c3                     eor #$c3
95b1 : c50c                     cmp zp1+1   ;test result
                                trap_ne
95b3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
95b5 : 68                       pla         ;load status
                                eor_flag 0
95b6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
95b8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
95bb : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
95bd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
95bf : 48              >            pha         ;use stack to load status
95c0 : 28              >            plp
                        
95c1 : ad1a02                   lda abs1+2
95c4 : 08                       php         ;test stores do not alter flags
95c5 : 49c3                     eor #$c3
95c7 : 28                       plp
95c8 : 8504                     sta zpt+2
95ca : 08                       php         ;flags after load/store sequence
95cb : 49c3                     eor #$c3
95cd : c50d                     cmp zp1+2   ;test result
                                trap_ne
95cf : d0fe            >        bne *         ;failed not equal (non zero)
                        
95d1 : 68                       pla         ;load status
                                eor_flag 0
95d2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
95d4 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
95d7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
95d9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
95db : 48              >            pha         ;use stack to load status
95dc : 28              >            plp
                        
95dd : ad1b02                   lda abs1+3
95e0 : 08                       php         ;test stores do not alter flags
95e1 : 49c3                     eor #$c3
95e3 : 28                       plp
95e4 : 8505                     sta zpt+3
95e6 : 08                       php         ;flags after load/store sequence
95e7 : 49c3                     eor #$c3
95e9 : c50e                     cmp zp1+3   ;test result
                                trap_ne
95eb : d0fe            >        bne *         ;failed not equal (non zero)
                        
95ed : 68                       pla         ;load status
                                eor_flag 0
95ee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
95f0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
95f3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
95f5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
95f7 : 48              >            pha         ;use stack to load status
95f8 : 28              >            plp
                        
95f9 : ad1802                   lda abs1  
95fc : 08                       php         ;test stores do not alter flags
95fd : 49c3                     eor #$c3
95ff : 28                       plp
9600 : 8502                     sta zpt  
9602 : 08                       php         ;flags after load/store sequence
9603 : 49c3                     eor #$c3
9605 : c50b                     cmp zp1     ;test result
                                trap_ne
9607 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9609 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
960a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
960c : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
960f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9611 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9613 : 48              >            pha         ;use stack to load status
9614 : 28              >            plp
                        
9615 : ad1902                   lda abs1+1
9618 : 08                       php         ;test stores do not alter flags
9619 : 49c3                     eor #$c3
961b : 28                       plp
961c : 8503                     sta zpt+1
961e : 08                       php         ;flags after load/store sequence
961f : 49c3                     eor #$c3
9621 : c50c                     cmp zp1+1   ;test result
                                trap_ne
9623 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9625 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9626 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9628 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
962b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
962d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
962f : 48              >            pha         ;use stack to load status
9630 : 28              >            plp
                        
9631 : ad1a02                   lda abs1+2
9634 : 08                       php         ;test stores do not alter flags
9635 : 49c3                     eor #$c3
9637 : 28                       plp
9638 : 8504                     sta zpt+2
963a : 08                       php         ;flags after load/store sequence
963b : 49c3                     eor #$c3
963d : c50d                     cmp zp1+2   ;test result
                                trap_ne
963f : d0fe            >        bne *         ;failed not equal (non zero)
                        
9641 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
9642 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9644 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
9647 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
9649 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
964b : 48              >            pha         ;use stack to load status
964c : 28              >            plp
                        
964d : ad1b02                   lda abs1+3
9650 : 08                       php         ;test stores do not alter flags
9651 : 49c3                     eor #$c3
9653 : 28                       plp
9654 : 8505                     sta zpt+3
9656 : 08                       php         ;flags after load/store sequence
9657 : 49c3                     eor #$c3
9659 : c50e                     cmp zp1+3   ;test result
                                trap_ne
965b : d0fe            >        bne *         ;failed not equal (non zero)
                        
965d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
965e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9660 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9663 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
9665 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
9667 : 48              >            pha         ;use stack to load status
9668 : 28              >            plp
                        
9669 : a9c3                     lda #$c3
966b : 08                       php
966c : cd1802                   cmp abs1    ;test result
                                trap_ne
966f : d0fe            >        bne *         ;failed not equal (non zero)
                        
9671 : 68                       pla         ;load status
                                eor_flag 0
9672 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9674 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
9677 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
9679 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
967b : 48              >            pha         ;use stack to load status
967c : 28              >            plp
                        
967d : a982                     lda #$82
967f : 08                       php
9680 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
9683 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9685 : 68                       pla         ;load status
                                eor_flag 0
9686 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
9688 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
968b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
968d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
968f : 48              >            pha         ;use stack to load status
9690 : 28              >            plp
                        
9691 : a941                     lda #$41
9693 : 08                       php
9694 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
9697 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9699 : 68                       pla         ;load status
                                eor_flag 0
969a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
969c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
969f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
96a1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
96a3 : 48              >            pha         ;use stack to load status
96a4 : 28              >            plp
                        
96a5 : a900                     lda #0
96a7 : 08                       php
96a8 : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
96ab : d0fe            >        bne *         ;failed not equal (non zero)
                        
96ad : 68                       pla         ;load status
                                eor_flag 0
96ae : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
96b0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
96b3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
96b5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
96b7 : 48              >            pha         ;use stack to load status
96b8 : 28              >            plp
                        
96b9 : a9c3                     lda #$c3  
96bb : 08                       php
96bc : cd1802                   cmp abs1    ;test result
                                trap_ne
96bf : d0fe            >        bne *         ;failed not equal (non zero)
                        
96c1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
96c2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
96c4 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
96c7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
96c9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
96cb : 48              >            pha         ;use stack to load status
96cc : 28              >            plp
                        
96cd : a982                     lda #$82
96cf : 08                       php
96d0 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
96d3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
96d5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
96d6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
96d8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
96db : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
96dd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
96df : 48              >            pha         ;use stack to load status
96e0 : 28              >            plp
                        
96e1 : a941                     lda #$41
96e3 : 08                       php
96e4 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
96e7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
96e9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
96ea : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
96ec : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
96ef : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
96f1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
96f3 : 48              >            pha         ;use stack to load status
96f4 : 28              >            plp
                        
96f5 : a900                     lda #0
96f7 : 08                       php
96f8 : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
96fb : d0fe            >        bne *         ;failed not equal (non zero)
                        
96fd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
96fe : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
9700 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
9703 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
9705 : a200                     ldx #0
9707 : a502                     lda zpt  
9709 : 49c3                     eor #$c3
970b : c50b                     cmp zp1  
                                trap_ne     ;store to zp data
970d : d0fe            >        bne *         ;failed not equal (non zero)
                        
970f : 8602                     stx zpt     ;clear                
9711 : ad0302                   lda abst  
9714 : 49c3                     eor #$c3
9716 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
9719 : d0fe            >        bne *         ;failed not equal (non zero)
                        
971b : 8e0302                   stx abst    ;clear                
971e : a503                     lda zpt+1
9720 : 49c3                     eor #$c3
9722 : c50c                     cmp zp1+1
                                trap_ne     ;store to zp data
9724 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9726 : 8603                     stx zpt+1   ;clear                
9728 : ad0402                   lda abst+1
972b : 49c3                     eor #$c3
972d : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
9730 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9732 : 8e0402                   stx abst+1  ;clear                
9735 : a504                     lda zpt+2
9737 : 49c3                     eor #$c3
9739 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp data
973b : d0fe            >        bne *         ;failed not equal (non zero)
                        
973d : 8604                     stx zpt+2   ;clear                
973f : ad0502                   lda abst+2
9742 : 49c3                     eor #$c3
9744 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
9747 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9749 : 8e0502                   stx abst+2  ;clear                
974c : a505                     lda zpt+3
974e : 49c3                     eor #$c3
9750 : c50e                     cmp zp1+3
                                trap_ne     ;store to zp data
9752 : d0fe            >        bne *         ;failed not equal (non zero)
                        
9754 : 8605                     stx zpt+3   ;clear                
9756 : ad0602                   lda abst+3
9759 : 49c3                     eor #$c3
975b : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
975e : d0fe            >        bne *         ;failed not equal (non zero)
                        
9760 : 8e0602                   stx abst+3  ;clear                
                                next_test
9763 : ad0002          >            lda test_case   ;previous test
9766 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
9768 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
976a : a919            >            lda #test_num   ;*** next tests' number
976c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
976f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9771 : 48              >            pha         ;use stack to load status
9772 : a9ff            >            lda #$ff     ;precharge accu
9774 : 28              >            plp
                        
9775 : 240e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
9777 : 08              >            php         ;save flags
9778 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
977a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
977c : 68              >            pla         ;load status
977d : 48              >            pha
                       >            cmp_flag fz 
977e : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9780 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9782 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
9783 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9785 : 48              >            pha         ;use stack to load status
9786 : a901            >            lda #1     ;precharge accu
9788 : 28              >            plp
                        
9789 : 240d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
978b : 08              >            php         ;save flags
978c : c901            >            cmp #1     ;test result
                       >            trap_ne
978e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9790 : 68              >            pla         ;load status
9791 : 48              >            pha
                       >            cmp_flag fv
9792 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9794 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9796 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
9797 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9799 : 48              >            pha         ;use stack to load status
979a : a901            >            lda #1     ;precharge accu
979c : 28              >            plp
                        
979d : 240c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
979f : 08              >            php         ;save flags
97a0 : c901            >            cmp #1     ;test result
                       >            trap_ne
97a2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97a4 : 68              >            pla         ;load status
97a5 : 48              >            pha
                       >            cmp_flag fnz
97a6 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97a8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97aa : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
97ab : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
97ad : 48              >            pha         ;use stack to load status
97ae : a901            >            lda #1     ;precharge accu
97b0 : 28              >            plp
                        
97b1 : 240b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
97b3 : 08              >            php         ;save flags
97b4 : c901            >            cmp #1     ;test result
                       >            trap_ne
97b6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97b8 : 68              >            pla         ;load status
97b9 : 48              >            pha
                       >            cmp_flag fnv
97ba : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97bc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97be : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
97bf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
97c1 : 48              >            pha         ;use stack to load status
97c2 : a9ff            >            lda #$ff     ;precharge accu
97c4 : 28              >            plp
                        
97c5 : 240e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
97c7 : 08              >            php         ;save flags
97c8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
97ca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97cc : 68              >            pla         ;load status
97cd : 48              >            pha
                       >            cmp_flag ~fnv 
97ce : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97d0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97d2 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
97d3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
97d5 : 48              >            pha         ;use stack to load status
97d6 : a901            >            lda #1     ;precharge accu
97d8 : 28              >            plp
                        
97d9 : 240d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
97db : 08              >            php         ;save flags
97dc : c901            >            cmp #1     ;test result
                       >            trap_ne
97de : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97e0 : 68              >            pla         ;load status
97e1 : 48              >            pha
                       >            cmp_flag ~fnz
97e2 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97e4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97e6 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
97e7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
97e9 : 48              >            pha         ;use stack to load status
97ea : a901            >            lda #1     ;precharge accu
97ec : 28              >            plp
                        
97ed : 240c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
97ef : 08              >            php         ;save flags
97f0 : c901            >            cmp #1     ;test result
                       >            trap_ne
97f2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97f4 : 68              >            pla         ;load status
97f5 : 48              >            pha
                       >            cmp_flag ~fv
97f6 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
97f8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
97fa : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
97fb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
97fd : 48              >            pha         ;use stack to load status
97fe : a901            >            lda #1     ;precharge accu
9800 : 28              >            plp
                        
9801 : 240b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
9803 : 08              >            php         ;save flags
9804 : c901            >            cmp #1     ;test result
                       >            trap_ne
9806 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9808 : 68              >            pla         ;load status
9809 : 48              >            pha
                       >            cmp_flag ~fz
980a : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
980c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
980e : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
980f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9811 : 48              >            pha         ;use stack to load status
9812 : a9ff            >            lda #$ff     ;precharge accu
9814 : 28              >            plp
                        
9815 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
9818 : 08              >            php         ;save flags
9819 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
981b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
981d : 68              >            pla         ;load status
981e : 48              >            pha
                       >            cmp_flag fz 
981f : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9821 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9823 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
9824 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9826 : 48              >            pha         ;use stack to load status
9827 : a901            >            lda #1     ;precharge accu
9829 : 28              >            plp
                        
982a : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
982d : 08              >            php         ;save flags
982e : c901            >            cmp #1     ;test result
                       >            trap_ne
9830 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9832 : 68              >            pla         ;load status
9833 : 48              >            pha
                       >            cmp_flag fv
9834 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9836 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9838 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
9839 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
983b : 48              >            pha         ;use stack to load status
983c : a901            >            lda #1     ;precharge accu
983e : 28              >            plp
                        
983f : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
9842 : 08              >            php         ;save flags
9843 : c901            >            cmp #1     ;test result
                       >            trap_ne
9845 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9847 : 68              >            pla         ;load status
9848 : 48              >            pha
                       >            cmp_flag fnz
9849 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
984b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
984d : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
984e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9850 : 48              >            pha         ;use stack to load status
9851 : a901            >            lda #1     ;precharge accu
9853 : 28              >            plp
                        
9854 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
9857 : 08              >            php         ;save flags
9858 : c901            >            cmp #1     ;test result
                       >            trap_ne
985a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
985c : 68              >            pla         ;load status
985d : 48              >            pha
                       >            cmp_flag fnv
985e : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9860 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9862 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
9863 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9865 : 48              >            pha         ;use stack to load status
9866 : a9ff            >            lda #$ff     ;precharge accu
9868 : 28              >            plp
                        
9869 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
986c : 08              >            php         ;save flags
986d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
986f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9871 : 68              >            pla         ;load status
9872 : 48              >            pha
                       >            cmp_flag ~fnv 
9873 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9875 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9877 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
9878 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
987a : 48              >            pha         ;use stack to load status
987b : a901            >            lda #1     ;precharge accu
987d : 28              >            plp
                        
987e : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
9881 : 08              >            php         ;save flags
9882 : c901            >            cmp #1     ;test result
                       >            trap_ne
9884 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9886 : 68              >            pla         ;load status
9887 : 48              >            pha
                       >            cmp_flag ~fnz
9888 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
988a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
988c : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
988d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
988f : 48              >            pha         ;use stack to load status
9890 : a901            >            lda #1     ;precharge accu
9892 : 28              >            plp
                        
9893 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
9896 : 08              >            php         ;save flags
9897 : c901            >            cmp #1     ;test result
                       >            trap_ne
9899 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
989b : 68              >            pla         ;load status
989c : 48              >            pha
                       >            cmp_flag ~fv
989d : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
989f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98a1 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
98a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
98a4 : 48              >            pha         ;use stack to load status
98a5 : a901            >            lda #1     ;precharge accu
98a7 : 28              >            plp
                        
98a8 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
98ab : 08              >            php         ;save flags
98ac : c901            >            cmp #1     ;test result
                       >            trap_ne
98ae : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98b0 : 68              >            pla         ;load status
98b1 : 48              >            pha
                       >            cmp_flag ~fz
98b2 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98b4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98b6 : 28              >            plp         ;restore status
                        
                                next_test
98b7 : ad0002          >            lda test_case   ;previous test
98ba : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
98bc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
98be : a91a            >            lda #test_num   ;*** next tests' number
98c0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
98c3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
98c5 : 48              >            pha         ;use stack to load status
98c6 : a280            >            ldx #$80     ;precharge index x
98c8 : 28              >            plp
                        
98c9 : e40f                     cpx zp7f
                                tst_stat fc
98cb : 08              >            php         ;save status
98cc : 68              >            pla         ;use stack to retrieve status
98cd : 48              >            pha
                       >            cmp_flag fc
98ce : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98d0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98d2 : 28              >            plp         ;restore status
                        
98d3 : ca                       dex
98d4 : e40f                     cpx zp7f
                                tst_stat fzc
98d6 : 08              >            php         ;save status
98d7 : 68              >            pla         ;use stack to retrieve status
98d8 : 48              >            pha
                       >            cmp_flag fzc
98d9 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98db : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98dd : 28              >            plp         ;restore status
                        
98de : ca                       dex
98df : e40f                     cpx zp7f
                                tst_x $7e,fn
98e1 : 08              >            php         ;save flags
98e2 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
98e4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98e6 : 68              >            pla         ;load status
98e7 : 48              >            pha
                       >            cmp_flag fn
98e8 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98ea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98ec : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
98ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
98ef : 48              >            pha         ;use stack to load status
98f0 : a280            >            ldx #$80     ;precharge index x
98f2 : 28              >            plp
                        
98f3 : e40f                     cpx zp7f
                                tst_stat ~fnz
98f5 : 08              >            php         ;save status
98f6 : 68              >            pla         ;use stack to retrieve status
98f7 : 48              >            pha
                       >            cmp_flag ~fnz
98f8 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
98fa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
98fc : 28              >            plp         ;restore status
                        
98fd : ca                       dex
98fe : e40f                     cpx zp7f
                                tst_stat ~fn
9900 : 08              >            php         ;save status
9901 : 68              >            pla         ;use stack to retrieve status
9902 : 48              >            pha
                       >            cmp_flag ~fn
9903 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9905 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9907 : 28              >            plp         ;restore status
                        
9908 : ca                       dex
9909 : e40f                     cpx zp7f
                                tst_x $7e,~fzc
990b : 08              >            php         ;save flags
990c : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
990e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9910 : 68              >            pla         ;load status
9911 : 48              >            pha
                       >            cmp_flag ~fzc
9912 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9914 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9916 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
9917 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9919 : 48              >            pha         ;use stack to load status
991a : a280            >            ldx #$80     ;precharge index x
991c : 28              >            plp
                        
991d : ec1c02                   cpx abs7f
                                tst_stat fc
9920 : 08              >            php         ;save status
9921 : 68              >            pla         ;use stack to retrieve status
9922 : 48              >            pha
                       >            cmp_flag fc
9923 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9925 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9927 : 28              >            plp         ;restore status
                        
9928 : ca                       dex
9929 : ec1c02                   cpx abs7f
                                tst_stat fzc
992c : 08              >            php         ;save status
992d : 68              >            pla         ;use stack to retrieve status
992e : 48              >            pha
                       >            cmp_flag fzc
992f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9931 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9933 : 28              >            plp         ;restore status
                        
9934 : ca                       dex
9935 : ec1c02                   cpx abs7f
                                tst_x $7e,fn
9938 : 08              >            php         ;save flags
9939 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
993b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
993d : 68              >            pla         ;load status
993e : 48              >            pha
                       >            cmp_flag fn
993f : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9941 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9943 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
9944 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9946 : 48              >            pha         ;use stack to load status
9947 : a280            >            ldx #$80     ;precharge index x
9949 : 28              >            plp
                        
994a : ec1c02                   cpx abs7f
                                tst_stat ~fnz
994d : 08              >            php         ;save status
994e : 68              >            pla         ;use stack to retrieve status
994f : 48              >            pha
                       >            cmp_flag ~fnz
9950 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9952 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9954 : 28              >            plp         ;restore status
                        
9955 : ca                       dex
9956 : ec1c02                   cpx abs7f
                                tst_stat ~fn
9959 : 08              >            php         ;save status
995a : 68              >            pla         ;use stack to retrieve status
995b : 48              >            pha
                       >            cmp_flag ~fn
995c : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
995e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9960 : 28              >            plp         ;restore status
                        
9961 : ca                       dex
9962 : ec1c02                   cpx abs7f
                                tst_x $7e,~fzc
9965 : 08              >            php         ;save flags
9966 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
9968 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
996a : 68              >            pla         ;load status
996b : 48              >            pha
                       >            cmp_flag ~fzc
996c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
996e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9970 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
9971 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9973 : 48              >            pha         ;use stack to load status
9974 : a280            >            ldx #$80     ;precharge index x
9976 : 28              >            plp
                        
9977 : e07f                     cpx #$7f
                                tst_stat fc
9979 : 08              >            php         ;save status
997a : 68              >            pla         ;use stack to retrieve status
997b : 48              >            pha
                       >            cmp_flag fc
997c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
997e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9980 : 28              >            plp         ;restore status
                        
9981 : ca                       dex
9982 : e07f                     cpx #$7f
                                tst_stat fzc
9984 : 08              >            php         ;save status
9985 : 68              >            pla         ;use stack to retrieve status
9986 : 48              >            pha
                       >            cmp_flag fzc
9987 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9989 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
998b : 28              >            plp         ;restore status
                        
998c : ca                       dex
998d : e07f                     cpx #$7f
                                tst_x $7e,fn
998f : 08              >            php         ;save flags
9990 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
9992 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9994 : 68              >            pla         ;load status
9995 : 48              >            pha
                       >            cmp_flag fn
9996 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9998 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
999a : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
999b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
999d : 48              >            pha         ;use stack to load status
999e : a280            >            ldx #$80     ;precharge index x
99a0 : 28              >            plp
                        
99a1 : e07f                     cpx #$7f
                                tst_stat ~fnz
99a3 : 08              >            php         ;save status
99a4 : 68              >            pla         ;use stack to retrieve status
99a5 : 48              >            pha
                       >            cmp_flag ~fnz
99a6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99a8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99aa : 28              >            plp         ;restore status
                        
99ab : ca                       dex
99ac : e07f                     cpx #$7f
                                tst_stat ~fn
99ae : 08              >            php         ;save status
99af : 68              >            pla         ;use stack to retrieve status
99b0 : 48              >            pha
                       >            cmp_flag ~fn
99b1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99b3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99b5 : 28              >            plp         ;restore status
                        
99b6 : ca                       dex
99b7 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
99b9 : 08              >            php         ;save flags
99ba : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
99bc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99be : 68              >            pla         ;load status
99bf : 48              >            pha
                       >            cmp_flag ~fzc
99c0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99c2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99c4 : 28              >            plp         ;restore status
                        
                                next_test
99c5 : ad0002          >            lda test_case   ;previous test
99c8 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
99ca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
99cc : a91b            >            lda #test_num   ;*** next tests' number
99ce : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
99d1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
99d3 : 48              >            pha         ;use stack to load status
99d4 : a080            >            ldy #$80     ;precharge index y
99d6 : 28              >            plp
                        
99d7 : c40f                     cpy zp7f
                                tst_stat fc
99d9 : 08              >            php         ;save status
99da : 68              >            pla         ;use stack to retrieve status
99db : 48              >            pha
                       >            cmp_flag fc
99dc : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99de : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99e0 : 28              >            plp         ;restore status
                        
99e1 : 88                       dey
99e2 : c40f                     cpy zp7f
                                tst_stat fzc
99e4 : 08              >            php         ;save status
99e5 : 68              >            pla         ;use stack to retrieve status
99e6 : 48              >            pha
                       >            cmp_flag fzc
99e7 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99e9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99eb : 28              >            plp         ;restore status
                        
99ec : 88                       dey
99ed : c40f                     cpy zp7f
                                tst_y $7e,fn
99ef : 08              >            php         ;save flags
99f0 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
99f2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99f4 : 68              >            pla         ;load status
99f5 : 48              >            pha
                       >            cmp_flag fn
99f6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
99f8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
99fa : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
99fb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
99fd : 48              >            pha         ;use stack to load status
99fe : a080            >            ldy #$80     ;precharge index y
9a00 : 28              >            plp
                        
9a01 : c40f                     cpy zp7f
                                tst_stat ~fnz
9a03 : 08              >            php         ;save status
9a04 : 68              >            pla         ;use stack to retrieve status
9a05 : 48              >            pha
                       >            cmp_flag ~fnz
9a06 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a08 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a0a : 28              >            plp         ;restore status
                        
9a0b : 88                       dey
9a0c : c40f                     cpy zp7f
                                tst_stat ~fn
9a0e : 08              >            php         ;save status
9a0f : 68              >            pla         ;use stack to retrieve status
9a10 : 48              >            pha
                       >            cmp_flag ~fn
9a11 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a13 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a15 : 28              >            plp         ;restore status
                        
9a16 : 88                       dey
9a17 : c40f                     cpy zp7f
                                tst_y $7e,~fzc
9a19 : 08              >            php         ;save flags
9a1a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9a1c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a1e : 68              >            pla         ;load status
9a1f : 48              >            pha
                       >            cmp_flag ~fzc
9a20 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a22 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a24 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
9a25 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9a27 : 48              >            pha         ;use stack to load status
9a28 : a080            >            ldy #$80     ;precharge index y
9a2a : 28              >            plp
                        
9a2b : cc1c02                   cpy abs7f
                                tst_stat fc
9a2e : 08              >            php         ;save status
9a2f : 68              >            pla         ;use stack to retrieve status
9a30 : 48              >            pha
                       >            cmp_flag fc
9a31 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a33 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a35 : 28              >            plp         ;restore status
                        
9a36 : 88                       dey
9a37 : cc1c02                   cpy abs7f
                                tst_stat fzc
9a3a : 08              >            php         ;save status
9a3b : 68              >            pla         ;use stack to retrieve status
9a3c : 48              >            pha
                       >            cmp_flag fzc
9a3d : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a3f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a41 : 28              >            plp         ;restore status
                        
9a42 : 88                       dey
9a43 : cc1c02                   cpy abs7f
                                tst_y $7e,fn
9a46 : 08              >            php         ;save flags
9a47 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9a49 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a4b : 68              >            pla         ;load status
9a4c : 48              >            pha
                       >            cmp_flag fn
9a4d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a4f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a51 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
9a52 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9a54 : 48              >            pha         ;use stack to load status
9a55 : a080            >            ldy #$80     ;precharge index y
9a57 : 28              >            plp
                        
9a58 : cc1c02                   cpy abs7f
                                tst_stat ~fnz
9a5b : 08              >            php         ;save status
9a5c : 68              >            pla         ;use stack to retrieve status
9a5d : 48              >            pha
                       >            cmp_flag ~fnz
9a5e : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a60 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a62 : 28              >            plp         ;restore status
                        
9a63 : 88                       dey
9a64 : cc1c02                   cpy abs7f
                                tst_stat ~fn
9a67 : 08              >            php         ;save status
9a68 : 68              >            pla         ;use stack to retrieve status
9a69 : 48              >            pha
                       >            cmp_flag ~fn
9a6a : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a6c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a6e : 28              >            plp         ;restore status
                        
9a6f : 88                       dey
9a70 : cc1c02                   cpy abs7f
                                tst_y $7e,~fzc
9a73 : 08              >            php         ;save flags
9a74 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9a76 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a78 : 68              >            pla         ;load status
9a79 : 48              >            pha
                       >            cmp_flag ~fzc
9a7a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a7c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a7e : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
9a7f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9a81 : 48              >            pha         ;use stack to load status
9a82 : a080            >            ldy #$80     ;precharge index y
9a84 : 28              >            plp
                        
9a85 : c07f                     cpy #$7f
                                tst_stat fc
9a87 : 08              >            php         ;save status
9a88 : 68              >            pla         ;use stack to retrieve status
9a89 : 48              >            pha
                       >            cmp_flag fc
9a8a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a8c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a8e : 28              >            plp         ;restore status
                        
9a8f : 88                       dey
9a90 : c07f                     cpy #$7f
                                tst_stat fzc
9a92 : 08              >            php         ;save status
9a93 : 68              >            pla         ;use stack to retrieve status
9a94 : 48              >            pha
                       >            cmp_flag fzc
9a95 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9a97 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9a99 : 28              >            plp         ;restore status
                        
9a9a : 88                       dey
9a9b : c07f                     cpy #$7f
                                tst_y $7e,fn
9a9d : 08              >            php         ;save flags
9a9e : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9aa0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9aa2 : 68              >            pla         ;load status
9aa3 : 48              >            pha
                       >            cmp_flag fn
9aa4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9aa6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9aa8 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
9aa9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9aab : 48              >            pha         ;use stack to load status
9aac : a080            >            ldy #$80     ;precharge index y
9aae : 28              >            plp
                        
9aaf : c07f                     cpy #$7f
                                tst_stat ~fnz
9ab1 : 08              >            php         ;save status
9ab2 : 68              >            pla         ;use stack to retrieve status
9ab3 : 48              >            pha
                       >            cmp_flag ~fnz
9ab4 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ab6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ab8 : 28              >            plp         ;restore status
                        
9ab9 : 88                       dey
9aba : c07f                     cpy #$7f
                                tst_stat ~fn
9abc : 08              >            php         ;save status
9abd : 68              >            pla         ;use stack to retrieve status
9abe : 48              >            pha
                       >            cmp_flag ~fn
9abf : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ac1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ac3 : 28              >            plp         ;restore status
                        
9ac4 : 88                       dey
9ac5 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
9ac7 : 08              >            php         ;save flags
9ac8 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
9aca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9acc : 68              >            pla         ;load status
9acd : 48              >            pha
                       >            cmp_flag ~fzc
9ace : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ad0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ad2 : 28              >            plp         ;restore status
                        
                                next_test
9ad3 : ad0002          >            lda test_case   ;previous test
9ad6 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
9ad8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
9ada : a91c            >            lda #test_num   ;*** next tests' number
9adc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
9adf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9ae1 : 48              >            pha         ;use stack to load status
9ae2 : a980            >            lda #$80     ;precharge accu
9ae4 : 28              >            plp
                        
9ae5 : c50f                     cmp zp7f
                                tst_a $80,fc
9ae7 : 08              >            php         ;save flags
9ae8 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9aea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9aec : 68              >            pla         ;load status
9aed : 48              >            pha
                       >            cmp_flag fc
9aee : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9af0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9af2 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9af3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9af5 : 48              >            pha         ;use stack to load status
9af6 : a97f            >            lda #$7f     ;precharge accu
9af8 : 28              >            plp
                        
9af9 : c50f                     cmp zp7f
                                tst_a $7f,fzc
9afb : 08              >            php         ;save flags
9afc : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9afe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b00 : 68              >            pla         ;load status
9b01 : 48              >            pha
                       >            cmp_flag fzc
9b02 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b04 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b06 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9b07 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9b09 : 48              >            pha         ;use stack to load status
9b0a : a97e            >            lda #$7e     ;precharge accu
9b0c : 28              >            plp
                        
9b0d : c50f                     cmp zp7f
                                tst_a $7e,fn
9b0f : 08              >            php         ;save flags
9b10 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9b12 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b14 : 68              >            pla         ;load status
9b15 : 48              >            pha
                       >            cmp_flag fn
9b16 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b18 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b1a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9b1b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9b1d : 48              >            pha         ;use stack to load status
9b1e : a980            >            lda #$80     ;precharge accu
9b20 : 28              >            plp
                        
9b21 : c50f                     cmp zp7f
                                tst_a $80,~fnz
9b23 : 08              >            php         ;save flags
9b24 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9b26 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b28 : 68              >            pla         ;load status
9b29 : 48              >            pha
                       >            cmp_flag ~fnz
9b2a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b2c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b2e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9b2f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9b31 : 48              >            pha         ;use stack to load status
9b32 : a97f            >            lda #$7f     ;precharge accu
9b34 : 28              >            plp
                        
9b35 : c50f                     cmp zp7f
                                tst_a $7f,~fn
9b37 : 08              >            php         ;save flags
9b38 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9b3a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b3c : 68              >            pla         ;load status
9b3d : 48              >            pha
                       >            cmp_flag ~fn
9b3e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b40 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b42 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9b43 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9b45 : 48              >            pha         ;use stack to load status
9b46 : a97e            >            lda #$7e     ;precharge accu
9b48 : 28              >            plp
                        
9b49 : c50f                     cmp zp7f
                                tst_a $7e,~fzc
9b4b : 08              >            php         ;save flags
9b4c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9b4e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b50 : 68              >            pla         ;load status
9b51 : 48              >            pha
                       >            cmp_flag ~fzc
9b52 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b54 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b56 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9b57 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9b59 : 48              >            pha         ;use stack to load status
9b5a : a980            >            lda #$80     ;precharge accu
9b5c : 28              >            plp
                        
9b5d : cd1c02                   cmp abs7f
                                tst_a $80,fc
9b60 : 08              >            php         ;save flags
9b61 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9b63 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b65 : 68              >            pla         ;load status
9b66 : 48              >            pha
                       >            cmp_flag fc
9b67 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b6b : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9b6c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9b6e : 48              >            pha         ;use stack to load status
9b6f : a97f            >            lda #$7f     ;precharge accu
9b71 : 28              >            plp
                        
9b72 : cd1c02                   cmp abs7f
                                tst_a $7f,fzc
9b75 : 08              >            php         ;save flags
9b76 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9b78 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b7a : 68              >            pla         ;load status
9b7b : 48              >            pha
                       >            cmp_flag fzc
9b7c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b7e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b80 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9b81 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9b83 : 48              >            pha         ;use stack to load status
9b84 : a97e            >            lda #$7e     ;precharge accu
9b86 : 28              >            plp
                        
9b87 : cd1c02                   cmp abs7f
                                tst_a $7e,fn
9b8a : 08              >            php         ;save flags
9b8b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9b8d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b8f : 68              >            pla         ;load status
9b90 : 48              >            pha
                       >            cmp_flag fn
9b91 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9b93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9b95 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9b96 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9b98 : 48              >            pha         ;use stack to load status
9b99 : a980            >            lda #$80     ;precharge accu
9b9b : 28              >            plp
                        
9b9c : cd1c02                   cmp abs7f
                                tst_a $80,~fnz
9b9f : 08              >            php         ;save flags
9ba0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9ba2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ba4 : 68              >            pla         ;load status
9ba5 : 48              >            pha
                       >            cmp_flag ~fnz
9ba6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ba8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9baa : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9bab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9bad : 48              >            pha         ;use stack to load status
9bae : a97f            >            lda #$7f     ;precharge accu
9bb0 : 28              >            plp
                        
9bb1 : cd1c02                   cmp abs7f
                                tst_a $7f,~fn
9bb4 : 08              >            php         ;save flags
9bb5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9bb7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bb9 : 68              >            pla         ;load status
9bba : 48              >            pha
                       >            cmp_flag ~fn
9bbb : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9bbd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bbf : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9bc0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9bc2 : 48              >            pha         ;use stack to load status
9bc3 : a97e            >            lda #$7e     ;precharge accu
9bc5 : 28              >            plp
                        
9bc6 : cd1c02                   cmp abs7f
                                tst_a $7e,~fzc
9bc9 : 08              >            php         ;save flags
9bca : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9bcc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bce : 68              >            pla         ;load status
9bcf : 48              >            pha
                       >            cmp_flag ~fzc
9bd0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9bd2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bd4 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9bd5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9bd7 : 48              >            pha         ;use stack to load status
9bd8 : a980            >            lda #$80     ;precharge accu
9bda : 28              >            plp
                        
9bdb : c97f                     cmp #$7f
                                tst_a $80,fc
9bdd : 08              >            php         ;save flags
9bde : c980            >            cmp #$80     ;test result
                       >            trap_ne
9be0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9be2 : 68              >            pla         ;load status
9be3 : 48              >            pha
                       >            cmp_flag fc
9be4 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9be6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9be8 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9be9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9beb : 48              >            pha         ;use stack to load status
9bec : a97f            >            lda #$7f     ;precharge accu
9bee : 28              >            plp
                        
9bef : c97f                     cmp #$7f
                                tst_a $7f,fzc
9bf1 : 08              >            php         ;save flags
9bf2 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9bf4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bf6 : 68              >            pla         ;load status
9bf7 : 48              >            pha
                       >            cmp_flag fzc
9bf8 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9bfa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9bfc : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9bfd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9bff : 48              >            pha         ;use stack to load status
9c00 : a97e            >            lda #$7e     ;precharge accu
9c02 : 28              >            plp
                        
9c03 : c97f                     cmp #$7f
                                tst_a $7e,fn
9c05 : 08              >            php         ;save flags
9c06 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9c08 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c0a : 68              >            pla         ;load status
9c0b : 48              >            pha
                       >            cmp_flag fn
9c0c : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c0e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c10 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9c11 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9c13 : 48              >            pha         ;use stack to load status
9c14 : a980            >            lda #$80     ;precharge accu
9c16 : 28              >            plp
                        
9c17 : c97f                     cmp #$7f
                                tst_a $80,~fnz
9c19 : 08              >            php         ;save flags
9c1a : c980            >            cmp #$80     ;test result
                       >            trap_ne
9c1c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c1e : 68              >            pla         ;load status
9c1f : 48              >            pha
                       >            cmp_flag ~fnz
9c20 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c22 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c24 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9c25 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9c27 : 48              >            pha         ;use stack to load status
9c28 : a97f            >            lda #$7f     ;precharge accu
9c2a : 28              >            plp
                        
9c2b : c97f                     cmp #$7f
                                tst_a $7f,~fn
9c2d : 08              >            php         ;save flags
9c2e : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9c30 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c32 : 68              >            pla         ;load status
9c33 : 48              >            pha
                       >            cmp_flag ~fn
9c34 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c36 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c38 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9c39 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9c3b : 48              >            pha         ;use stack to load status
9c3c : a97e            >            lda #$7e     ;precharge accu
9c3e : 28              >            plp
                        
9c3f : c97f                     cmp #$7f
                                tst_a $7e,~fzc
9c41 : 08              >            php         ;save flags
9c42 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9c44 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c46 : 68              >            pla         ;load status
9c47 : 48              >            pha
                       >            cmp_flag ~fzc
9c48 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c4a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c4c : 28              >            plp         ;restore status
                        
                        
9c4d : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
9c4f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9c51 : 48              >            pha         ;use stack to load status
9c52 : a980            >            lda #$80     ;precharge accu
9c54 : 28              >            plp
                        
9c55 : d50b                     cmp zp1,x
                                tst_a $80,fc
9c57 : 08              >            php         ;save flags
9c58 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9c5a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c5c : 68              >            pla         ;load status
9c5d : 48              >            pha
                       >            cmp_flag fc
9c5e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c60 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c62 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9c63 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9c65 : 48              >            pha         ;use stack to load status
9c66 : a97f            >            lda #$7f     ;precharge accu
9c68 : 28              >            plp
                        
9c69 : d50b                     cmp zp1,x
                                tst_a $7f,fzc
9c6b : 08              >            php         ;save flags
9c6c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9c6e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c70 : 68              >            pla         ;load status
9c71 : 48              >            pha
                       >            cmp_flag fzc
9c72 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c74 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c76 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9c77 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9c79 : 48              >            pha         ;use stack to load status
9c7a : a97e            >            lda #$7e     ;precharge accu
9c7c : 28              >            plp
                        
9c7d : d50b                     cmp zp1,x
                                tst_a $7e,fn
9c7f : 08              >            php         ;save flags
9c80 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9c82 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c84 : 68              >            pla         ;load status
9c85 : 48              >            pha
                       >            cmp_flag fn
9c86 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c88 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c8a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9c8b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9c8d : 48              >            pha         ;use stack to load status
9c8e : a980            >            lda #$80     ;precharge accu
9c90 : 28              >            plp
                        
9c91 : d50b                     cmp zp1,x
                                tst_a $80,~fnz
9c93 : 08              >            php         ;save flags
9c94 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9c96 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c98 : 68              >            pla         ;load status
9c99 : 48              >            pha
                       >            cmp_flag ~fnz
9c9a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9c9c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9c9e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9c9f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9ca1 : 48              >            pha         ;use stack to load status
9ca2 : a97f            >            lda #$7f     ;precharge accu
9ca4 : 28              >            plp
                        
9ca5 : d50b                     cmp zp1,x
                                tst_a $7f,~fn
9ca7 : 08              >            php         ;save flags
9ca8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9caa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cac : 68              >            pla         ;load status
9cad : 48              >            pha
                       >            cmp_flag ~fn
9cae : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9cb0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cb2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9cb3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9cb5 : 48              >            pha         ;use stack to load status
9cb6 : a97e            >            lda #$7e     ;precharge accu
9cb8 : 28              >            plp
                        
9cb9 : d50b                     cmp zp1,x
                                tst_a $7e,~fzc
9cbb : 08              >            php         ;save flags
9cbc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9cbe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cc0 : 68              >            pla         ;load status
9cc1 : 48              >            pha
                       >            cmp_flag ~fzc
9cc2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9cc4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cc6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9cc7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9cc9 : 48              >            pha         ;use stack to load status
9cca : a980            >            lda #$80     ;precharge accu
9ccc : 28              >            plp
                        
9ccd : dd1802                   cmp abs1,x
                                tst_a $80,fc
9cd0 : 08              >            php         ;save flags
9cd1 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9cd3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cd5 : 68              >            pla         ;load status
9cd6 : 48              >            pha
                       >            cmp_flag fc
9cd7 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9cd9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cdb : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9cdc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9cde : 48              >            pha         ;use stack to load status
9cdf : a97f            >            lda #$7f     ;precharge accu
9ce1 : 28              >            plp
                        
9ce2 : dd1802                   cmp abs1,x
                                tst_a $7f,fzc
9ce5 : 08              >            php         ;save flags
9ce6 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9ce8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cea : 68              >            pla         ;load status
9ceb : 48              >            pha
                       >            cmp_flag fzc
9cec : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9cee : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cf0 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9cf1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9cf3 : 48              >            pha         ;use stack to load status
9cf4 : a97e            >            lda #$7e     ;precharge accu
9cf6 : 28              >            plp
                        
9cf7 : dd1802                   cmp abs1,x
                                tst_a $7e,fn
9cfa : 08              >            php         ;save flags
9cfb : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9cfd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9cff : 68              >            pla         ;load status
9d00 : 48              >            pha
                       >            cmp_flag fn
9d01 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d03 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d05 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9d06 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9d08 : 48              >            pha         ;use stack to load status
9d09 : a980            >            lda #$80     ;precharge accu
9d0b : 28              >            plp
                        
9d0c : dd1802                   cmp abs1,x
                                tst_a $80,~fnz
9d0f : 08              >            php         ;save flags
9d10 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9d12 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d14 : 68              >            pla         ;load status
9d15 : 48              >            pha
                       >            cmp_flag ~fnz
9d16 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d18 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d1a : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9d1b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9d1d : 48              >            pha         ;use stack to load status
9d1e : a97f            >            lda #$7f     ;precharge accu
9d20 : 28              >            plp
                        
9d21 : dd1802                   cmp abs1,x
                                tst_a $7f,~fn
9d24 : 08              >            php         ;save flags
9d25 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9d27 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d29 : 68              >            pla         ;load status
9d2a : 48              >            pha
                       >            cmp_flag ~fn
9d2b : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d2d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d2f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9d30 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9d32 : 48              >            pha         ;use stack to load status
9d33 : a97e            >            lda #$7e     ;precharge accu
9d35 : 28              >            plp
                        
9d36 : dd1802                   cmp abs1,x
                                tst_a $7e,~fzc
9d39 : 08              >            php         ;save flags
9d3a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9d3c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d3e : 68              >            pla         ;load status
9d3f : 48              >            pha
                       >            cmp_flag ~fzc
9d40 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d42 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d44 : 28              >            plp         ;restore status
                        
                        
9d45 : a004                     ldy #4          ;with indexing by Y
9d47 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
9d49 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9d4b : 48              >            pha         ;use stack to load status
9d4c : a980            >            lda #$80     ;precharge accu
9d4e : 28              >            plp
                        
9d4f : d91802                   cmp abs1,y
                                tst_a $80,fc
9d52 : 08              >            php         ;save flags
9d53 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9d55 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d57 : 68              >            pla         ;load status
9d58 : 48              >            pha
                       >            cmp_flag fc
9d59 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d5b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d5d : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9d5e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9d60 : 48              >            pha         ;use stack to load status
9d61 : a97f            >            lda #$7f     ;precharge accu
9d63 : 28              >            plp
                        
9d64 : d91802                   cmp abs1,y
                                tst_a $7f,fzc
9d67 : 08              >            php         ;save flags
9d68 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9d6a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d6c : 68              >            pla         ;load status
9d6d : 48              >            pha
                       >            cmp_flag fzc
9d6e : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d70 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d72 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9d73 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9d75 : 48              >            pha         ;use stack to load status
9d76 : a97e            >            lda #$7e     ;precharge accu
9d78 : 28              >            plp
                        
9d79 : d91802                   cmp abs1,y
                                tst_a $7e,fn
9d7c : 08              >            php         ;save flags
9d7d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9d7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d81 : 68              >            pla         ;load status
9d82 : 48              >            pha
                       >            cmp_flag fn
9d83 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d85 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d87 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9d88 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9d8a : 48              >            pha         ;use stack to load status
9d8b : a980            >            lda #$80     ;precharge accu
9d8d : 28              >            plp
                        
9d8e : d91802                   cmp abs1,y
                                tst_a $80,~fnz
9d91 : 08              >            php         ;save flags
9d92 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9d94 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d96 : 68              >            pla         ;load status
9d97 : 48              >            pha
                       >            cmp_flag ~fnz
9d98 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9d9a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9d9c : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9d9d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9d9f : 48              >            pha         ;use stack to load status
9da0 : a97f            >            lda #$7f     ;precharge accu
9da2 : 28              >            plp
                        
9da3 : d91802                   cmp abs1,y
                                tst_a $7f,~fn
9da6 : 08              >            php         ;save flags
9da7 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9da9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dab : 68              >            pla         ;load status
9dac : 48              >            pha
                       >            cmp_flag ~fn
9dad : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9daf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9db1 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9db2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9db4 : 48              >            pha         ;use stack to load status
9db5 : a97e            >            lda #$7e     ;precharge accu
9db7 : 28              >            plp
                        
9db8 : d91802                   cmp abs1,y
                                tst_a $7e,~fzc
9dbb : 08              >            php         ;save flags
9dbc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9dbe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dc0 : 68              >            pla         ;load status
9dc1 : 48              >            pha
                       >            cmp_flag ~fzc
9dc2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9dc4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dc6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9dc7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9dc9 : 48              >            pha         ;use stack to load status
9dca : a980            >            lda #$80     ;precharge accu
9dcc : 28              >            plp
                        
9dcd : c11c                     cmp (ind1,x)
                                tst_a $80,fc
9dcf : 08              >            php         ;save flags
9dd0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9dd2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dd4 : 68              >            pla         ;load status
9dd5 : 48              >            pha
                       >            cmp_flag fc
9dd6 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9dd8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dda : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9ddb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9ddd : 48              >            pha         ;use stack to load status
9dde : a97f            >            lda #$7f     ;precharge accu
9de0 : 28              >            plp
                        
9de1 : c11c                     cmp (ind1,x)
                                tst_a $7f,fzc
9de3 : 08              >            php         ;save flags
9de4 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9de6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9de8 : 68              >            pla         ;load status
9de9 : 48              >            pha
                       >            cmp_flag fzc
9dea : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9dec : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dee : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9def : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9df1 : 48              >            pha         ;use stack to load status
9df2 : a97e            >            lda #$7e     ;precharge accu
9df4 : 28              >            plp
                        
9df5 : c11c                     cmp (ind1,x)
                                tst_a $7e,fn
9df7 : 08              >            php         ;save flags
9df8 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9dfa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9dfc : 68              >            pla         ;load status
9dfd : 48              >            pha
                       >            cmp_flag fn
9dfe : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e00 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e02 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9e03 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9e05 : 48              >            pha         ;use stack to load status
9e06 : a980            >            lda #$80     ;precharge accu
9e08 : 28              >            plp
                        
9e09 : c11c                     cmp (ind1,x)
                                tst_a $80,~fnz
9e0b : 08              >            php         ;save flags
9e0c : c980            >            cmp #$80     ;test result
                       >            trap_ne
9e0e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e10 : 68              >            pla         ;load status
9e11 : 48              >            pha
                       >            cmp_flag ~fnz
9e12 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e14 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e16 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9e17 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9e19 : 48              >            pha         ;use stack to load status
9e1a : a97f            >            lda #$7f     ;precharge accu
9e1c : 28              >            plp
                        
9e1d : c11c                     cmp (ind1,x)
                                tst_a $7f,~fn
9e1f : 08              >            php         ;save flags
9e20 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9e22 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e24 : 68              >            pla         ;load status
9e25 : 48              >            pha
                       >            cmp_flag ~fn
9e26 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e28 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e2a : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9e2b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9e2d : 48              >            pha         ;use stack to load status
9e2e : a97e            >            lda #$7e     ;precharge accu
9e30 : 28              >            plp
                        
9e31 : c11c                     cmp (ind1,x)
                                tst_a $7e,~fzc
9e33 : 08              >            php         ;save flags
9e34 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9e36 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e38 : 68              >            pla         ;load status
9e39 : 48              >            pha
                       >            cmp_flag ~fzc
9e3a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e3c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e3e : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
9e3f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9e41 : 48              >            pha         ;use stack to load status
9e42 : a980            >            lda #$80     ;precharge accu
9e44 : 28              >            plp
                        
9e45 : d11c                     cmp (ind1),y
                                tst_a $80,fc
9e47 : 08              >            php         ;save flags
9e48 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9e4a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e4c : 68              >            pla         ;load status
9e4d : 48              >            pha
                       >            cmp_flag fc
9e4e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e50 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e52 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
9e53 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9e55 : 48              >            pha         ;use stack to load status
9e56 : a97f            >            lda #$7f     ;precharge accu
9e58 : 28              >            plp
                        
9e59 : d11c                     cmp (ind1),y
                                tst_a $7f,fzc
9e5b : 08              >            php         ;save flags
9e5c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9e5e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e60 : 68              >            pla         ;load status
9e61 : 48              >            pha
                       >            cmp_flag fzc
9e62 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e64 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e66 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
9e67 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9e69 : 48              >            pha         ;use stack to load status
9e6a : a97e            >            lda #$7e     ;precharge accu
9e6c : 28              >            plp
                        
9e6d : d11c                     cmp (ind1),y
                                tst_a $7e,fn
9e6f : 08              >            php         ;save flags
9e70 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9e72 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e74 : 68              >            pla         ;load status
9e75 : 48              >            pha
                       >            cmp_flag fn
9e76 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e78 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e7a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
9e7b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9e7d : 48              >            pha         ;use stack to load status
9e7e : a980            >            lda #$80     ;precharge accu
9e80 : 28              >            plp
                        
9e81 : d11c                     cmp (ind1),y
                                tst_a $80,~fnz
9e83 : 08              >            php         ;save flags
9e84 : c980            >            cmp #$80     ;test result
                       >            trap_ne
9e86 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e88 : 68              >            pla         ;load status
9e89 : 48              >            pha
                       >            cmp_flag ~fnz
9e8a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9e8c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e8e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
9e8f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9e91 : 48              >            pha         ;use stack to load status
9e92 : a97f            >            lda #$7f     ;precharge accu
9e94 : 28              >            plp
                        
9e95 : d11c                     cmp (ind1),y
                                tst_a $7f,~fn
9e97 : 08              >            php         ;save flags
9e98 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
9e9a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9e9c : 68              >            pla         ;load status
9e9d : 48              >            pha
                       >            cmp_flag ~fn
9e9e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9ea0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ea2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
9ea3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9ea5 : 48              >            pha         ;use stack to load status
9ea6 : a97e            >            lda #$7e     ;precharge accu
9ea8 : 28              >            plp
                        
9ea9 : d11c                     cmp (ind1),y
                                tst_a $7e,~fzc
9eab : 08              >            php         ;save flags
9eac : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
9eae : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9eb0 : 68              >            pla         ;load status
9eb1 : 48              >            pha
                       >            cmp_flag ~fzc
9eb2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
9eb4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9eb6 : 28              >            plp         ;restore status
                        
                                next_test
9eb7 : ad0002          >            lda test_case   ;previous test
9eba : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
9ebc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
9ebe : a91d            >            lda #test_num   ;*** next tests' number
9ec0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
9ec3 : a205                     ldx #5
9ec5 :                  tasl
                                set_ax zps,0
                       >            load_flag 0
9ec5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9ec7 : 48              >            pha         ;use stack to load status
9ec8 : b509            >            lda zps,x    ;precharge accu
9eca : 28              >            plp
                        
9ecb : 0a                       asl a
                                tst_ax rASL,fASL,0
9ecc : 08              >            php         ;save flags
9ecd : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
9ed0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ed2 : 68              >            pla         ;load status
                       >            eor_flag 0
9ed3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9ed5 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
9ed8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9eda : ca                       dex
9edb : 10e8                     bpl tasl
9edd : a205                     ldx #5
9edf :                  tasl1
                                set_ax zps,$ff
                       >            load_flag $ff
9edf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9ee1 : 48              >            pha         ;use stack to load status
9ee2 : b509            >            lda zps,x    ;precharge accu
9ee4 : 28              >            plp
                        
9ee5 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
9ee6 : 08              >            php         ;save flags
9ee7 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
9eea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9eec : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9eed : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9eef : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
9ef2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9ef4 : ca                       dex
9ef5 : 10e8                     bpl tasl1
                        
9ef7 : a205                     ldx #5
9ef9 :                  tlsr
                                set_ax zps,0
                       >            load_flag 0
9ef9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9efb : 48              >            pha         ;use stack to load status
9efc : b509            >            lda zps,x    ;precharge accu
9efe : 28              >            plp
                        
9eff : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
9f00 : 08              >            php         ;save flags
9f01 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
9f04 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f06 : 68              >            pla         ;load status
                       >            eor_flag 0
9f07 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9f09 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
9f0c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f0e : ca                       dex
9f0f : 10e8                     bpl tlsr
9f11 : a205                     ldx #5
9f13 :                  tlsr1
                                set_ax zps,$ff
                       >            load_flag $ff
9f13 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9f15 : 48              >            pha         ;use stack to load status
9f16 : b509            >            lda zps,x    ;precharge accu
9f18 : 28              >            plp
                        
9f19 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
9f1a : 08              >            php         ;save flags
9f1b : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
9f1e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f20 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9f21 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9f23 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
9f26 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f28 : ca                       dex
9f29 : 10e8                     bpl tlsr1
                        
9f2b : a205                     ldx #5
9f2d :                  trol
                                set_ax zps,0
                       >            load_flag 0
9f2d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9f2f : 48              >            pha         ;use stack to load status
9f30 : b509            >            lda zps,x    ;precharge accu
9f32 : 28              >            plp
                        
9f33 : 2a                       rol a
                                tst_ax rROL,fROL,0
9f34 : 08              >            php         ;save flags
9f35 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
9f38 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f3a : 68              >            pla         ;load status
                       >            eor_flag 0
9f3b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9f3d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
9f40 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f42 : ca                       dex
9f43 : 10e8                     bpl trol
9f45 : a205                     ldx #5
9f47 :                  trol1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
9f47 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
9f49 : 48              >            pha         ;use stack to load status
9f4a : b509            >            lda zps,x    ;precharge accu
9f4c : 28              >            plp
                        
9f4d : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
9f4e : 08              >            php         ;save flags
9f4f : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
9f52 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f54 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9f55 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9f57 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
9f5a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f5c : ca                       dex
9f5d : 10e8                     bpl trol1
                        
9f5f : a205                     ldx #5
9f61 :                  trolc
                                set_ax zps,fc
                       >            load_flag fc
9f61 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
9f63 : 48              >            pha         ;use stack to load status
9f64 : b509            >            lda zps,x    ;precharge accu
9f66 : 28              >            plp
                        
9f67 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
9f68 : 08              >            php         ;save flags
9f69 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
9f6c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f6e : 68              >            pla         ;load status
                       >            eor_flag 0
9f6f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9f71 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
9f74 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f76 : ca                       dex
9f77 : 10e8                     bpl trolc
9f79 : a205                     ldx #5
9f7b :                  trolc1
                                set_ax zps,$ff
                       >            load_flag $ff
9f7b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9f7d : 48              >            pha         ;use stack to load status
9f7e : b509            >            lda zps,x    ;precharge accu
9f80 : 28              >            plp
                        
9f81 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
9f82 : 08              >            php         ;save flags
9f83 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
9f86 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9f88 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9f89 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9f8b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
9f8e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9f90 : ca                       dex
9f91 : 10e8                     bpl trolc1
                        
9f93 : a205                     ldx #5
9f95 :                  tror
                                set_ax zps,0
                       >            load_flag 0
9f95 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
9f97 : 48              >            pha         ;use stack to load status
9f98 : b509            >            lda zps,x    ;precharge accu
9f9a : 28              >            plp
                        
9f9b : 6a                       ror a
                                tst_ax rROR,fROR,0
9f9c : 08              >            php         ;save flags
9f9d : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
9fa0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9fa2 : 68              >            pla         ;load status
                       >            eor_flag 0
9fa3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9fa5 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
9fa8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9faa : ca                       dex
9fab : 10e8                     bpl tror
9fad : a205                     ldx #5
9faf :                  tror1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
9faf : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
9fb1 : 48              >            pha         ;use stack to load status
9fb2 : b509            >            lda zps,x    ;precharge accu
9fb4 : 28              >            plp
                        
9fb5 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
9fb6 : 08              >            php         ;save flags
9fb7 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
9fba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9fbc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9fbd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9fbf : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
9fc2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9fc4 : ca                       dex
9fc5 : 10e8                     bpl tror1
                        
9fc7 : a205                     ldx #5
9fc9 :                  trorc
                                set_ax zps,fc
                       >            load_flag fc
9fc9 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
9fcb : 48              >            pha         ;use stack to load status
9fcc : b509            >            lda zps,x    ;precharge accu
9fce : 28              >            plp
                        
9fcf : 6a                       ror a
                                tst_ax rRORc,fRORc,0
9fd0 : 08              >            php         ;save flags
9fd1 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
9fd4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9fd6 : 68              >            pla         ;load status
                       >            eor_flag 0
9fd7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
9fd9 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
9fdc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9fde : ca                       dex
9fdf : 10e8                     bpl trorc
9fe1 : a205                     ldx #5
9fe3 :                  trorc1
                                set_ax zps,$ff
                       >            load_flag $ff
9fe3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
9fe5 : 48              >            pha         ;use stack to load status
9fe6 : b509            >            lda zps,x    ;precharge accu
9fe8 : 28              >            plp
                        
9fe9 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
9fea : 08              >            php         ;save flags
9feb : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
9fee : d0fe            >        bne *         ;failed not equal (non zero)
                       >
9ff0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
9ff1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
9ff3 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
9ff6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
9ff8 : ca                       dex
9ff9 : 10e8                     bpl trorc1
                                next_test
9ffb : ad0002          >            lda test_case   ;previous test
9ffe : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a000 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
a002 : a91e            >            lda #test_num   ;*** next tests' number
a004 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
a007 : a205                     ldx #5
a009 :                  tasl2
                                set_z zps,0
                       >            load_flag 0
a009 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a00b : 48              >            pha         ;use stack to load status
a00c : b509            >            lda zps,x    ;load to zeropage
a00e : 8502            >            sta zpt
a010 : 28              >            plp
                        
a011 : 0602                     asl zpt
                                tst_z rASL,fASL,0
a013 : 08              >            php         ;save flags
a014 : a502            >            lda zpt
a016 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a019 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a01b : 68              >            pla         ;load status
                       >            eor_flag 0
a01c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a01e : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a021 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a023 : ca                       dex
a024 : 10e3                     bpl tasl2
a026 : a205                     ldx #5
a028 :                  tasl3
                                set_z zps,$ff
                       >            load_flag $ff
a028 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a02a : 48              >            pha         ;use stack to load status
a02b : b509            >            lda zps,x    ;load to zeropage
a02d : 8502            >            sta zpt
a02f : 28              >            plp
                        
a030 : 0602                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
a032 : 08              >            php         ;save flags
a033 : a502            >            lda zpt
a035 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a038 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a03a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a03b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a03d : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a040 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a042 : ca                       dex
a043 : 10e3                     bpl tasl3
                        
a045 : a205                     ldx #5
a047 :                  tlsr2
                                set_z zps,0
                       >            load_flag 0
a047 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a049 : 48              >            pha         ;use stack to load status
a04a : b509            >            lda zps,x    ;load to zeropage
a04c : 8502            >            sta zpt
a04e : 28              >            plp
                        
a04f : 4602                     lsr zpt
                                tst_z rLSR,fLSR,0
a051 : 08              >            php         ;save flags
a052 : a502            >            lda zpt
a054 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a057 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a059 : 68              >            pla         ;load status
                       >            eor_flag 0
a05a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a05c : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a05f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a061 : ca                       dex
a062 : 10e3                     bpl tlsr2
a064 : a205                     ldx #5
a066 :                  tlsr3
                                set_z zps,$ff
                       >            load_flag $ff
a066 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a068 : 48              >            pha         ;use stack to load status
a069 : b509            >            lda zps,x    ;load to zeropage
a06b : 8502            >            sta zpt
a06d : 28              >            plp
                        
a06e : 4602                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
a070 : 08              >            php         ;save flags
a071 : a502            >            lda zpt
a073 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a076 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a078 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a079 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a07b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a07e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a080 : ca                       dex
a081 : 10e3                     bpl tlsr3
                        
a083 : a205                     ldx #5
a085 :                  trol2
                                set_z zps,0
                       >            load_flag 0
a085 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a087 : 48              >            pha         ;use stack to load status
a088 : b509            >            lda zps,x    ;load to zeropage
a08a : 8502            >            sta zpt
a08c : 28              >            plp
                        
a08d : 2602                     rol zpt
                                tst_z rROL,fROL,0
a08f : 08              >            php         ;save flags
a090 : a502            >            lda zpt
a092 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a095 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a097 : 68              >            pla         ;load status
                       >            eor_flag 0
a098 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a09a : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a09d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a09f : ca                       dex
a0a0 : 10e3                     bpl trol2
a0a2 : a205                     ldx #5
a0a4 :                  trol3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
a0a4 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a0a6 : 48              >            pha         ;use stack to load status
a0a7 : b509            >            lda zps,x    ;load to zeropage
a0a9 : 8502            >            sta zpt
a0ab : 28              >            plp
                        
a0ac : 2602                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
a0ae : 08              >            php         ;save flags
a0af : a502            >            lda zpt
a0b1 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a0b4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a0b6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a0b7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a0b9 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a0bc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a0be : ca                       dex
a0bf : 10e3                     bpl trol3
                        
a0c1 : a205                     ldx #5
a0c3 :                  trolc2
                                set_z zps,fc
                       >            load_flag fc
a0c3 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a0c5 : 48              >            pha         ;use stack to load status
a0c6 : b509            >            lda zps,x    ;load to zeropage
a0c8 : 8502            >            sta zpt
a0ca : 28              >            plp
                        
a0cb : 2602                     rol zpt
                                tst_z rROLc,fROLc,0
a0cd : 08              >            php         ;save flags
a0ce : a502            >            lda zpt
a0d0 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a0d3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a0d5 : 68              >            pla         ;load status
                       >            eor_flag 0
a0d6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a0d8 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a0db : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a0dd : ca                       dex
a0de : 10e3                     bpl trolc2
a0e0 : a205                     ldx #5
a0e2 :                  trolc3
                                set_z zps,$ff
                       >            load_flag $ff
a0e2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a0e4 : 48              >            pha         ;use stack to load status
a0e5 : b509            >            lda zps,x    ;load to zeropage
a0e7 : 8502            >            sta zpt
a0e9 : 28              >            plp
                        
a0ea : 2602                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
a0ec : 08              >            php         ;save flags
a0ed : a502            >            lda zpt
a0ef : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a0f2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a0f4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a0f5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a0f7 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a0fa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a0fc : ca                       dex
a0fd : 10e3                     bpl trolc3
                        
a0ff : a205                     ldx #5
a101 :                  tror2
                                set_z zps,0
                       >            load_flag 0
a101 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a103 : 48              >            pha         ;use stack to load status
a104 : b509            >            lda zps,x    ;load to zeropage
a106 : 8502            >            sta zpt
a108 : 28              >            plp
                        
a109 : 6602                     ror zpt
                                tst_z rROR,fROR,0
a10b : 08              >            php         ;save flags
a10c : a502            >            lda zpt
a10e : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a111 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a113 : 68              >            pla         ;load status
                       >            eor_flag 0
a114 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a116 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a119 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a11b : ca                       dex
a11c : 10e3                     bpl tror2
a11e : a205                     ldx #5
a120 :                  tror3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
a120 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a122 : 48              >            pha         ;use stack to load status
a123 : b509            >            lda zps,x    ;load to zeropage
a125 : 8502            >            sta zpt
a127 : 28              >            plp
                        
a128 : 6602                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
a12a : 08              >            php         ;save flags
a12b : a502            >            lda zpt
a12d : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a130 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a132 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a133 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a135 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a138 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a13a : ca                       dex
a13b : 10e3                     bpl tror3
                        
a13d : a205                     ldx #5
a13f :                  trorc2
                                set_z zps,fc
                       >            load_flag fc
a13f : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a141 : 48              >            pha         ;use stack to load status
a142 : b509            >            lda zps,x    ;load to zeropage
a144 : 8502            >            sta zpt
a146 : 28              >            plp
                        
a147 : 6602                     ror zpt
                                tst_z rRORc,fRORc,0
a149 : 08              >            php         ;save flags
a14a : a502            >            lda zpt
a14c : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a14f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a151 : 68              >            pla         ;load status
                       >            eor_flag 0
a152 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a154 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a157 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a159 : ca                       dex
a15a : 10e3                     bpl trorc2
a15c : a205                     ldx #5
a15e :                  trorc3
                                set_z zps,$ff
                       >            load_flag $ff
a15e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a160 : 48              >            pha         ;use stack to load status
a161 : b509            >            lda zps,x    ;load to zeropage
a163 : 8502            >            sta zpt
a165 : 28              >            plp
                        
a166 : 6602                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
a168 : 08              >            php         ;save flags
a169 : a502            >            lda zpt
a16b : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a16e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a170 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a171 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a173 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a176 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a178 : ca                       dex
a179 : 10e3                     bpl trorc3
                                next_test
a17b : ad0002          >            lda test_case   ;previous test
a17e : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a180 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
a182 : a91f            >            lda #test_num   ;*** next tests' number
a184 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
a187 : a205                     ldx #5
a189 :                  tasl4
                                set_abs zps,0
                       >            load_flag 0
a189 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a18b : 48              >            pha         ;use stack to load status
a18c : b509            >            lda zps,x    ;load to memory
a18e : 8d0302          >            sta abst
a191 : 28              >            plp
                        
a192 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
a195 : 08              >            php         ;save flags
a196 : ad0302          >            lda abst
a199 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a19c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a19e : 68              >            pla         ;load status
                       >            eor_flag 0
a19f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a1a1 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a1a4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a1a6 : ca                       dex
a1a7 : 10e0                     bpl tasl4
a1a9 : a205                     ldx #5
a1ab :                  tasl5
                                set_abs zps,$ff
                       >            load_flag $ff
a1ab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a1ad : 48              >            pha         ;use stack to load status
a1ae : b509            >            lda zps,x    ;load to memory
a1b0 : 8d0302          >            sta abst
a1b3 : 28              >            plp
                        
a1b4 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
a1b7 : 08              >            php         ;save flags
a1b8 : ad0302          >            lda abst
a1bb : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a1be : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a1c0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a1c1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a1c3 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a1c6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a1c8 : ca                       dex
a1c9 : 10e0                     bpl tasl5
                        
a1cb : a205                     ldx #5
a1cd :                  tlsr4
                                set_abs zps,0
                       >            load_flag 0
a1cd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a1cf : 48              >            pha         ;use stack to load status
a1d0 : b509            >            lda zps,x    ;load to memory
a1d2 : 8d0302          >            sta abst
a1d5 : 28              >            plp
                        
a1d6 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
a1d9 : 08              >            php         ;save flags
a1da : ad0302          >            lda abst
a1dd : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a1e0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a1e2 : 68              >            pla         ;load status
                       >            eor_flag 0
a1e3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a1e5 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a1e8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a1ea : ca                       dex
a1eb : 10e0                     bpl tlsr4
a1ed : a205                     ldx #5
a1ef :                  tlsr5
                                set_abs zps,$ff
                       >            load_flag $ff
a1ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a1f1 : 48              >            pha         ;use stack to load status
a1f2 : b509            >            lda zps,x    ;load to memory
a1f4 : 8d0302          >            sta abst
a1f7 : 28              >            plp
                        
a1f8 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
a1fb : 08              >            php         ;save flags
a1fc : ad0302          >            lda abst
a1ff : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a202 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a204 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a205 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a207 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a20a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a20c : ca                       dex
a20d : 10e0                     bpl tlsr5
                        
a20f : a205                     ldx #5
a211 :                  trol4
                                set_abs zps,0
                       >            load_flag 0
a211 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a213 : 48              >            pha         ;use stack to load status
a214 : b509            >            lda zps,x    ;load to memory
a216 : 8d0302          >            sta abst
a219 : 28              >            plp
                        
a21a : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
a21d : 08              >            php         ;save flags
a21e : ad0302          >            lda abst
a221 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a224 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a226 : 68              >            pla         ;load status
                       >            eor_flag 0
a227 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a229 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a22c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a22e : ca                       dex
a22f : 10e0                     bpl trol4
a231 : a205                     ldx #5
a233 :                  trol5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
a233 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a235 : 48              >            pha         ;use stack to load status
a236 : b509            >            lda zps,x    ;load to memory
a238 : 8d0302          >            sta abst
a23b : 28              >            plp
                        
a23c : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
a23f : 08              >            php         ;save flags
a240 : ad0302          >            lda abst
a243 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a246 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a248 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a249 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a24b : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a24e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a250 : ca                       dex
a251 : 10e0                     bpl trol5
                        
a253 : a205                     ldx #5
a255 :                  trolc4
                                set_abs zps,fc
                       >            load_flag fc
a255 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a257 : 48              >            pha         ;use stack to load status
a258 : b509            >            lda zps,x    ;load to memory
a25a : 8d0302          >            sta abst
a25d : 28              >            plp
                        
a25e : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
a261 : 08              >            php         ;save flags
a262 : ad0302          >            lda abst
a265 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a268 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a26a : 68              >            pla         ;load status
                       >            eor_flag 0
a26b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a26d : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a270 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a272 : ca                       dex
a273 : 10e0                     bpl trolc4
a275 : a205                     ldx #5
a277 :                  trolc5
                                set_abs zps,$ff
                       >            load_flag $ff
a277 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a279 : 48              >            pha         ;use stack to load status
a27a : b509            >            lda zps,x    ;load to memory
a27c : 8d0302          >            sta abst
a27f : 28              >            plp
                        
a280 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
a283 : 08              >            php         ;save flags
a284 : ad0302          >            lda abst
a287 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a28a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a28c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a28d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a28f : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a292 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a294 : ca                       dex
a295 : 10e0                     bpl trolc5
                        
a297 : a205                     ldx #5
a299 :                  tror4
                                set_abs zps,0
                       >            load_flag 0
a299 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a29b : 48              >            pha         ;use stack to load status
a29c : b509            >            lda zps,x    ;load to memory
a29e : 8d0302          >            sta abst
a2a1 : 28              >            plp
                        
a2a2 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
a2a5 : 08              >            php         ;save flags
a2a6 : ad0302          >            lda abst
a2a9 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a2ac : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a2ae : 68              >            pla         ;load status
                       >            eor_flag 0
a2af : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a2b1 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a2b4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a2b6 : ca                       dex
a2b7 : 10e0                     bpl tror4
a2b9 : a205                     ldx #5
a2bb :                  tror5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
a2bb : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a2bd : 48              >            pha         ;use stack to load status
a2be : b509            >            lda zps,x    ;load to memory
a2c0 : 8d0302          >            sta abst
a2c3 : 28              >            plp
                        
a2c4 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
a2c7 : 08              >            php         ;save flags
a2c8 : ad0302          >            lda abst
a2cb : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a2ce : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a2d0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a2d1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a2d3 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a2d6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a2d8 : ca                       dex
a2d9 : 10e0                     bpl tror5
                        
a2db : a205                     ldx #5
a2dd :                  trorc4
                                set_abs zps,fc
                       >            load_flag fc
a2dd : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a2df : 48              >            pha         ;use stack to load status
a2e0 : b509            >            lda zps,x    ;load to memory
a2e2 : 8d0302          >            sta abst
a2e5 : 28              >            plp
                        
a2e6 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
a2e9 : 08              >            php         ;save flags
a2ea : ad0302          >            lda abst
a2ed : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a2f0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a2f2 : 68              >            pla         ;load status
                       >            eor_flag 0
a2f3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a2f5 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a2f8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a2fa : ca                       dex
a2fb : 10e0                     bpl trorc4
a2fd : a205                     ldx #5
a2ff :                  trorc5
                                set_abs zps,$ff
                       >            load_flag $ff
a2ff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a301 : 48              >            pha         ;use stack to load status
a302 : b509            >            lda zps,x    ;load to memory
a304 : 8d0302          >            sta abst
a307 : 28              >            plp
                        
a308 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
a30b : 08              >            php         ;save flags
a30c : ad0302          >            lda abst
a30f : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a312 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a314 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a315 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a317 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a31a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a31c : ca                       dex
a31d : 10e0                     bpl trorc5
                                next_test
a31f : ad0002          >            lda test_case   ;previous test
a322 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a324 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
a326 : a920            >            lda #test_num   ;*** next tests' number
a328 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
a32b : a205                     ldx #5
a32d :                  tasl6
                                set_zx zps,0
                       >            load_flag 0
a32d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a32f : 48              >            pha         ;use stack to load status
a330 : b509            >            lda zps,x    ;load to indexed zeropage
a332 : 9502            >            sta zpt,x
a334 : 28              >            plp
                        
a335 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,0
a337 : 08              >            php         ;save flags
a338 : b502            >            lda zpt,x
a33a : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a33d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a33f : 68              >            pla         ;load status
                       >            eor_flag 0
a340 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a342 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a345 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a347 : ca                       dex
a348 : 10e3                     bpl tasl6
a34a : a205                     ldx #5
a34c :                  tasl7
                                set_zx zps,$ff
                       >            load_flag $ff
a34c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a34e : 48              >            pha         ;use stack to load status
a34f : b509            >            lda zps,x    ;load to indexed zeropage
a351 : 9502            >            sta zpt,x
a353 : 28              >            plp
                        
a354 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
a356 : 08              >            php         ;save flags
a357 : b502            >            lda zpt,x
a359 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a35c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a35e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a35f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a361 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a364 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a366 : ca                       dex
a367 : 10e3                     bpl tasl7
                        
a369 : a205                     ldx #5
a36b :                  tlsr6
                                set_zx zps,0
                       >            load_flag 0
a36b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a36d : 48              >            pha         ;use stack to load status
a36e : b509            >            lda zps,x    ;load to indexed zeropage
a370 : 9502            >            sta zpt,x
a372 : 28              >            plp
                        
a373 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
a375 : 08              >            php         ;save flags
a376 : b502            >            lda zpt,x
a378 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a37b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a37d : 68              >            pla         ;load status
                       >            eor_flag 0
a37e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a380 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a383 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a385 : ca                       dex
a386 : 10e3                     bpl tlsr6
a388 : a205                     ldx #5
a38a :                  tlsr7
                                set_zx zps,$ff
                       >            load_flag $ff
a38a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a38c : 48              >            pha         ;use stack to load status
a38d : b509            >            lda zps,x    ;load to indexed zeropage
a38f : 9502            >            sta zpt,x
a391 : 28              >            plp
                        
a392 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
a394 : 08              >            php         ;save flags
a395 : b502            >            lda zpt,x
a397 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a39a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a39c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a39d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a39f : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a3a2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a3a4 : ca                       dex
a3a5 : 10e3                     bpl tlsr7
                        
a3a7 : a205                     ldx #5
a3a9 :                  trol6
                                set_zx zps,0
                       >            load_flag 0
a3a9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a3ab : 48              >            pha         ;use stack to load status
a3ac : b509            >            lda zps,x    ;load to indexed zeropage
a3ae : 9502            >            sta zpt,x
a3b0 : 28              >            plp
                        
a3b1 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,0
a3b3 : 08              >            php         ;save flags
a3b4 : b502            >            lda zpt,x
a3b6 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a3b9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a3bb : 68              >            pla         ;load status
                       >            eor_flag 0
a3bc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a3be : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a3c1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a3c3 : ca                       dex
a3c4 : 10e3                     bpl trol6
a3c6 : a205                     ldx #5
a3c8 :                  trol7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
a3c8 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a3ca : 48              >            pha         ;use stack to load status
a3cb : b509            >            lda zps,x    ;load to indexed zeropage
a3cd : 9502            >            sta zpt,x
a3cf : 28              >            plp
                        
a3d0 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
a3d2 : 08              >            php         ;save flags
a3d3 : b502            >            lda zpt,x
a3d5 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a3d8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a3da : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a3db : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a3dd : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a3e0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a3e2 : ca                       dex
a3e3 : 10e3                     bpl trol7
                        
a3e5 : a205                     ldx #5
a3e7 :                  trolc6
                                set_zx zps,fc
                       >            load_flag fc
a3e7 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a3e9 : 48              >            pha         ;use stack to load status
a3ea : b509            >            lda zps,x    ;load to indexed zeropage
a3ec : 9502            >            sta zpt,x
a3ee : 28              >            plp
                        
a3ef : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,0
a3f1 : 08              >            php         ;save flags
a3f2 : b502            >            lda zpt,x
a3f4 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a3f7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a3f9 : 68              >            pla         ;load status
                       >            eor_flag 0
a3fa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a3fc : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a3ff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a401 : ca                       dex
a402 : 10e3                     bpl trolc6
a404 : a205                     ldx #5
a406 :                  trolc7
                                set_zx zps,$ff
                       >            load_flag $ff
a406 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a408 : 48              >            pha         ;use stack to load status
a409 : b509            >            lda zps,x    ;load to indexed zeropage
a40b : 9502            >            sta zpt,x
a40d : 28              >            plp
                        
a40e : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
a410 : 08              >            php         ;save flags
a411 : b502            >            lda zpt,x
a413 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a416 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a418 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a419 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a41b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a41e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a420 : ca                       dex
a421 : 10e3                     bpl trolc7
                        
a423 : a205                     ldx #5
a425 :                  tror6
                                set_zx zps,0
                       >            load_flag 0
a425 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a427 : 48              >            pha         ;use stack to load status
a428 : b509            >            lda zps,x    ;load to indexed zeropage
a42a : 9502            >            sta zpt,x
a42c : 28              >            plp
                        
a42d : 7602                     ror zpt,x
                                tst_zx rROR,fROR,0
a42f : 08              >            php         ;save flags
a430 : b502            >            lda zpt,x
a432 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a435 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a437 : 68              >            pla         ;load status
                       >            eor_flag 0
a438 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a43a : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a43d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a43f : ca                       dex
a440 : 10e3                     bpl tror6
a442 : a205                     ldx #5
a444 :                  tror7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
a444 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a446 : 48              >            pha         ;use stack to load status
a447 : b509            >            lda zps,x    ;load to indexed zeropage
a449 : 9502            >            sta zpt,x
a44b : 28              >            plp
                        
a44c : 7602                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
a44e : 08              >            php         ;save flags
a44f : b502            >            lda zpt,x
a451 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a454 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a456 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a457 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a459 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a45c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a45e : ca                       dex
a45f : 10e3                     bpl tror7
                        
a461 : a205                     ldx #5
a463 :                  trorc6
                                set_zx zps,fc
                       >            load_flag fc
a463 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a465 : 48              >            pha         ;use stack to load status
a466 : b509            >            lda zps,x    ;load to indexed zeropage
a468 : 9502            >            sta zpt,x
a46a : 28              >            plp
                        
a46b : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,0
a46d : 08              >            php         ;save flags
a46e : b502            >            lda zpt,x
a470 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a473 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a475 : 68              >            pla         ;load status
                       >            eor_flag 0
a476 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a478 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a47b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a47d : ca                       dex
a47e : 10e3                     bpl trorc6
a480 : a205                     ldx #5
a482 :                  trorc7
                                set_zx zps,$ff
                       >            load_flag $ff
a482 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a484 : 48              >            pha         ;use stack to load status
a485 : b509            >            lda zps,x    ;load to indexed zeropage
a487 : 9502            >            sta zpt,x
a489 : 28              >            plp
                        
a48a : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
a48c : 08              >            php         ;save flags
a48d : b502            >            lda zpt,x
a48f : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a492 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a494 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a495 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a497 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a49a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a49c : ca                       dex
a49d : 10e3                     bpl trorc7
                                next_test
a49f : ad0002          >            lda test_case   ;previous test
a4a2 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a4a4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
a4a6 : a921            >            lda #test_num   ;*** next tests' number
a4a8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
a4ab : a205                     ldx #5
a4ad :                  tasl8
                                set_absx zps,0
                       >            load_flag 0
a4ad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a4af : 48              >            pha         ;use stack to load status
a4b0 : b509            >            lda zps,x    ;load to indexed memory
a4b2 : 9d0302          >            sta abst,x
a4b5 : 28              >            plp
                        
a4b6 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
a4b9 : 08              >            php         ;save flags
a4ba : bd0302          >            lda abst,x
a4bd : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a4c0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a4c2 : 68              >            pla         ;load status
                       >            eor_flag 0
a4c3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a4c5 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a4c8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a4ca : ca                       dex
a4cb : 10e0                     bpl tasl8
a4cd : a205                     ldx #5
a4cf :                  tasl9
                                set_absx zps,$ff
                       >            load_flag $ff
a4cf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a4d1 : 48              >            pha         ;use stack to load status
a4d2 : b509            >            lda zps,x    ;load to indexed memory
a4d4 : 9d0302          >            sta abst,x
a4d7 : 28              >            plp
                        
a4d8 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
a4db : 08              >            php         ;save flags
a4dc : bd0302          >            lda abst,x
a4df : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
a4e2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a4e4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a4e5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a4e7 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
a4ea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a4ec : ca                       dex
a4ed : 10e0                     bpl tasl9
                        
a4ef : a205                     ldx #5
a4f1 :                  tlsr8
                                set_absx zps,0
                       >            load_flag 0
a4f1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a4f3 : 48              >            pha         ;use stack to load status
a4f4 : b509            >            lda zps,x    ;load to indexed memory
a4f6 : 9d0302          >            sta abst,x
a4f9 : 28              >            plp
                        
a4fa : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
a4fd : 08              >            php         ;save flags
a4fe : bd0302          >            lda abst,x
a501 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a504 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a506 : 68              >            pla         ;load status
                       >            eor_flag 0
a507 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a509 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a50c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a50e : ca                       dex
a50f : 10e0                     bpl tlsr8
a511 : a205                     ldx #5
a513 :                  tlsr9
                                set_absx zps,$ff
                       >            load_flag $ff
a513 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a515 : 48              >            pha         ;use stack to load status
a516 : b509            >            lda zps,x    ;load to indexed memory
a518 : 9d0302          >            sta abst,x
a51b : 28              >            plp
                        
a51c : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
a51f : 08              >            php         ;save flags
a520 : bd0302          >            lda abst,x
a523 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
a526 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a528 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a529 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a52b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
a52e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a530 : ca                       dex
a531 : 10e0                     bpl tlsr9
                        
a533 : a205                     ldx #5
a535 :                  trol8
                                set_absx zps,0
                       >            load_flag 0
a535 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a537 : 48              >            pha         ;use stack to load status
a538 : b509            >            lda zps,x    ;load to indexed memory
a53a : 9d0302          >            sta abst,x
a53d : 28              >            plp
                        
a53e : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
a541 : 08              >            php         ;save flags
a542 : bd0302          >            lda abst,x
a545 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a548 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a54a : 68              >            pla         ;load status
                       >            eor_flag 0
a54b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a54d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a550 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a552 : ca                       dex
a553 : 10e0                     bpl trol8
a555 : a205                     ldx #5
a557 :                  trol9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
a557 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a559 : 48              >            pha         ;use stack to load status
a55a : b509            >            lda zps,x    ;load to indexed memory
a55c : 9d0302          >            sta abst,x
a55f : 28              >            plp
                        
a560 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
a563 : 08              >            php         ;save flags
a564 : bd0302          >            lda abst,x
a567 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
a56a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a56c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a56d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a56f : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
a572 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a574 : ca                       dex
a575 : 10e0                     bpl trol9
                        
a577 : a205                     ldx #5
a579 :                  trolc8
                                set_absx zps,fc
                       >            load_flag fc
a579 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a57b : 48              >            pha         ;use stack to load status
a57c : b509            >            lda zps,x    ;load to indexed memory
a57e : 9d0302          >            sta abst,x
a581 : 28              >            plp
                        
a582 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
a585 : 08              >            php         ;save flags
a586 : bd0302          >            lda abst,x
a589 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a58c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a58e : 68              >            pla         ;load status
                       >            eor_flag 0
a58f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a591 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a594 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a596 : ca                       dex
a597 : 10e0                     bpl trolc8
a599 : a205                     ldx #5
a59b :                  trolc9
                                set_absx zps,$ff
                       >            load_flag $ff
a59b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a59d : 48              >            pha         ;use stack to load status
a59e : b509            >            lda zps,x    ;load to indexed memory
a5a0 : 9d0302          >            sta abst,x
a5a3 : 28              >            plp
                        
a5a4 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
a5a7 : 08              >            php         ;save flags
a5a8 : bd0302          >            lda abst,x
a5ab : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
a5ae : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a5b0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a5b1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a5b3 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
a5b6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a5b8 : ca                       dex
a5b9 : 10e0                     bpl trolc9
                        
a5bb : a205                     ldx #5
a5bd :                  tror8
                                set_absx zps,0
                       >            load_flag 0
a5bd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a5bf : 48              >            pha         ;use stack to load status
a5c0 : b509            >            lda zps,x    ;load to indexed memory
a5c2 : 9d0302          >            sta abst,x
a5c5 : 28              >            plp
                        
a5c6 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
a5c9 : 08              >            php         ;save flags
a5ca : bd0302          >            lda abst,x
a5cd : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a5d0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a5d2 : 68              >            pla         ;load status
                       >            eor_flag 0
a5d3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a5d5 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a5d8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a5da : ca                       dex
a5db : 10e0                     bpl tror8
a5dd : a205                     ldx #5
a5df :                  tror9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
a5df : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
a5e1 : 48              >            pha         ;use stack to load status
a5e2 : b509            >            lda zps,x    ;load to indexed memory
a5e4 : 9d0302          >            sta abst,x
a5e7 : 28              >            plp
                        
a5e8 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
a5eb : 08              >            php         ;save flags
a5ec : bd0302          >            lda abst,x
a5ef : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
a5f2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a5f4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a5f5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a5f7 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
a5fa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a5fc : ca                       dex
a5fd : 10e0                     bpl tror9
                        
a5ff : a205                     ldx #5
a601 :                  trorc8
                                set_absx zps,fc
                       >            load_flag fc
a601 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
a603 : 48              >            pha         ;use stack to load status
a604 : b509            >            lda zps,x    ;load to indexed memory
a606 : 9d0302          >            sta abst,x
a609 : 28              >            plp
                        
a60a : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
a60d : 08              >            php         ;save flags
a60e : bd0302          >            lda abst,x
a611 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a614 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a616 : 68              >            pla         ;load status
                       >            eor_flag 0
a617 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a619 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a61c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a61e : ca                       dex
a61f : 10e0                     bpl trorc8
a621 : a205                     ldx #5
a623 :                  trorc9
                                set_absx zps,$ff
                       >            load_flag $ff
a623 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a625 : 48              >            pha         ;use stack to load status
a626 : b509            >            lda zps,x    ;load to indexed memory
a628 : 9d0302          >            sta abst,x
a62b : 28              >            plp
                        
a62c : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
a62f : 08              >            php         ;save flags
a630 : bd0302          >            lda abst,x
a633 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
a636 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a638 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
a639 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
a63b : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
a63e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a640 : ca                       dex
a641 : 10e0                     bpl trorc9
                                next_test
a643 : ad0002          >            lda test_case   ;previous test
a646 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a648 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
a64a : a922            >            lda #test_num   ;*** next tests' number
a64c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
a64f : a200                     ldx #0
a651 : a97e                     lda #$7e
a653 : 8502                     sta zpt
a655 :                  tinc    
                                set_stat 0
                       >            load_flag 0
a655 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a657 : 48              >            pha         ;use stack to load status
a658 : 28              >            plp
                        
a659 : e602                     inc zpt
                                tst_z rINC,fINC,0
a65b : 08              >            php         ;save flags
a65c : a502            >            lda zpt
a65e : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a661 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a663 : 68              >            pla         ;load status
                       >            eor_flag 0
a664 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a666 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a669 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a66b : e8                       inx
a66c : e002                     cpx #2
a66e : d004                     bne tinc1
a670 : a9fe                     lda #$fe
a672 : 8502                     sta zpt
a674 : e005             tinc1   cpx #5
a676 : d0dd                     bne tinc
a678 : ca                       dex
a679 : e602                     inc zpt
a67b :                  tdec    
                                set_stat 0
                       >            load_flag 0
a67b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a67d : 48              >            pha         ;use stack to load status
a67e : 28              >            plp
                        
a67f : c602                     dec zpt
                                tst_z rINC,fINC,0
a681 : 08              >            php         ;save flags
a682 : a502            >            lda zpt
a684 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a687 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a689 : 68              >            pla         ;load status
                       >            eor_flag 0
a68a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a68c : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a68f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a691 : ca                       dex
a692 : 300a                     bmi tdec1
a694 : e001                     cpx #1
a696 : d0e3                     bne tdec
a698 : a981                     lda #$81
a69a : 8502                     sta zpt
a69c : d0dd                     bne tdec
a69e :                  tdec1
a69e : a200                     ldx #0
a6a0 : a97e                     lda #$7e
a6a2 : 8502                     sta zpt
a6a4 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
a6a4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a6a6 : 48              >            pha         ;use stack to load status
a6a7 : 28              >            plp
                        
a6a8 : e602                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
a6aa : 08              >            php         ;save flags
a6ab : a502            >            lda zpt
a6ad : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a6b0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a6b2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a6b3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a6b5 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a6b8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a6ba : e8                       inx
a6bb : e002                     cpx #2
a6bd : d004                     bne tinc11
a6bf : a9fe                     lda #$fe
a6c1 : 8502                     sta zpt
a6c3 : e005             tinc11  cpx #5
a6c5 : d0dd                     bne tinc10
a6c7 : ca                       dex
a6c8 : e602                     inc zpt
a6ca :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
a6ca : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a6cc : 48              >            pha         ;use stack to load status
a6cd : 28              >            plp
                        
a6ce : c602                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
a6d0 : 08              >            php         ;save flags
a6d1 : a502            >            lda zpt
a6d3 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a6d6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a6d8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a6d9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a6db : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a6de : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a6e0 : ca                       dex
a6e1 : 300a                     bmi tdec11
a6e3 : e001                     cpx #1
a6e5 : d0e3                     bne tdec10
a6e7 : a981                     lda #$81
a6e9 : 8502                     sta zpt
a6eb : d0dd                     bne tdec10
a6ed :                  tdec11
                                next_test
a6ed : ad0002          >            lda test_case   ;previous test
a6f0 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a6f2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
a6f4 : a923            >            lda #test_num   ;*** next tests' number
a6f6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
a6f9 : a200                     ldx #0
a6fb : a97e                     lda #$7e
a6fd : 8d0302                   sta abst
a700 :                  tinc2    
                                set_stat 0
                       >            load_flag 0
a700 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a702 : 48              >            pha         ;use stack to load status
a703 : 28              >            plp
                        
a704 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
a707 : 08              >            php         ;save flags
a708 : ad0302          >            lda abst
a70b : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a70e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a710 : 68              >            pla         ;load status
                       >            eor_flag 0
a711 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a713 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a716 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a718 : e8                       inx
a719 : e002                     cpx #2
a71b : d005                     bne tinc3
a71d : a9fe                     lda #$fe
a71f : 8d0302                   sta abst
a722 : e005             tinc3   cpx #5
a724 : d0da                     bne tinc2
a726 : ca                       dex
a727 : ee0302                   inc abst
a72a :                  tdec2    
                                set_stat 0
                       >            load_flag 0
a72a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a72c : 48              >            pha         ;use stack to load status
a72d : 28              >            plp
                        
a72e : ce0302                   dec abst
                                tst_abs rINC,fINC,0
a731 : 08              >            php         ;save flags
a732 : ad0302          >            lda abst
a735 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a738 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a73a : 68              >            pla         ;load status
                       >            eor_flag 0
a73b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a73d : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a740 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a742 : ca                       dex
a743 : 300b                     bmi tdec3
a745 : e001                     cpx #1
a747 : d0e1                     bne tdec2
a749 : a981                     lda #$81
a74b : 8d0302                   sta abst
a74e : d0da                     bne tdec2
a750 :                  tdec3
a750 : a200                     ldx #0
a752 : a97e                     lda #$7e
a754 : 8d0302                   sta abst
a757 :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
a757 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a759 : 48              >            pha         ;use stack to load status
a75a : 28              >            plp
                        
a75b : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
a75e : 08              >            php         ;save flags
a75f : ad0302          >            lda abst
a762 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a765 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a767 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a768 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a76a : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a76d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a76f : e8                       inx
a770 : e002                     cpx #2
a772 : d005                     bne tinc13
a774 : a9fe                     lda #$fe
a776 : 8d0302                   sta abst
a779 : e005             tinc13   cpx #5
a77b : d0da                     bne tinc12
a77d : ca                       dex
a77e : ee0302                   inc abst
a781 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
a781 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a783 : 48              >            pha         ;use stack to load status
a784 : 28              >            plp
                        
a785 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
a788 : 08              >            php         ;save flags
a789 : ad0302          >            lda abst
a78c : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a78f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a791 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a792 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a794 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a797 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a799 : ca                       dex
a79a : 300b                     bmi tdec13
a79c : e001                     cpx #1
a79e : d0e1                     bne tdec12
a7a0 : a981                     lda #$81
a7a2 : 8d0302                   sta abst
a7a5 : d0da                     bne tdec12
a7a7 :                  tdec13
                                next_test
a7a7 : ad0002          >            lda test_case   ;previous test
a7aa : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a7ac : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
a7ae : a924            >            lda #test_num   ;*** next tests' number
a7b0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
a7b3 : a200                     ldx #0
a7b5 : a97e                     lda #$7e
a7b7 : 9502             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
a7b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a7bb : 48              >            pha         ;use stack to load status
a7bc : 28              >            plp
                        
a7bd : f602                     inc zpt,x
                                tst_zx rINC,fINC,0
a7bf : 08              >            php         ;save flags
a7c0 : b502            >            lda zpt,x
a7c2 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a7c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a7c7 : 68              >            pla         ;load status
                       >            eor_flag 0
a7c8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a7ca : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a7cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a7cf : b502                     lda zpt,x
a7d1 : e8                       inx
a7d2 : e002                     cpx #2
a7d4 : d002                     bne tinc5
a7d6 : a9fe                     lda #$fe
a7d8 : e005             tinc5   cpx #5
a7da : d0db                     bne tinc4
a7dc : ca                       dex
a7dd : a902                     lda #2
a7df : 9502             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
a7e1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a7e3 : 48              >            pha         ;use stack to load status
a7e4 : 28              >            plp
                        
a7e5 : d602                     dec zpt,x
                                tst_zx rINC,fINC,0
a7e7 : 08              >            php         ;save flags
a7e8 : b502            >            lda zpt,x
a7ea : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a7ed : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a7ef : 68              >            pla         ;load status
                       >            eor_flag 0
a7f0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a7f2 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a7f5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a7f7 : b502                     lda zpt,x
a7f9 : ca                       dex
a7fa : 3008                     bmi tdec5
a7fc : e001                     cpx #1
a7fe : d0df                     bne tdec4
a800 : a981                     lda #$81
a802 : d0db                     bne tdec4
a804 :                  tdec5
a804 : a200                     ldx #0
a806 : a97e                     lda #$7e
a808 : 9502             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
a80a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a80c : 48              >            pha         ;use stack to load status
a80d : 28              >            plp
                        
a80e : f602                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
a810 : 08              >            php         ;save flags
a811 : b502            >            lda zpt,x
a813 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a816 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a818 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a819 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a81b : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a81e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a820 : b502                     lda zpt,x
a822 : e8                       inx
a823 : e002                     cpx #2
a825 : d002                     bne tinc15
a827 : a9fe                     lda #$fe
a829 : e005             tinc15  cpx #5
a82b : d0db                     bne tinc14
a82d : ca                       dex
a82e : a902                     lda #2
a830 : 9502             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
a832 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a834 : 48              >            pha         ;use stack to load status
a835 : 28              >            plp
                        
a836 : d602                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
a838 : 08              >            php         ;save flags
a839 : b502            >            lda zpt,x
a83b : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a83e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a840 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a841 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a843 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a846 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a848 : b502                     lda zpt,x
a84a : ca                       dex
a84b : 3008                     bmi tdec15
a84d : e001                     cpx #1
a84f : d0df                     bne tdec14
a851 : a981                     lda #$81
a853 : d0db                     bne tdec14
a855 :                  tdec15
                                next_test
a855 : ad0002          >            lda test_case   ;previous test
a858 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a85a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
a85c : a925            >            lda #test_num   ;*** next tests' number
a85e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
a861 : a200                     ldx #0
a863 : a97e                     lda #$7e
a865 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
a868 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a86a : 48              >            pha         ;use stack to load status
a86b : 28              >            plp
                        
a86c : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
a86f : 08              >            php         ;save flags
a870 : bd0302          >            lda abst,x
a873 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a876 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a878 : 68              >            pla         ;load status
                       >            eor_flag 0
a879 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a87b : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a87e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a880 : bd0302                   lda abst,x
a883 : e8                       inx
a884 : e002                     cpx #2
a886 : d002                     bne tinc7
a888 : a9fe                     lda #$fe
a88a : e005             tinc7   cpx #5
a88c : d0d7                     bne tinc6
a88e : ca                       dex
a88f : a902                     lda #2
a891 : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
a894 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a896 : 48              >            pha         ;use stack to load status
a897 : 28              >            plp
                        
a898 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
a89b : 08              >            php         ;save flags
a89c : bd0302          >            lda abst,x
a89f : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a8a2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a8a4 : 68              >            pla         ;load status
                       >            eor_flag 0
a8a5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a8a7 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a8aa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a8ac : bd0302                   lda abst,x
a8af : ca                       dex
a8b0 : 3008                     bmi tdec7
a8b2 : e001                     cpx #1
a8b4 : d0db                     bne tdec6
a8b6 : a981                     lda #$81
a8b8 : d0d7                     bne tdec6
a8ba :                  tdec7
a8ba : a200                     ldx #0
a8bc : a97e                     lda #$7e
a8be : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
a8c1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a8c3 : 48              >            pha         ;use stack to load status
a8c4 : 28              >            plp
                        
a8c5 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
a8c8 : 08              >            php         ;save flags
a8c9 : bd0302          >            lda abst,x
a8cc : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a8cf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a8d1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a8d2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a8d4 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a8d7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a8d9 : bd0302                   lda abst,x
a8dc : e8                       inx
a8dd : e002                     cpx #2
a8df : d002                     bne tinc17
a8e1 : a9fe                     lda #$fe
a8e3 : e005             tinc17  cpx #5
a8e5 : d0d7                     bne tinc16
a8e7 : ca                       dex
a8e8 : a902                     lda #2
a8ea : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
a8ed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a8ef : 48              >            pha         ;use stack to load status
a8f0 : 28              >            plp
                        
a8f1 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
a8f4 : 08              >            php         ;save flags
a8f5 : bd0302          >            lda abst,x
a8f8 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
a8fb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a8fd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a8fe : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a900 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
a903 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a905 : bd0302                   lda abst,x
a908 : ca                       dex
a909 : 3008                     bmi tdec17
a90b : e001                     cpx #1
a90d : d0db                     bne tdec16
a90f : a981                     lda #$81
a911 : d0d7                     bne tdec16
a913 :                  tdec17
                                next_test
a913 : ad0002          >            lda test_case   ;previous test
a916 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
a918 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
a91a : a926            >            lda #test_num   ;*** next tests' number
a91c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
a91f : a203                     ldx #3          ;immediate
a921 : b514             tand    lda zpAN,x
a923 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
a926 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a928 : 48              >            pha         ;use stack to load status
a929 : bd6b02          >            lda absANa,x    ;precharge accu
a92c : 28              >            plp
                        
a92d : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
a930 : 08              >            php         ;save flags
a931 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a934 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a936 : 68              >            pla         ;load status
                       >            eor_flag 0
a937 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a939 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a93c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a93e : ca                       dex
a93f : 10e0                     bpl tand
a941 : a203                     ldx #3
a943 : b514             tand1   lda zpAN,x
a945 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
a948 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a94a : 48              >            pha         ;use stack to load status
a94b : bd6b02          >            lda absANa,x    ;precharge accu
a94e : 28              >            plp
                        
a94f : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
a952 : 08              >            php         ;save flags
a953 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a956 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a958 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a959 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a95b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a95e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a960 : ca                       dex
a961 : 10e0                     bpl tand1
                            
a963 : a203                     ldx #3      ;zp
a965 : b514             tand2   lda zpAN,x
a967 : 8502                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
a969 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a96b : 48              >            pha         ;use stack to load status
a96c : bd6b02          >            lda absANa,x    ;precharge accu
a96f : 28              >            plp
                        
a970 : 2502                     and zpt
                                tst_ax  absrlo,absflo,0
a972 : 08              >            php         ;save flags
a973 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a976 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a978 : 68              >            pla         ;load status
                       >            eor_flag 0
a979 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a97b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a97e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a980 : ca                       dex
a981 : 10e2                     bpl tand2
a983 : a203                     ldx #3
a985 : b514             tand3   lda zpAN,x
a987 : 8502                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
a989 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a98b : 48              >            pha         ;use stack to load status
a98c : bd6b02          >            lda absANa,x    ;precharge accu
a98f : 28              >            plp
                        
a990 : 2502                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
a992 : 08              >            php         ;save flags
a993 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a996 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a998 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a999 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a99b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a99e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a9a0 : ca                       dex
a9a1 : 10e2                     bpl tand3
                        
a9a3 : a203                     ldx #3      ;abs
a9a5 : b514             tand4   lda zpAN,x
a9a7 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
a9aa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a9ac : 48              >            pha         ;use stack to load status
a9ad : bd6b02          >            lda absANa,x    ;precharge accu
a9b0 : 28              >            plp
                        
a9b1 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
a9b4 : 08              >            php         ;save flags
a9b5 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a9b8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a9ba : 68              >            pla         ;load status
                       >            eor_flag 0
a9bb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a9bd : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a9c0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a9c2 : ca                       dex
a9c3 : 10e0                     bpl tand4
a9c5 : a203                     ldx #3
a9c7 : b514             tand5   lda zpAN,x
a9c9 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
a9cc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
a9ce : 48              >            pha         ;use stack to load status
a9cf : bd6b02          >            lda absANa,x    ;precharge accu
a9d2 : 28              >            plp
                        
a9d3 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
a9d6 : 08              >            php         ;save flags
a9d7 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a9da : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a9dc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
a9dd : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
a9df : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a9e2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
a9e4 : ca                       dex
a9e5 : 1002                     bpl tand6
                        
a9e7 : a203                     ldx #3      ;zp,x
a9e9 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
a9e9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
a9eb : 48              >            pha         ;use stack to load status
a9ec : bd6b02          >            lda absANa,x    ;precharge accu
a9ef : 28              >            plp
                        
a9f0 : 3514                     and zpAN,x
                                tst_ax  absrlo,absflo,0
a9f2 : 08              >            php         ;save flags
a9f3 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
a9f6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
a9f8 : 68              >            pla         ;load status
                       >            eor_flag 0
a9f9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
a9fb : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
a9fe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa00 : ca                       dex
aa01 : 10e6                     bpl tand6
aa03 : a203                     ldx #3
aa05 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
aa05 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aa07 : 48              >            pha         ;use stack to load status
aa08 : bd6b02          >            lda absANa,x    ;precharge accu
aa0b : 28              >            plp
                        
aa0c : 3514                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
aa0e : 08              >            php         ;save flags
aa0f : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aa12 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa14 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aa15 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aa17 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aa1a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa1c : ca                       dex
aa1d : 10e6                     bpl tand7
                        
aa1f : a203                     ldx #3      ;abs,x
aa21 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
aa21 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aa23 : 48              >            pha         ;use stack to load status
aa24 : bd6b02          >            lda absANa,x    ;precharge accu
aa27 : 28              >            plp
                        
aa28 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
aa2b : 08              >            php         ;save flags
aa2c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aa2f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa31 : 68              >            pla         ;load status
                       >            eor_flag 0
aa32 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aa34 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aa37 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa39 : ca                       dex
aa3a : 10e5                     bpl tand8
aa3c : a203                     ldx #3
aa3e :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
aa3e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aa40 : 48              >            pha         ;use stack to load status
aa41 : bd6b02          >            lda absANa,x    ;precharge accu
aa44 : 28              >            plp
                        
aa45 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
aa48 : 08              >            php         ;save flags
aa49 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
aa4c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa4e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aa4f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aa51 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
aa54 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa56 : ca                       dex
aa57 : 10e5                     bpl tand9
                        
aa59 : a003                     ldy #3      ;abs,y
aa5b :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
aa5b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aa5d : 48              >            pha         ;use stack to load status
aa5e : b96b02          >            lda absANa,y    ;precharge accu
aa61 : 28              >            plp
                        
aa62 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
aa65 : 08              >            php         ;save flags
aa66 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aa69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa6b : 68              >            pla         ;load status
                       >            eor_flag 0
aa6c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aa6e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aa71 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa73 : 88                       dey
aa74 : 10e5                     bpl tand10
aa76 : a003                     ldy #3
aa78 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
aa78 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aa7a : 48              >            pha         ;use stack to load status
aa7b : b96b02          >            lda absANa,y    ;precharge accu
aa7e : 28              >            plp
                        
aa7f : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
aa82 : 08              >            php         ;save flags
aa83 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aa86 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aa88 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aa89 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aa8b : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aa8e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aa90 : 88                       dey
aa91 : 10e5                     bpl tand11
                        
aa93 : a206                     ldx #6      ;(zp,x)
aa95 : a003                     ldy #3
aa97 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
aa97 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aa99 : 48              >            pha         ;use stack to load status
aa9a : b96b02          >            lda absANa,y    ;precharge accu
aa9d : 28              >            plp
                        
aa9e : 2132                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
aaa0 : 08              >            php         ;save flags
aaa1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aaa4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aaa6 : 68              >            pla         ;load status
                       >            eor_flag 0
aaa7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aaa9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aaac : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aaae : ca                       dex
aaaf : ca                       dex
aab0 : 88                       dey
aab1 : 10e4                     bpl tand12
aab3 : a206                     ldx #6
aab5 : a003                     ldy #3
aab7 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
aab7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aab9 : 48              >            pha         ;use stack to load status
aaba : b96b02          >            lda absANa,y    ;precharge accu
aabd : 28              >            plp
                        
aabe : 2132                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
aac0 : 08              >            php         ;save flags
aac1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aac4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aac6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aac7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aac9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aacc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aace : ca                       dex
aacf : ca                       dex
aad0 : 88                       dey
aad1 : 10e4                     bpl tand13
                        
aad3 : a003                     ldy #3      ;(zp),y
aad5 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
aad5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aad7 : 48              >            pha         ;use stack to load status
aad8 : b96b02          >            lda absANa,y    ;precharge accu
aadb : 28              >            plp
                        
aadc : 3132                     and (indAN),y
                                tst_ay  absrlo,absflo,0
aade : 08              >            php         ;save flags
aadf : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aae2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aae4 : 68              >            pla         ;load status
                       >            eor_flag 0
aae5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aae7 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aaea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aaec : 88                       dey
aaed : 10e6                     bpl tand14
aaef : a003                     ldy #3
aaf1 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
aaf1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aaf3 : 48              >            pha         ;use stack to load status
aaf4 : b96b02          >            lda absANa,y    ;precharge accu
aaf7 : 28              >            plp
                        
aaf8 : 3132                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
aafa : 08              >            php         ;save flags
aafb : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aafe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab00 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ab01 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ab03 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ab06 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab08 : 88                       dey
ab09 : 10e6                     bpl tand15
                                next_test
ab0b : ad0002          >            lda test_case   ;previous test
ab0e : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
ab10 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
ab12 : a927            >            lda #test_num   ;*** next tests' number
ab14 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
ab17 : a203                     ldx #3          ;immediate - self modifying code
ab19 : b518             teor    lda zpEO,x
ab1b : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
ab1e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ab20 : 48              >            pha         ;use stack to load status
ab21 : bd6f02          >            lda absEOa,x    ;precharge accu
ab24 : 28              >            plp
                        
ab25 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
ab28 : 08              >            php         ;save flags
ab29 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ab2c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab2e : 68              >            pla         ;load status
                       >            eor_flag 0
ab2f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ab31 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ab34 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab36 : ca                       dex
ab37 : 10e0                     bpl teor
ab39 : a203                     ldx #3
ab3b : b518             teor1   lda zpEO,x
ab3d : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ab40 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ab42 : 48              >            pha         ;use stack to load status
ab43 : bd6f02          >            lda absEOa,x    ;precharge accu
ab46 : 28              >            plp
                        
ab47 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
ab4a : 08              >            php         ;save flags
ab4b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ab4e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab50 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ab51 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ab53 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ab56 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab58 : ca                       dex
ab59 : 10e0                     bpl teor1
                            
ab5b : a203                     ldx #3      ;zp
ab5d : b518             teor2    lda zpEO,x
ab5f : 8502                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
ab61 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ab63 : 48              >            pha         ;use stack to load status
ab64 : bd6f02          >            lda absEOa,x    ;precharge accu
ab67 : 28              >            plp
                        
ab68 : 4502                     eor zpt
                                tst_ax  absrlo,absflo,0
ab6a : 08              >            php         ;save flags
ab6b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ab6e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab70 : 68              >            pla         ;load status
                       >            eor_flag 0
ab71 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ab73 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ab76 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab78 : ca                       dex
ab79 : 10e2                     bpl teor2
ab7b : a203                     ldx #3
ab7d : b518             teor3   lda zpEO,x
ab7f : 8502                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ab81 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ab83 : 48              >            pha         ;use stack to load status
ab84 : bd6f02          >            lda absEOa,x    ;precharge accu
ab87 : 28              >            plp
                        
ab88 : 4502                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
ab8a : 08              >            php         ;save flags
ab8b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ab8e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ab90 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ab91 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ab93 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ab96 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ab98 : ca                       dex
ab99 : 10e2                     bpl teor3
                        
ab9b : a203                     ldx #3      ;abs
ab9d : b518             teor4   lda zpEO,x
ab9f : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
aba2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aba4 : 48              >            pha         ;use stack to load status
aba5 : bd6f02          >            lda absEOa,x    ;precharge accu
aba8 : 28              >            plp
                        
aba9 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
abac : 08              >            php         ;save flags
abad : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
abb0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
abb2 : 68              >            pla         ;load status
                       >            eor_flag 0
abb3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
abb5 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
abb8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
abba : ca                       dex
abbb : 10e0                     bpl teor4
abbd : a203                     ldx #3
abbf : b518             teor5   lda zpEO,x
abc1 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
abc4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
abc6 : 48              >            pha         ;use stack to load status
abc7 : bd6f02          >            lda absEOa,x    ;precharge accu
abca : 28              >            plp
                        
abcb : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
abce : 08              >            php         ;save flags
abcf : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
abd2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
abd4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
abd5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
abd7 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
abda : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
abdc : ca                       dex
abdd : 1002                     bpl teor6
                        
abdf : a203                     ldx #3      ;zp,x
abe1 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
abe1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
abe3 : 48              >            pha         ;use stack to load status
abe4 : bd6f02          >            lda absEOa,x    ;precharge accu
abe7 : 28              >            plp
                        
abe8 : 5518                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
abea : 08              >            php         ;save flags
abeb : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
abee : d0fe            >        bne *         ;failed not equal (non zero)
                       >
abf0 : 68              >            pla         ;load status
                       >            eor_flag 0
abf1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
abf3 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
abf6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
abf8 : ca                       dex
abf9 : 10e6                     bpl teor6
abfb : a203                     ldx #3
abfd :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
abfd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
abff : 48              >            pha         ;use stack to load status
ac00 : bd6f02          >            lda absEOa,x    ;precharge accu
ac03 : 28              >            plp
                        
ac04 : 5518                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
ac06 : 08              >            php         ;save flags
ac07 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ac0a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac0c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ac0d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ac0f : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ac12 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac14 : ca                       dex
ac15 : 10e6                     bpl teor7
                        
ac17 : a203                     ldx #3      ;abs,x
ac19 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
ac19 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ac1b : 48              >            pha         ;use stack to load status
ac1c : bd6f02          >            lda absEOa,x    ;precharge accu
ac1f : 28              >            plp
                        
ac20 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
ac23 : 08              >            php         ;save flags
ac24 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ac27 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac29 : 68              >            pla         ;load status
                       >            eor_flag 0
ac2a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ac2c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ac2f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac31 : ca                       dex
ac32 : 10e5                     bpl teor8
ac34 : a203                     ldx #3
ac36 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ac36 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ac38 : 48              >            pha         ;use stack to load status
ac39 : bd6f02          >            lda absEOa,x    ;precharge accu
ac3c : 28              >            plp
                        
ac3d : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
ac40 : 08              >            php         ;save flags
ac41 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ac44 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac46 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ac47 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ac49 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ac4c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac4e : ca                       dex
ac4f : 10e5                     bpl teor9
                        
ac51 : a003                     ldy #3      ;abs,y
ac53 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
ac53 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ac55 : 48              >            pha         ;use stack to load status
ac56 : b96f02          >            lda absEOa,y    ;precharge accu
ac59 : 28              >            plp
                        
ac5a : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
ac5d : 08              >            php         ;save flags
ac5e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ac61 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac63 : 68              >            pla         ;load status
                       >            eor_flag 0
ac64 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ac66 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ac69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac6b : 88                       dey
ac6c : 10e5                     bpl teor10
ac6e : a003                     ldy #3
ac70 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
ac70 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ac72 : 48              >            pha         ;use stack to load status
ac73 : b96f02          >            lda absEOa,y    ;precharge accu
ac76 : 28              >            plp
                        
ac77 : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
ac7a : 08              >            php         ;save flags
ac7b : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ac7e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac80 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ac81 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ac83 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ac86 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ac88 : 88                       dey
ac89 : 10e5                     bpl teor11
                        
ac8b : a206                     ldx #6      ;(zp,x)
ac8d : a003                     ldy #3
ac8f :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
ac8f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ac91 : 48              >            pha         ;use stack to load status
ac92 : b96f02          >            lda absEOa,y    ;precharge accu
ac95 : 28              >            plp
                        
ac96 : 413a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
ac98 : 08              >            php         ;save flags
ac99 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ac9c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ac9e : 68              >            pla         ;load status
                       >            eor_flag 0
ac9f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aca1 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aca4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aca6 : ca                       dex
aca7 : ca                       dex
aca8 : 88                       dey
aca9 : 10e4                     bpl teor12
acab : a206                     ldx #6
acad : a003                     ldy #3
acaf :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
acaf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
acb1 : 48              >            pha         ;use stack to load status
acb2 : b96f02          >            lda absEOa,y    ;precharge accu
acb5 : 28              >            plp
                        
acb6 : 413a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
acb8 : 08              >            php         ;save flags
acb9 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
acbc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
acbe : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
acbf : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
acc1 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
acc4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
acc6 : ca                       dex
acc7 : ca                       dex
acc8 : 88                       dey
acc9 : 10e4                     bpl teor13
                        
accb : a003                     ldy #3      ;(zp),y
accd :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
accd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
accf : 48              >            pha         ;use stack to load status
acd0 : b96f02          >            lda absEOa,y    ;precharge accu
acd3 : 28              >            plp
                        
acd4 : 513a                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
acd6 : 08              >            php         ;save flags
acd7 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
acda : d0fe            >        bne *         ;failed not equal (non zero)
                       >
acdc : 68              >            pla         ;load status
                       >            eor_flag 0
acdd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
acdf : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ace2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ace4 : 88                       dey
ace5 : 10e6                     bpl teor14
ace7 : a003                     ldy #3
ace9 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
ace9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aceb : 48              >            pha         ;use stack to load status
acec : b96f02          >            lda absEOa,y    ;precharge accu
acef : 28              >            plp
                        
acf0 : 513a                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
acf2 : 08              >            php         ;save flags
acf3 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
acf6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
acf8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
acf9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
acfb : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
acfe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad00 : 88                       dey
ad01 : 10e6                     bpl teor15
                                next_test
ad03 : ad0002          >            lda test_case   ;previous test
ad06 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
ad08 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
ad0a : a928            >            lda #test_num   ;*** next tests' number
ad0c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
ad0f : a203                     ldx #3          ;immediate - self modifying code
ad11 : b510             tora    lda zpOR,x
ad13 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
ad16 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ad18 : 48              >            pha         ;use stack to load status
ad19 : bd6702          >            lda absORa,x    ;precharge accu
ad1c : 28              >            plp
                        
ad1d : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
ad20 : 08              >            php         ;save flags
ad21 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ad24 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad26 : 68              >            pla         ;load status
                       >            eor_flag 0
ad27 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ad29 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ad2c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad2e : ca                       dex
ad2f : 10e0                     bpl tora
ad31 : a203                     ldx #3
ad33 : b510             tora1   lda zpOR,x
ad35 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
ad38 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ad3a : 48              >            pha         ;use stack to load status
ad3b : bd6702          >            lda absORa,x    ;precharge accu
ad3e : 28              >            plp
                        
ad3f : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
ad42 : 08              >            php         ;save flags
ad43 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ad46 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad48 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ad49 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ad4b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ad4e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad50 : ca                       dex
ad51 : 10e0                     bpl tora1
                            
ad53 : a203                     ldx #3      ;zp
ad55 : b510             tora2   lda zpOR,x
ad57 : 8502                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
ad59 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ad5b : 48              >            pha         ;use stack to load status
ad5c : bd6702          >            lda absORa,x    ;precharge accu
ad5f : 28              >            plp
                        
ad60 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,0
ad62 : 08              >            php         ;save flags
ad63 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ad66 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad68 : 68              >            pla         ;load status
                       >            eor_flag 0
ad69 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ad6b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ad6e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad70 : ca                       dex
ad71 : 10e2                     bpl tora2
ad73 : a203                     ldx #3
ad75 : b510             tora3   lda zpOR,x
ad77 : 8502                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
ad79 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ad7b : 48              >            pha         ;use stack to load status
ad7c : bd6702          >            lda absORa,x    ;precharge accu
ad7f : 28              >            plp
                        
ad80 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
ad82 : 08              >            php         ;save flags
ad83 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ad86 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ad88 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ad89 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ad8b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ad8e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ad90 : ca                       dex
ad91 : 10e2                     bpl tora3
                        
ad93 : a203                     ldx #3      ;abs
ad95 : b510             tora4   lda zpOR,x
ad97 : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
ad9a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ad9c : 48              >            pha         ;use stack to load status
ad9d : bd6702          >            lda absORa,x    ;precharge accu
ada0 : 28              >            plp
                        
ada1 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
ada4 : 08              >            php         ;save flags
ada5 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ada8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
adaa : 68              >            pla         ;load status
                       >            eor_flag 0
adab : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
adad : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
adb0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
adb2 : ca                       dex
adb3 : 10e0                     bpl tora4
adb5 : a203                     ldx #3
adb7 : b510             tora5   lda zpOR,x
adb9 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
adbc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
adbe : 48              >            pha         ;use stack to load status
adbf : bd6702          >            lda absORa,x    ;precharge accu
adc2 : 28              >            plp
                        
adc3 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
adc6 : 08              >            php         ;save flags
adc7 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
adca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
adcc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
adcd : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
adcf : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
add2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
add4 : ca                       dex
add5 : 1002                     bpl tora6
                        
add7 : a203                     ldx #3      ;zp,x
add9 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
add9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
addb : 48              >            pha         ;use stack to load status
addc : bd6702          >            lda absORa,x    ;precharge accu
addf : 28              >            plp
                        
ade0 : 1510                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
ade2 : 08              >            php         ;save flags
ade3 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ade6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ade8 : 68              >            pla         ;load status
                       >            eor_flag 0
ade9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
adeb : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
adee : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
adf0 : ca                       dex
adf1 : 10e6                     bpl tora6
adf3 : a203                     ldx #3
adf5 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
adf5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
adf7 : 48              >            pha         ;use stack to load status
adf8 : bd6702          >            lda absORa,x    ;precharge accu
adfb : 28              >            plp
                        
adfc : 1510                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
adfe : 08              >            php         ;save flags
adff : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ae02 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae04 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ae05 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ae07 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ae0a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae0c : ca                       dex
ae0d : 10e6                     bpl tora7
                        
ae0f : a203                     ldx #3      ;abs,x
ae11 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
ae11 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ae13 : 48              >            pha         ;use stack to load status
ae14 : bd6702          >            lda absORa,x    ;precharge accu
ae17 : 28              >            plp
                        
ae18 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
ae1b : 08              >            php         ;save flags
ae1c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ae1f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae21 : 68              >            pla         ;load status
                       >            eor_flag 0
ae22 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ae24 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ae27 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae29 : ca                       dex
ae2a : 10e5                     bpl tora8
ae2c : a203                     ldx #3
ae2e :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
ae2e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ae30 : 48              >            pha         ;use stack to load status
ae31 : bd6702          >            lda absORa,x    ;precharge accu
ae34 : 28              >            plp
                        
ae35 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
ae38 : 08              >            php         ;save flags
ae39 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ae3c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae3e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ae3f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ae41 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ae44 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae46 : ca                       dex
ae47 : 10e5                     bpl tora9
                        
ae49 : a003                     ldy #3      ;abs,y
ae4b :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
ae4b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ae4d : 48              >            pha         ;use stack to load status
ae4e : b96702          >            lda absORa,y    ;precharge accu
ae51 : 28              >            plp
                        
ae52 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
ae55 : 08              >            php         ;save flags
ae56 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ae59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae5b : 68              >            pla         ;load status
                       >            eor_flag 0
ae5c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ae5e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ae61 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae63 : 88                       dey
ae64 : 10e5                     bpl tora10
ae66 : a003                     ldy #3
ae68 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
ae68 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ae6a : 48              >            pha         ;use stack to load status
ae6b : b96702          >            lda absORa,y    ;precharge accu
ae6e : 28              >            plp
                        
ae6f : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
ae72 : 08              >            php         ;save flags
ae73 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ae76 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae78 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ae79 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ae7b : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ae7e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae80 : 88                       dey
ae81 : 10e5                     bpl tora11
                        
ae83 : a206                     ldx #6      ;(zp,x)
ae85 : a003                     ldy #3
ae87 :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
ae87 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ae89 : 48              >            pha         ;use stack to load status
ae8a : b96702          >            lda absORa,y    ;precharge accu
ae8d : 28              >            plp
                        
ae8e : 0142                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
ae90 : 08              >            php         ;save flags
ae91 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ae94 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
ae96 : 68              >            pla         ;load status
                       >            eor_flag 0
ae97 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ae99 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ae9c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
ae9e : ca                       dex
ae9f : ca                       dex
aea0 : 88                       dey
aea1 : 10e4                     bpl tora12
aea3 : a206                     ldx #6
aea5 : a003                     ldy #3
aea7 :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
aea7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aea9 : 48              >            pha         ;use stack to load status
aeaa : b96702          >            lda absORa,y    ;precharge accu
aead : 28              >            plp
                        
aeae : 0142                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
aeb0 : 08              >            php         ;save flags
aeb1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aeb4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aeb6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aeb7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aeb9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aebc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aebe : ca                       dex
aebf : ca                       dex
aec0 : 88                       dey
aec1 : 10e4                     bpl tora13
                        
aec3 : a003                     ldy #3      ;(zp),y
aec5 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
aec5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
aec7 : 48              >            pha         ;use stack to load status
aec8 : b96702          >            lda absORa,y    ;precharge accu
aecb : 28              >            plp
                        
aecc : 1142                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
aece : 08              >            php         ;save flags
aecf : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aed2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aed4 : 68              >            pla         ;load status
                       >            eor_flag 0
aed5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
aed7 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aeda : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aedc : 88                       dey
aedd : 10e6                     bpl tora14
aedf : a003                     ldy #3
aee1 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
aee1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
aee3 : 48              >            pha         ;use stack to load status
aee4 : b96702          >            lda absORa,y    ;precharge accu
aee7 : 28              >            plp
                        
aee8 : 1142                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
aeea : 08              >            php         ;save flags
aeeb : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
aeee : d0fe            >        bne *         ;failed not equal (non zero)
                       >
aef0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
aef1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
aef3 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
aef6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
aef8 : 88                       dey
aef9 : 10e6                     bpl tora15
                            if I_flag = 3
aefb : 58                       cli
                            endif                
                                next_test
aefc : ad0002          >            lda test_case   ;previous test
aeff : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
af01 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
af03 : a929            >            lda #test_num   ;*** next tests' number
af05 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
af08 : d8                       cld
af09 : a204                     ldx #ad2        ;for indexed test
af0b : a0ff                     ldy #$ff        ;max range
af0d : a900                     lda #0          ;start with adding zeroes & no carry
af0f : 8502                     sta adfc        ;carry in - for diag
af11 : 8503                     sta ad1         ;operand 1 - accumulator
af13 : 8504                     sta ad2         ;operand 2 - memory or immediate
af15 : 8d0302                   sta ada2        ;non zp
af18 : 8505                     sta adrl        ;expected result bits 0-7
af1a : 8506                     sta adrh        ;expected result bit 8 (carry out)
af1c : a9ff                     lda #$ff        ;complemented operand 2 for subtract
af1e : 8508                     sta sb2
af20 : 8d0402                   sta sba2        ;non zp
af23 : a902                     lda #2          ;expected Z-flag
af25 : 8507                     sta adrf
af27 : 18               tadd    clc             ;test with carry clear
af28 : 2073af                   jsr chkadd
af2b : e602                     inc adfc        ;now with carry
af2d : e605                     inc adrl        ;result +1
af2f : 08                       php             ;save N & Z from low result
af30 : 08                       php
af31 : 68                       pla             ;accu holds expected flags
af32 : 2982                     and #$82        ;mask N & Z
af34 : 28                       plp
af35 : d002                     bne tadd1
af37 : e606                     inc adrh        ;result bit 8 - carry
af39 : 0506             tadd1   ora adrh        ;merge C to expected flags
af3b : 8507                     sta adrf        ;save expected flags except overflow
af3d : 38                       sec             ;test with carry set
af3e : 2073af                   jsr chkadd
af41 : c602                     dec adfc        ;same for operand +1 but no carry
af43 : e603                     inc ad1
af45 : d0e0                     bne tadd        ;iterate op1
af47 : a900                     lda #0          ;preset result to op2 when op1 = 0
af49 : 8506                     sta adrh
af4b : ee0302                   inc ada2
af4e : e604                     inc ad2
af50 : 08                       php             ;save NZ as operand 2 becomes the new result
af51 : 68                       pla
af52 : 2982                     and #$82        ;mask N00000Z0
af54 : 8507                     sta adrf        ;no need to check carry as we are adding to 0
af56 : c608                     dec sb2         ;complement subtract operand 2
af58 : ce0402                   dec sba2
af5b : a504                     lda ad2         
af5d : 8505                     sta adrl
af5f : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
af61 : ad0002                   lda test_case
af64 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
af66 : d0fe            >        bne *         ;failed not equal (non zero)
                        
af68 : a9f0                     lda #$f0        ;mark opcode testing complete
af6a : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
af6d : 4c6daf          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
af70 : 4c0080                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
af73 : a507             chkadd  lda adrf        ;add V-flag if overflow
af75 : 2983                     and #$83        ;keep N-----ZC / clear V
af77 : 48                       pha
af78 : a503                     lda ad1         ;test sign unequal between operands
af7a : 4504                     eor ad2
af7c : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
af7e : a503                     lda ad1         ;test sign equal between operands and result
af80 : 4505                     eor adrl
af82 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
af84 : 68                       pla
af85 : 0940                     ora #$40        ;set V
af87 : 48                       pha
af88 : 68               ckad1   pla
af89 : 8507                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
af8b : 08                       php             ;save carry for subtract
af8c : a503                     lda ad1
af8e : 6504                     adc ad2         ;perform add
af90 : 08                       php          
af91 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
af93 : d0fe            >        bne *         ;failed not equal (non zero)
                        
af95 : 68                       pla             ;check flags
af96 : 29c3                     and #$c3        ;mask NV----ZC
af98 : c507                     cmp adrf
                                trap_ne         ;bad flags
af9a : d0fe            >        bne *         ;failed not equal (non zero)
                        
af9c : 28                       plp
af9d : 08                       php             ;save carry for next add
af9e : a503                     lda ad1
afa0 : e508                     sbc sb2         ;perform subtract
afa2 : 08                       php          
afa3 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
afa5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
afa7 : 68                       pla             ;check flags
afa8 : 29c3                     and #$c3        ;mask NV----ZC
afaa : c507                     cmp adrf
                                trap_ne         ;bad flags
afac : d0fe            >        bne *         ;failed not equal (non zero)
                        
afae : 28                       plp
                        ; binary ADC / SBC abs
afaf : 08                       php             ;save carry for subtract
afb0 : a503                     lda ad1
afb2 : 6d0302                   adc ada2        ;perform add
afb5 : 08                       php          
afb6 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
afb8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
afba : 68                       pla             ;check flags
afbb : 29c3                     and #$c3        ;mask NV----ZC
afbd : c507                     cmp adrf
                                trap_ne         ;bad flags
afbf : d0fe            >        bne *         ;failed not equal (non zero)
                        
afc1 : 28                       plp
afc2 : 08                       php             ;save carry for next add
afc3 : a503                     lda ad1
afc5 : ed0402                   sbc sba2        ;perform subtract
afc8 : 08                       php          
afc9 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
afcb : d0fe            >        bne *         ;failed not equal (non zero)
                        
afcd : 68                       pla             ;check flags
afce : 29c3                     and #$c3        ;mask NV----ZC
afd0 : c507                     cmp adrf
                                trap_ne         ;bad flags
afd2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
afd4 : 28                       plp
                        ; binary ADC / SBC #
afd5 : 08                       php             ;save carry for subtract
afd6 : a504                     lda ad2
afd8 : 8d1302                   sta ex_adci+1   ;set ADC # operand
afdb : a503                     lda ad1
afdd : 201202                   jsr ex_adci     ;execute ADC # in RAM
afe0 : 08                       php          
afe1 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
afe3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
afe5 : 68                       pla             ;check flags
afe6 : 29c3                     and #$c3        ;mask NV----ZC
afe8 : c507                     cmp adrf
                                trap_ne         ;bad flags
afea : d0fe            >        bne *         ;failed not equal (non zero)
                        
afec : 28                       plp
afed : 08                       php             ;save carry for next add
afee : a508                     lda sb2
aff0 : 8d1602                   sta ex_sbci+1   ;set SBC # operand
aff3 : a503                     lda ad1
aff5 : 201502                   jsr ex_sbci     ;execute SBC # in RAM
aff8 : 08                       php          
aff9 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
affb : d0fe            >        bne *         ;failed not equal (non zero)
                        
affd : 68                       pla             ;check flags
affe : 29c3                     and #$c3        ;mask NV----ZC
b000 : c507                     cmp adrf
                                trap_ne         ;bad flags
b002 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b004 : 28                       plp
                        ; binary ADC / SBC zp,x
b005 : 08                       php             ;save carry for subtract
b006 : a503                     lda ad1
b008 : 7500                     adc 0,x         ;perform add
b00a : 08                       php          
b00b : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b00d : d0fe            >        bne *         ;failed not equal (non zero)
                        
b00f : 68                       pla             ;check flags
b010 : 29c3                     and #$c3        ;mask NV----ZC
b012 : c507                     cmp adrf
                                trap_ne         ;bad flags
b014 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b016 : 28                       plp
b017 : 08                       php             ;save carry for next add
b018 : a503                     lda ad1
b01a : f504                     sbc sb2-ad2,x   ;perform subtract
b01c : 08                       php          
b01d : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b01f : d0fe            >        bne *         ;failed not equal (non zero)
                        
b021 : 68                       pla             ;check flags
b022 : 29c3                     and #$c3        ;mask NV----ZC
b024 : c507                     cmp adrf
                                trap_ne         ;bad flags
b026 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b028 : 28                       plp
                        ; binary ADC / SBC abs,x
b029 : 08                       php             ;save carry for subtract
b02a : a503                     lda ad1
b02c : 7dff01                   adc ada2-ad2,x  ;perform add
b02f : 08                       php          
b030 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b032 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b034 : 68                       pla             ;check flags
b035 : 29c3                     and #$c3        ;mask NV----ZC
b037 : c507                     cmp adrf
                                trap_ne         ;bad flags
b039 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b03b : 28                       plp
b03c : 08                       php             ;save carry for next add
b03d : a503                     lda ad1
b03f : fd0002                   sbc sba2-ad2,x  ;perform subtract
b042 : 08                       php          
b043 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b045 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b047 : 68                       pla             ;check flags
b048 : 29c3                     and #$c3        ;mask NV----ZC
b04a : c507                     cmp adrf
                                trap_ne         ;bad flags
b04c : d0fe            >        bne *         ;failed not equal (non zero)
                        
b04e : 28                       plp
                        ; binary ADC / SBC abs,y
b04f : 08                       php             ;save carry for subtract
b050 : a503                     lda ad1
b052 : 790401                   adc ada2-$ff,y  ;perform add
b055 : 08                       php          
b056 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b058 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b05a : 68                       pla             ;check flags
b05b : 29c3                     and #$c3        ;mask NV----ZC
b05d : c507                     cmp adrf
                                trap_ne         ;bad flags
b05f : d0fe            >        bne *         ;failed not equal (non zero)
                        
b061 : 28                       plp
b062 : 08                       php             ;save carry for next add
b063 : a503                     lda ad1
b065 : f90501                   sbc sba2-$ff,y  ;perform subtract
b068 : 08                       php          
b069 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b06b : d0fe            >        bne *         ;failed not equal (non zero)
                        
b06d : 68                       pla             ;check flags
b06e : 29c3                     and #$c3        ;mask NV----ZC
b070 : c507                     cmp adrf
                                trap_ne         ;bad flags
b072 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b074 : 28                       plp
                        ; binary ADC / SBC (zp,x)
b075 : 08                       php             ;save carry for subtract
b076 : a503                     lda ad1
b078 : 6146                     adc (lo adi2-ad2,x) ;perform add
b07a : 08                       php          
b07b : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b07d : d0fe            >        bne *         ;failed not equal (non zero)
                        
b07f : 68                       pla             ;check flags
b080 : 29c3                     and #$c3        ;mask NV----ZC
b082 : c507                     cmp adrf
                                trap_ne         ;bad flags
b084 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b086 : 28                       plp
b087 : 08                       php             ;save carry for next add
b088 : a503                     lda ad1
b08a : e148                     sbc (lo sbi2-ad2,x) ;perform subtract
b08c : 08                       php          
b08d : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b08f : d0fe            >        bne *         ;failed not equal (non zero)
                        
b091 : 68                       pla             ;check flags
b092 : 29c3                     and #$c3        ;mask NV----ZC
b094 : c507                     cmp adrf
                                trap_ne         ;bad flags
b096 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b098 : 28                       plp
                        ; binary ADC / SBC (abs),y
b099 : 08                       php             ;save carry for subtract
b09a : a503                     lda ad1
b09c : 714e                     adc (adiy2),y   ;perform add
b09e : 08                       php          
b09f : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b0a1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0a3 : 68                       pla             ;check flags
b0a4 : 29c3                     and #$c3        ;mask NV----ZC
b0a6 : c507                     cmp adrf
                                trap_ne         ;bad flags
b0a8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0aa : 28                       plp
b0ab : 08                       php             ;save carry for next add
b0ac : a503                     lda ad1
b0ae : f150                     sbc (sbiy2),y   ;perform subtract
b0b0 : 08                       php          
b0b1 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
b0b3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0b5 : 68                       pla             ;check flags
b0b6 : 29c3                     and #$c3        ;mask NV----ZC
b0b8 : c507                     cmp adrf
                                trap_ne         ;bad flags
b0ba : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0bc : 28                       plp
b0bd : 60                       rts
                        
                        ; target for the jump absolute test
b0be : 88                       dey
b0bf : 88                       dey
b0c0 :                  test_far
b0c0 : 08                       php             ;either SP or Y count will fail, if we do not hit
b0c1 : 88                       dey
b0c2 : 88                       dey
b0c3 : 88                       dey
b0c4 : 28                       plp
                                trap_cs         ;flags loaded?
b0c5 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
b0c7 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
b0c9 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
b0cb : f0fe            >        beq *           ;failed equal (zero)
                        
b0cd : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
b0cf : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0d1 : e041                     cpx #'A'
                                trap_ne        
b0d3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0d5 : c04f                     cpy #('R'-3)
                                trap_ne
b0d7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0d9 : 48                       pha             ;save a,x
b0da : 8a                       txa
b0db : 48                       pha
b0dc : ba                       tsx
b0dd : e0fd                     cpx #$fd        ;check SP
                                trap_ne
b0df : d0fe            >        bne *         ;failed not equal (non zero)
                        
b0e1 : 68                       pla             ;restore x
b0e2 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
b0e3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
b0e5 : 48              >            pha         ;use stack to load status
b0e6 : 28              >            plp
                        
b0e7 : 68                       pla             ;restore a
b0e8 : e8                       inx             ;return registers with modifications
b0e9 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
b0eb : 4c0f85                   jmp far_ret
                                
                        ; target for the jump indirect test
                                align
b0ee : f7b0             ptr_tst_ind dw test_ind
b0f0 : 6485             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
b0f2 : 4cf2b0          >        jmp *           ;failed anyway
                        
b0f5 : 88                       dey
b0f6 : 88                       dey
b0f7 :                  test_ind
b0f7 : 08                       php             ;either SP or Y count will fail, if we do not hit
b0f8 : 88                       dey
b0f9 : 88                       dey
b0fa : 88                       dey
b0fb : 28                       plp
                                trap_cs         ;flags loaded?
b0fc : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
b0fe : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
b100 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
b102 : f0fe            >        beq *           ;failed equal (zero)
                        
b104 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
b106 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b108 : e04e                     cpx #'N'
                                trap_ne        
b10a : d0fe            >        bne *         ;failed not equal (non zero)
                        
b10c : c041                     cpy #('D'-3)
                                trap_ne
b10e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b110 : 48                       pha             ;save a,x
b111 : 8a                       txa
b112 : 48                       pha
b113 : ba                       tsx
b114 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
b116 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b118 : 68                       pla             ;restore x
b119 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
b11a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
b11c : 48              >            pha         ;use stack to load status
b11d : 28              >            plp
                        
b11e : 68                       pla             ;restore a
b11f : e8                       inx             ;return registers with modifications
b120 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
b122 : 6cf0b0                   jmp (ptr_ind_ret)
                                trap            ;runover protection
b125 : 4c25b1          >        jmp *           ;failed anyway
                        
b128 : 4c0080                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
b12b : 88                       dey
b12c : 88                       dey
b12d :                  test_jsr
b12d : 08                       php             ;either SP or Y count will fail, if we do not hit
b12e : 88                       dey
b12f : 88                       dey
b130 : 88                       dey
b131 : 28                       plp
                                trap_cs         ;flags loaded?
b132 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
b134 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
b136 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
b138 : f0fe            >        beq *           ;failed equal (zero)
                        
b13a : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
b13c : d0fe            >        bne *         ;failed not equal (non zero)
                        
b13e : e053                     cpx #'S'
                                trap_ne        
b140 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b142 : c04f                     cpy #('R'-3)
                                trap_ne
b144 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b146 : 48                       pha             ;save a,x
b147 : 8a                       txa
b148 : 48                       pha       
b149 : ba                       tsx             ;sp -4? (return addr,a,x)
b14a : e0fb                     cpx #$fb
                                trap_ne
b14c : d0fe            >        bne *         ;failed not equal (non zero)
                        
b14e : adff01                   lda $1ff        ;propper return on stack
b151 : c985                     cmp #hi(jsr_ret)
                                trap_ne
b153 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b155 : adfe01                   lda $1fe
b158 : c99a                     cmp #lo(jsr_ret)
                                trap_ne
b15a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
b15c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
b15e : 48              >            pha         ;use stack to load status
b15f : 28              >            plp
                        
b160 : 68                       pla             ;pull x,a
b161 : aa                       tax
b162 : 68                       pla
b163 : e8                       inx             ;return registers with modifications
b164 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
b166 : 60                       rts
                                trap            ;runover protection
b167 : 4c67b1          >        jmp *           ;failed anyway
                        
b16a : 4c0080                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
b16d :                  nmi_trap
                                trap            ;check stack for conditions at NMI
b16d : 4c6db1          >        jmp *           ;failed anyway
                        
b170 : 4c0080                   jmp start       ;catastrophic error - cannot continue
b173 :                  res_trap
                                trap            ;unexpected RESET
b173 : 4c73b1          >        jmp *           ;failed anyway
                        
b176 : 4c0080                   jmp start       ;catastrophic error - cannot continue
                                
b179 : 88                       dey
b17a : 88                       dey
b17b :                  irq_trap                ;BRK test or unextpected BRK or IRQ
b17b : 08                       php             ;either SP or Y count will fail, if we do not hit
b17c : 88                       dey
b17d : 88                       dey
b17e : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
b17f : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
b181 : f042                     beq break2
b183 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
b185 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b187 : e052                     cpx #'R'
                                trap_ne        
b189 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b18b : c048                     cpy #'K'-3
                                trap_ne
b18d : d0fe            >        bne *         ;failed not equal (non zero)
                        
b18f : 8500                     sta irq_a       ;save registers during break test
b191 : 8601                     stx irq_x
b193 : ba                       tsx             ;test break on stack
b194 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
b197 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
b199 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b19b : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
b19c : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
b19e : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1a0 : ba                       tsx
b1a1 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
b1a3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1a5 : adff01                   lda $1ff        ;propper return on stack
b1a8 : c985                     cmp #hi(brk_ret0)
                                trap_ne
b1aa : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1ac : adfe01                   lda $1fe
b1af : c9d1                     cmp #lo(brk_ret0)
                                trap_ne
b1b1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                load_flag $ff
b1b3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
b1b5 : 48                       pha
b1b6 : a601                     ldx irq_x
b1b8 : e8                       inx             ;return registers with modifications
b1b9 : a500                     lda irq_a
b1bb : 49aa                     eor #$aa
b1bd : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
b1be : 40                       rti
                                trap            ;runover protection
b1bf : 4cbfb1          >        jmp *           ;failed anyway
                        
b1c2 : 4c0080                   jmp start       ;catastrophic error - cannot continue
                                
b1c5 :                  break2                  ;BRK pass 2        
b1c5 : e0ad                     cpx #$ff-'R'
                                trap_ne        
b1c7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1c9 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
b1cb : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1cd : 8500                     sta irq_a       ;save registers during break test
b1cf : 8601                     stx irq_x
b1d1 : ba                       tsx             ;test break on stack
b1d2 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
b1d5 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
b1d7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1d9 : 68                       pla
b1da : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
b1dc : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
b1de : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1e0 : ba                       tsx
b1e1 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
b1e3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1e5 : adff01                   lda $1ff        ;propper return on stack
b1e8 : c985                     cmp #hi(brk_ret1)
                                trap_ne
b1ea : d0fe            >        bne *         ;failed not equal (non zero)
                        
b1ec : adfe01                   lda $1fe
b1ef : c9f7                     cmp #lo(brk_ret1)
                                trap_ne
b1f1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                load_flag intdis
b1f3 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
b1f5 : 48                       pha      
b1f6 : a601                     ldx irq_x
b1f8 : e8                       inx             ;return registers with modifications
b1f9 : a500                     lda irq_a
b1fb : 49aa                     eor #$aa
b1fd : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
b1fe : 40                       rti
                                trap            ;runover protection
b1ff : 4cffb1          >        jmp *           ;failed anyway
                        
b202 : 4c0080                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zps_    db  $80,1           ;additional shift pattern to test zero result & flag
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
                        rASL_                               ;expected result ASL & ROL -carry
                        rROL_   db  0,2,$86,$04,$82,0
                        rROLc_  db  1,3,$87,$05,$83,1       ;expected result ROL +carry
                        rLSR_                               ;expected result LSR & ROR -carry
                        rROR_   db  $40,0,$61,$41,$20,0
                        rRORc_  db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                               ;expected flags for shifts
                        fROL_   db  fzc,0,fnc,fc,fn,fz      ;no carry in
                        fROLc_  db  fc,0,fnc,fc,fn,0        ;carry in 
                        fLSR_
                        fROR_   db  0,fzc,fc,0,fc,fz        ;no carry in
                        fRORc_  db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80           ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80         ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0             ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff         ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
fffa =                          org $fffa       ;vectors
fffa : 6db1                     dw  nmi_trap
fffc : 73b1                     dw  res_trap
fffe : 7bb1                     dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0000 through $ffff.
Total size 65536 bytes.
Program start address is at $8000 (32768).
