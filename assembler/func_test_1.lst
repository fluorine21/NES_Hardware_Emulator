AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
-------------------------------------------------------- func_test_1.a65 ---------------------------------------------------------

6115 lines read, no errors in pass 1.
                        
                        
                        ;as65.exe -l ../func_test_1.a65 -m -h0 -l -w
                        
                        
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2020  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 05-jan-2020
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 written by Frank A. Kingswood
                        ; The assembler as65_142.zip can be obtained from my GitHub repository 
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        ;   05-jan-2020  fixed shifts not testing zero result and flag when last 1-bit
                        ;                is shifted out
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0000 =                  load_data_direct = 0
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $52 (82) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
0000 =                  zero_page = $0  
                        
                        ;data_segment memory start address, $7B (123) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13.1kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0001 =                  disable_selfmod = 1
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0001 =                  disable_decimal = 1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                        		endm
                        trap_ne macro
                                bne *         ;failed not equal (non zero)
                        		endm
                        trap_cs macro
                                bcs *           ;failed carry set
                        		endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                        		endm
                        trap_mi macro
                                bmi *         ;failed minus (bit 7 set)
                        		endm
                        trap_pl macro
                                bpl *          ;failed plus (bit 7 clear)
                        		endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                        		endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                        		endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;break test interrupt save
0000 =                  irq_a   ds  1               ;a register
0001 =                  irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0002 =                  zpt                         ;6 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0002 =                  adfc    ds  1               ;carry flag before op
0003 =                  ad1     ds  1               ;operand 1 - accumulator
0004 =                  ad2     ds  1               ;operand 2 - memory / immediate
0005 =                  adrl    ds  1               ;expected result bits 0-7
0006 =                  adrh    ds  1               ;expected result bit 8 (carry)
0007 =                  adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0008 =                  sb2     ds  1               ;operand 2 complemented for subtract
0009 =                  zp_bss
0009 =                  zps     db  $80,1           ;additional shift pattern to test zero result & flag
000b =                  zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000f =                  zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0010 =                  zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0014 =                  zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0018 =                  zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
001c =                  ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
001e =                          dw  abs1+1
0020 =                          dw  abs1+2
0022 =                          dw  abs1+3
0024 =                          dw  abs7f
0026 =                  inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0028 =                  indt    dw  abst            ;indirect pointer to store area in absolute memory
002a =                          dw  abst+1
002c =                          dw  abst+2
002e =                          dw  abst+3
0030 =                  inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0032 =                  indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0034 =                          dw  absAN+1
0036 =                          dw  absAN+2
0038 =                          dw  absAN+3
003a =                  indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
003c =                          dw  absEO+1
003e =                          dw  absEO+2
0040 =                          dw  absEO+3
0042 =                  indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0044 =                          dw  absOR+1
0046 =                          dw  absOR+2
0048 =                          dw  absOR+3
                        ;add/subtract indirect pointers
004a =                  adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
004c =                  sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
004e =                  adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0050 =                  sbiy2   dw  sba2-$ff
0052 =                  zp_bss_end
                           
0200 =                          org data_segment
0200 =                  test_case   ds  1           ;current test number
0201 =                  ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 =                  abst                        ;6 bytes store/modify test area
0203 =                  ada2    ds  1               ;operand 2
0204 =                  sba2    ds  1               ;operand 2 complemented for subtract
0205 =                          ds  4               ;fill remaining bytes
0209 =                  data_bss
                            if load_data_direct = 1
                        ex_andi and #0              ;execute immediate opcodes
                                rts
                        ex_eori eor #0              ;execute immediate opcodes
                                rts
                        ex_orai ora #0              ;execute immediate opcodes
                                rts
                        ex_adci adc #0              ;execute immediate opcodes
                                rts
                        ex_sbci sbc #0              ;execute immediate opcodes
                                rts
                            else
0209 =                  ex_andi ds  3
020c =                  ex_eori ds  3
020f =                  ex_orai ds  3
0212 =                  ex_adci ds  3
0215 =                  ex_sbci ds  3
                            endif
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
0218 =                  abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021c =                  abs7f   db  $7f             ;test pattern for compare
                        ;loads
021d =                  fLDx    db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
0221 =                  rASL                                ;expected result ASL & ROL -carry
0221 =                  rROL    db  0,2,$86,$04,$82,0
0227 =                  rROLc   db  1,3,$87,$05,$83,1       ;expected result ROL +carry
022d =                  rLSR                                ;expected result LSR & ROR -carry
022d =                  rROR    db  $40,0,$61,$41,$20,0
0233 =                  rRORc   db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
0239 =                  fASL                                ;expected flags for shifts
0239 =                  fROL    db  fzc,0,fnc,fc,fn,fz      ;no carry in
023f =                  fROLc   db  fc,0,fnc,fc,fn,0        ;carry in 
0245 =                  fLSR 
0245 =                  fROR    db  0,fzc,fc,0,fc,fz        ;no carry in
024b =                  fRORc   db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
0251 =                  rINC    db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
0256 =                  fINC    db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
025b =                  absOR   db  0,$1f,$71,$80           ;test pattern for OR
025f =                  absAN   db  $0f,$ff,$7f,$80         ;test pattern for AND
0263 =                  absEO   db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
0267 =                  absORa  db  0,$f1,$1f,0             ;test pattern for OR
026b =                  absANa  db  $f0,$ff,$ff,$ff         ;test pattern for AND
026f =                  absEOa  db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
0273 =                  absrlo  db  0,$ff,$7f,$80
0277 =                  absflo  db  fz,fn,0,fn
027b =                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
0409 : a205                     ldx #5
040b : 4c3304                   jmp psb_test
040e :                  psb_bwok
040e : a005                     ldy #5
0410 : d008                     bne psb_forw
                                trap        ;branch should be taken
0412 : 4c1204          >        jmp *           ;failed anyway
                        
0415 : 88                       dey         ;forward landing zone
0416 : 88                       dey
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a :                  psb_forw
041a : 88                       dey
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : f017                     beq psb_fwok
                                trap        ;forward offset
0421 : 4c2104          >        jmp *           ;failed anyway
                        
                        
0424 : ca                       dex         ;backward landing zone
0425 : ca                       dex
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 :                  psb_back
0429 : ca                       dex
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : f0de                     beq psb_bwok
                                trap        ;backward offset
0430 : 4c3004          >        jmp *           ;failed anyway
                        
0433 :                  psb_test
0433 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0435 : 4c3504          >        jmp *           ;failed anyway
                        
0438 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
0438 : a248                     ldx #zp_end-zp_init-1
043a : bde934           ld_zp   lda zp_init,x
043d : 9509                     sta zp_bss,x
043f : ca                       dex
0440 : 10f8                     bpl ld_zp
0442 : a271                     ldx #data_end-data_init-1
0444 : bd3235           ld_data lda data_init,x
0447 : 9d0902                   sta data_bss,x
044a : ca                       dex
044b : 10f7                     bpl ld_data
                              if ROM_vectors = 1
044d : a205                     ldx #5
044f : bda435           ld_vect lda vec_init,x
0452 : 9dfaff                   sta vec_bss,x
0455 : ca                       dex
0456 : 10f7                     bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0458 : ad0002          >            lda test_case   ;previous test
045b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
045d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
045f : a901            >            lda #test_num   ;*** next tests' number
0461 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
                                ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
                        range_loop
                                dey             ;next relative address
                                tya
                                tax             ;precharge count to end of loop
                                bpl range_fw    ;calculate relative address
                                clc             ;avoid branch self or to relative address of branch
                                adc #2
                                nop             ;offset landing zone - tolerate +/-5 offset to branch
                                nop
                                nop
                                nop
                                nop
                        range_fw
                                nop
                                nop
                                nop
                                nop
                                nop
                                eor #$7f        ;complement except sign
                                sta range_adr   ;load into test target
                                lda #0          ;should set zero flag in status register
                                jmp range_op
                                
                                dex             ; offset landing zone - backward branch too far
                                dex
                                dex
                                dex
                                dex
                                ;relative address target field with branch under test in the middle
                                dex             ;-128 - max backward
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-120
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-110
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-100
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-90
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-80
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-70
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-60
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-50
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-40
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-30
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-20
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-10
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-3
                        range_op                ;test target with zero flag=0, z=1 if previous dex
                        range_adr   = *+1       ;modifiable relative address
                                beq *+64        ;+64 if called without modification
                                dex             ;+0
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+10
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+20
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+30
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+40
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+50
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+60
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+70
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+80
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+90
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+100
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+110
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+120
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                nop             ;offset landing zone - forward branch too far
                                nop
                                nop
                                nop
                                nop
                                beq range_ok    ;+127 - max forward
                                trap            ; bad range
                                nop             ;offset landing zone - tolerate +/-5 offset to branch
                                nop
                                nop
                                nop
                                nop
                        range_ok
                                nop
                                nop
                                nop
                                nop
                                nop
                                cpy #0
                                beq range_end   
                                jmp range_loop
                        range_end               ;range test successful
                            endif
                                next_test
0464 : ad0002          >            lda test_case   ;previous test
0467 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0469 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
046b : a902            >            lda #test_num   ;*** next tests' number
046d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
0470 : c001                     cpy #1          ;testing BNE true
0472 : d003                     bne test_bne
                                trap 
0474 : 4c7404          >        jmp *           ;failed anyway
                        
0477 :                  test_bne
0477 : a900                     lda #0 
0479 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
047b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
047d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
047f : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
0481 : c901                     cmp #1
                                trap_eq 
0483 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0485 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0487 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
0489 : aa                       tax 
048a : e000                     cpx #0          ;test compare x immediate
                                trap_ne
048c : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
048e : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
0490 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
0492 : e001                     cpx #1
                                trap_eq 
0494 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0496 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0498 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
049a : a8                       tay 
049b : c000                     cpy #0          ;test compare y immediate
                                trap_ne
049d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
049f : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
04a1 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
04a3 : c001                     cpy #1
                                trap_eq 
04a5 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
04a7 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
04a9 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                next_test
04ab : ad0002          >            lda test_case   ;previous test
04ae : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
04b0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
04b2 : a903            >            lda #test_num   ;*** next tests' number
04b4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
04b7 : a2ff                     ldx #$ff        ;initialize stack
04b9 : 9a                       txs
04ba : a955                     lda #$55
04bc : 48                       pha
04bd : a9aa                     lda #$aa
04bf : 48                       pha
04c0 : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
04c3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
04c5 : ba                       tsx
04c6 : 8a                       txa             ;overwrite accu
04c7 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
04c9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
04cb : 68                       pla
04cc : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
04ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
04d0 : 68                       pla
04d1 : c955                     cmp #$55
                                trap_ne
04d3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
04d5 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
04d8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
04da : ba                       tsx
04db : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
04dd : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
04df : ad0002          >            lda test_case   ;previous test
04e2 : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
04e4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
04e6 : a904            >            lda #test_num   ;*** next tests' number
04e8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
04eb : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
04ed : 48              >            pha         ;use stack to load status
04ee : 28              >            plp
                        
04ef : 101a                     bpl nbr1        ;branches should not be taken
04f1 : 501b                     bvc nbr2
04f3 : 901c                     bcc nbr3
04f5 : d01d                     bne nbr4
04f7 : 3003                     bmi br1         ;branches should be taken
                                trap 
04f9 : 4cf904          >        jmp *           ;failed anyway
                        
04fc : 7003             br1     bvs br2
                                trap 
04fe : 4cfe04          >        jmp *           ;failed anyway
                        
0501 : b003             br2     bcs br3
                                trap 
0503 : 4c0305          >        jmp *           ;failed anyway
                        
0506 : f00f             br3     beq br4
                                trap 
0508 : 4c0805          >        jmp *           ;failed anyway
                        
050b :                  nbr1
                                trap            ;previous bpl taken 
050b : 4c0b05          >        jmp *           ;failed anyway
                        
050e :                  nbr2
                                trap            ;previous bvc taken
050e : 4c0e05          >        jmp *           ;failed anyway
                        
0511 :                  nbr3
                                trap            ;previous bcc taken
0511 : 4c1105          >        jmp *           ;failed anyway
                        
0514 :                  nbr4
                                trap            ;previous bne taken
0514 : 4c1405          >        jmp *           ;failed anyway
                        
0517 : 08               br4     php
0518 : ba                       tsx
0519 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
051b : d0fe            >        bne *         ;failed not equal (non zero)
                        
051d : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
051e : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0520 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0522 : ba                       tsx
0523 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0525 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0527 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
0529 : 48              >            pha         ;use stack to load status
052a : 28              >            plp
                        
052b : 301a                     bmi nbr11       ;branches should not be taken
052d : 701b                     bvs nbr12
052f : b01c                     bcs nbr13
0531 : f01d                     beq nbr14
0533 : 1003                     bpl br11        ;branches should be taken
                                trap 
0535 : 4c3505          >        jmp *           ;failed anyway
                        
0538 : 5003             br11    bvc br12
                                trap 
053a : 4c3a05          >        jmp *           ;failed anyway
                        
053d : 9003             br12    bcc br13
                                trap 
053f : 4c3f05          >        jmp *           ;failed anyway
                        
0542 : d00f             br13    bne br14
                                trap 
0544 : 4c4405          >        jmp *           ;failed anyway
                        
0547 :                  nbr11
                                trap            ;previous bmi taken 
0547 : 4c4705          >        jmp *           ;failed anyway
                        
054a :                  nbr12
                                trap            ;previous bvs taken 
054a : 4c4a05          >        jmp *           ;failed anyway
                        
054d :                  nbr13
                                trap            ;previous bcs taken 
054d : 4c4d05          >        jmp *           ;failed anyway
                        
0550 :                  nbr14
                                trap            ;previous beq taken 
0550 : 4c5005          >        jmp *           ;failed anyway
                        
0553 : 08               br14    php
0554 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0555 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                ;cmp #0
                        		trap_ne
0557 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0559 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
055b : 48              >            pha         ;use stack to load status
055c : 28              >            plp
                        
055d : d002                     bne brzs1
055f : f003                     beq brzs2
0561 :                  brzs1
                                trap            ;branch zero/non zero
0561 : 4c6105          >        jmp *           ;failed anyway
                        
0564 : b002             brzs2   bcs brzs3
0566 : 9003                     bcc brzs4
0568 :                  brzs3
                                trap            ;branch carry/no carry
0568 : 4c6805          >        jmp *           ;failed anyway
                        
056b : 3002             brzs4   bmi brzs5
056d : 1003                     bpl brzs6
056f :                  brzs5
                                trap            ;branch minus/plus
056f : 4c6f05          >        jmp *           ;failed anyway
                        
0572 : 7002             brzs6   bvs brzs7
0574 : 5003                     bvc brzs8
0576 :                  brzs7
                                trap            ;branch overflow/no overflow
0576 : 4c7605          >        jmp *           ;failed anyway
                        
0579 :                  brzs8
                                set_stat carry
                       >            load_flag carry
0579 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
057b : 48              >            pha         ;use stack to load status
057c : 28              >            plp
                        
057d : f002                     beq brcs1
057f : d003                     bne brcs2
0581 :                  brcs1
                                trap            ;branch zero/non zero
0581 : 4c8105          >        jmp *           ;failed anyway
                        
0584 : 9002             brcs2   bcc brcs3
0586 : b003                     bcs brcs4
0588 :                  brcs3
                                trap            ;branch carry/no carry
0588 : 4c8805          >        jmp *           ;failed anyway
                        
058b : 3002             brcs4   bmi brcs5
058d : 1003                     bpl brcs6
058f :                  brcs5
                                trap            ;branch minus/plus
058f : 4c8f05          >        jmp *           ;failed anyway
                        
0592 : 7002             brcs6   bvs brcs7
0594 : 5003                     bvc brcs8
0596 :                  brcs7
                                trap            ;branch overflow/no overflow
0596 : 4c9605          >        jmp *           ;failed anyway
                        
                        
0599 :                  brcs8
                                set_stat minus
                       >            load_flag minus
0599 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
059b : 48              >            pha         ;use stack to load status
059c : 28              >            plp
                        
059d : f002                     beq brmi1
059f : d003                     bne brmi2
05a1 :                  brmi1
                                trap            ;branch zero/non zero
05a1 : 4ca105          >        jmp *           ;failed anyway
                        
05a4 : b002             brmi2   bcs brmi3
05a6 : 9003                     bcc brmi4
05a8 :                  brmi3
                                trap            ;branch carry/no carry
05a8 : 4ca805          >        jmp *           ;failed anyway
                        
05ab : 1002             brmi4   bpl brmi5
05ad : 3003                     bmi brmi6
05af :                  brmi5
                                trap            ;branch minus/plus
05af : 4caf05          >        jmp *           ;failed anyway
                        
05b2 : 7002             brmi6   bvs brmi7
05b4 : 5003                     bvc brmi8
05b6 :                  brmi7
                                trap            ;branch overflow/no overflow
05b6 : 4cb605          >        jmp *           ;failed anyway
                        
05b9 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
05b9 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
05bb : 48              >            pha         ;use stack to load status
05bc : 28              >            plp
                        
05bd : f002                     beq brvs1
05bf : d003                     bne brvs2
05c1 :                  brvs1
                                trap            ;branch zero/non zero
05c1 : 4cc105          >        jmp *           ;failed anyway
                        
05c4 : b002             brvs2   bcs brvs3
05c6 : 9003                     bcc brvs4
05c8 :                  brvs3
                                trap            ;branch carry/no carry
05c8 : 4cc805          >        jmp *           ;failed anyway
                        
05cb : 3002             brvs4   bmi brvs5
05cd : 1003                     bpl brvs6
05cf :                  brvs5
                                trap            ;branch minus/plus
05cf : 4ccf05          >        jmp *           ;failed anyway
                        
05d2 : 5002             brvs6   bvc brvs7
05d4 : 7003                     bvs brvs8
05d6 :                  brvs7
                                trap            ;branch overflow/no overflow
05d6 : 4cd605          >        jmp *           ;failed anyway
                        
05d9 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
05d9 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
05db : 48              >            pha         ;use stack to load status
05dc : 28              >            plp
                        
05dd : f002                     beq brzc1
05df : d003                     bne brzc2
05e1 :                  brzc1
                                trap            ;branch zero/non zero
05e1 : 4ce105          >        jmp *           ;failed anyway
                        
05e4 : 9002             brzc2   bcc brzc3
05e6 : b003                     bcs brzc4
05e8 :                  brzc3
                                trap            ;branch carry/no carry
05e8 : 4ce805          >        jmp *           ;failed anyway
                        
05eb : 1002             brzc4   bpl brzc5
05ed : 3003                     bmi brzc6
05ef :                  brzc5
                                trap            ;branch minus/plus
05ef : 4cef05          >        jmp *           ;failed anyway
                        
05f2 : 5002             brzc6   bvc brzc7
05f4 : 7003                     bvs brzc8
05f6 :                  brzc7
                                trap            ;branch overflow/no overflow
05f6 : 4cf605          >        jmp *           ;failed anyway
                        
05f9 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
05f9 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
05fb : 48              >            pha         ;use stack to load status
05fc : 28              >            plp
                        
05fd : d002                     bne brcc1
05ff : f003                     beq brcc2
0601 :                  brcc1
                                trap            ;branch zero/non zero
0601 : 4c0106          >        jmp *           ;failed anyway
                        
0604 : b002             brcc2   bcs brcc3
0606 : 9003                     bcc brcc4
0608 :                  brcc3
                                trap            ;branch carry/no carry
0608 : 4c0806          >        jmp *           ;failed anyway
                        
060b : 1002             brcc4   bpl brcc5
060d : 3003                     bmi brcc6
060f :                  brcc5
                                trap            ;branch minus/plus
060f : 4c0f06          >        jmp *           ;failed anyway
                        
0612 : 5002             brcc6   bvc brcc7
0614 : 7003                     bvs brcc8
0616 :                  brcc7
                                trap            ;branch overflow/no overflow
0616 : 4c1606          >        jmp *           ;failed anyway
                        
0619 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
0619 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
061b : 48              >            pha         ;use stack to load status
061c : 28              >            plp
                        
061d : d002                     bne brpl1
061f : f003                     beq brpl2
0621 :                  brpl1
                                trap            ;branch zero/non zero
0621 : 4c2106          >        jmp *           ;failed anyway
                        
0624 : 9002             brpl2   bcc brpl3
0626 : b003                     bcs brpl4
0628 :                  brpl3
                                trap            ;branch carry/no carry
0628 : 4c2806          >        jmp *           ;failed anyway
                        
062b : 3002             brpl4   bmi brpl5
062d : 1003                     bpl brpl6
062f :                  brpl5
                                trap            ;branch minus/plus
062f : 4c2f06          >        jmp *           ;failed anyway
                        
0632 : 5002             brpl6   bvc brpl7
0634 : 7003                     bvs brpl8
0636 :                  brpl7
                                trap            ;branch overflow/no overflow
0636 : 4c3606          >        jmp *           ;failed anyway
                        
0639 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0639 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
063b : 48              >            pha         ;use stack to load status
063c : 28              >            plp
                        
063d : d002                     bne brvc1
063f : f003                     beq brvc2
0641 :                  brvc1
                                trap            ;branch zero/non zero
0641 : 4c4106          >        jmp *           ;failed anyway
                        
0644 : 9002             brvc2   bcc brvc3
0646 : b003                     bcs brvc4
0648 :                  brvc3
                                trap            ;branch carry/no carry
0648 : 4c4806          >        jmp *           ;failed anyway
                        
064b : 1002             brvc4   bpl brvc5
064d : 3003                     bmi brvc6
064f :                  brvc5
                                trap            ;branch minus/plus
064f : 4c4f06          >        jmp *           ;failed anyway
                        
0652 : 7002             brvc6   bvs brvc7
0654 : 5003                     bvc brvc8
0656 :                  brvc7
                                trap            ;branch overflow/no overflow
0656 : 4c5606          >        jmp *           ;failed anyway
                        
0659 :                  brvc8
                                next_test
0659 : ad0002          >            lda test_case   ;previous test
065c : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
065e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
0660 : a905            >            lda #test_num   ;*** next tests' number
0662 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0665 : a255                     ldx #$55        ;x & y protected
0667 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
0669 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
066b : 48              >            pha         ;use stack to load status
066c : a901            >            lda #1     ;precharge accu
066e : 28              >            plp
                        
066f : 48                       pha
                                tst_a 1,$ff
0670 : 08              >            php         ;save flags
0671 : c901            >            cmp #1     ;test result
                       >            trap_ne
0673 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0675 : 68              >            pla         ;load status
0676 : 48              >            pha
                       >            cmp_flag $ff
0677 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0679 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
067b : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
067c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
067e : 48              >            pha         ;use stack to load status
067f : a900            >            lda #0     ;precharge accu
0681 : 28              >            plp
                        
0682 : 48                       pha
                                tst_a 0,0
0683 : 08              >            php         ;save flags
0684 : c900            >            cmp #0     ;test result
                       >            trap_ne
0686 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0688 : 68              >            pla         ;load status
0689 : 48              >            pha
                       >            cmp_flag 0
068a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
068c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
068e : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
068f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0691 : 48              >            pha         ;use stack to load status
0692 : a9ff            >            lda #$ff     ;precharge accu
0694 : 28              >            plp
                        
0695 : 48                       pha
                                tst_a $ff,$ff
0696 : 08              >            php         ;save flags
0697 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0699 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
069b : 68              >            pla         ;load status
069c : 48              >            pha
                       >            cmp_flag $ff
069d : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
069f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06a1 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
06a2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
06a4 : 48              >            pha         ;use stack to load status
06a5 : a901            >            lda #1     ;precharge accu
06a7 : 28              >            plp
                        
06a8 : 48                       pha
                                tst_a 1,0
06a9 : 08              >            php         ;save flags
06aa : c901            >            cmp #1     ;test result
                       >            trap_ne
06ac : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06ae : 68              >            pla         ;load status
06af : 48              >            pha
                       >            cmp_flag 0
06b0 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06b2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06b4 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
06b5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
06b7 : 48              >            pha         ;use stack to load status
06b8 : a900            >            lda #0     ;precharge accu
06ba : 28              >            plp
                        
06bb : 48                       pha
                                tst_a 0,$ff
06bc : 08              >            php         ;save flags
06bd : c900            >            cmp #0     ;test result
                       >            trap_ne
06bf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06c1 : 68              >            pla         ;load status
06c2 : 48              >            pha
                       >            cmp_flag $ff
06c3 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06c7 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
06c8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
06ca : 48              >            pha         ;use stack to load status
06cb : a9ff            >            lda #$ff     ;precharge accu
06cd : 28              >            plp
                        
06ce : 48                       pha
                                tst_a $ff,0
06cf : 08              >            php         ;save flags
06d0 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
06d2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06d4 : 68              >            pla         ;load status
06d5 : 48              >            pha
                       >            cmp_flag 0
06d6 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06d8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06da : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
06db : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
06dd : 48              >            pha         ;use stack to load status
06de : a900            >            lda #0     ;precharge accu
06e0 : 28              >            plp
                        
06e1 : 68                       pla
                                tst_a $ff,$ff-zero
06e2 : 08              >            php         ;save flags
06e3 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
06e5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06e7 : 68              >            pla         ;load status
06e8 : 48              >            pha
                       >            cmp_flag $ff-zero
06e9 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06eb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06ed : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
06ee : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
06f0 : 48              >            pha         ;use stack to load status
06f1 : a9ff            >            lda #$ff     ;precharge accu
06f3 : 28              >            plp
                        
06f4 : 68                       pla
                                tst_a 0,zero
06f5 : 08              >            php         ;save flags
06f6 : c900            >            cmp #0     ;test result
                       >            trap_ne
06f8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06fa : 68              >            pla         ;load status
06fb : 48              >            pha
                       >            cmp_flag zero
06fc : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06fe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0700 : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
0701 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0703 : 48              >            pha         ;use stack to load status
0704 : a9fe            >            lda #$fe     ;precharge accu
0706 : 28              >            plp
                        
0707 : 68                       pla
                                tst_a 1,$ff-zero-minus
0708 : 08              >            php         ;save flags
0709 : c901            >            cmp #1     ;test result
                       >            trap_ne
070b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
070d : 68              >            pla         ;load status
070e : 48              >            pha
                       >            cmp_flag $ff-zero-minus
070f : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0711 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0713 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0714 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0716 : 48              >            pha         ;use stack to load status
0717 : a900            >            lda #0     ;precharge accu
0719 : 28              >            plp
                        
071a : 68                       pla
                                tst_a $ff,minus
071b : 08              >            php         ;save flags
071c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
071e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0720 : 68              >            pla         ;load status
0721 : 48              >            pha
                       >            cmp_flag minus
0722 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0724 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0726 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0727 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0729 : 48              >            pha         ;use stack to load status
072a : a9ff            >            lda #$ff     ;precharge accu
072c : 28              >            plp
                        
072d : 68                       pla
                                tst_a 0,$ff-minus
072e : 08              >            php         ;save flags
072f : c900            >            cmp #0     ;test result
                       >            trap_ne
0731 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0733 : 68              >            pla         ;load status
0734 : 48              >            pha
                       >            cmp_flag $ff-minus
0735 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0737 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0739 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
073a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
073c : 48              >            pha         ;use stack to load status
073d : a9fe            >            lda #$fe     ;precharge accu
073f : 28              >            plp
                        
0740 : 68                       pla
                                tst_a 1,0
0741 : 08              >            php         ;save flags
0742 : c901            >            cmp #1     ;test result
                       >            trap_ne
0744 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0746 : 68              >            pla         ;load status
0747 : 48              >            pha
                       >            cmp_flag 0
0748 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
074a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
074c : 28              >            plp         ;restore status
                        
074d : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
074f : d0fe            >        bne *         ;failed not equal (non zero)
                        
0751 : c0aa                     cpy #$aa
                                trap_ne
0753 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
0755 : ad0002          >            lda test_case   ;previous test
0758 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
075a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
075c : a906            >            lda #test_num   ;*** next tests' number
075e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
0761 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0763 : 48              >            pha         ;use stack to load status
0764 : a93c            >            lda #$3c     ;precharge accu
0766 : 28              >            plp
                        
0767 : 49c3                     eor #$c3
                                tst_a $ff,fn
0769 : 08              >            php         ;save flags
076a : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
076c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
076e : 68              >            pla         ;load status
076f : 48              >            pha
                       >            cmp_flag fn
0770 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0772 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0774 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0775 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0777 : 48              >            pha         ;use stack to load status
0778 : a9c3            >            lda #$c3     ;precharge accu
077a : 28              >            plp
                        
077b : 49c3                     eor #$c3
                                tst_a 0,fz
077d : 08              >            php         ;save flags
077e : c900            >            cmp #0     ;test result
                       >            trap_ne
0780 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0782 : 68              >            pla         ;load status
0783 : 48              >            pha
                       >            cmp_flag fz
0784 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0786 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0788 : 28              >            plp         ;restore status
                        
                                next_test
0789 : ad0002          >            lda test_case   ;previous test
078c : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
078e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
0790 : a907            >            lda #test_num   ;*** next tests' number
0792 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
0795 : a224                     ldx #$24
0797 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
0799 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
079b : 48              >            pha         ;use stack to load status
079c : a918            >            lda #$18     ;precharge accu
079e : 28              >            plp
                        
079f : ea                       nop
                                tst_a $18,0
07a0 : 08              >            php         ;save flags
07a1 : c918            >            cmp #$18     ;test result
                       >            trap_ne
07a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
07a5 : 68              >            pla         ;load status
07a6 : 48              >            pha
                       >            cmp_flag 0
07a7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
07ab : 28              >            plp         ;restore status
                        
07ac : e024                     cpx #$24
                                trap_ne
07ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
07b0 : c042                     cpy #$42
                                trap_ne
07b2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
07b4 : a2db                     ldx #$db
07b6 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
07b8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07ba : 48              >            pha         ;use stack to load status
07bb : a9e7            >            lda #$e7     ;precharge accu
07bd : 28              >            plp
                        
07be : ea                       nop
                                tst_a $e7,$ff
07bf : 08              >            php         ;save flags
07c0 : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
07c2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
07c4 : 68              >            pla         ;load status
07c5 : 48              >            pha
                       >            cmp_flag $ff
07c6 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07c8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
07ca : 28              >            plp         ;restore status
                        
07cb : e0db                     cpx #$db
                                trap_ne
07cd : d0fe            >        bne *         ;failed not equal (non zero)
                        
07cf : c0bd                     cpy #$bd
                                trap_ne
07d1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
07d3 : ad0002          >            lda test_case   ;previous test
07d6 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
07d8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
07da : a908            >            lda #test_num   ;*** next tests' number
07dc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
07df : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
07e1 : 48              >            pha         ;use stack to load status
07e2 : 28              >            plp
                        
07e3 : a946                     lda #'F'
07e5 : a241                     ldx #'A'
07e7 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
07e9 : 4ca333                   jmp test_far
07ec : ea                       nop
07ed : ea                       nop
                                trap_ne         ;runover protection
07ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
07f0 : e8                       inx
07f1 : e8                       inx
07f2 :                  far_ret 
                                trap_eq         ;returned flags OK?
07f2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
07f4 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
07f6 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
07f8 : 50fe            >        bvc *           ;failed overflow clear
                        
07fa : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
07fc : d0fe            >        bne *         ;failed not equal (non zero)
                        
07fe : e042                     cpx #('A'+1)
                                trap_ne
0800 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0802 : c04f                     cpy #('R'-3)
                                trap_ne
0804 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0806 : ca                       dex
0807 : c8                       iny
0808 : c8                       iny
0809 : c8                       iny
080a : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
080c : 4c1508                   jmp test_near
080f : ea                       nop
0810 : ea                       nop
                                trap_ne         ;runover protection
0811 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0813 : e8                       inx
0814 : e8                       inx
0815 :                  test_near
                                trap_eq         ;passed flags OK?
0815 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0817 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_cc
0819 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
081b : 50fe            >        bvc *           ;failed overflow clear
                        
081d : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
081f : d0fe            >        bne *         ;failed not equal (non zero)
                        
0821 : e041                     cpx #'A'
                                trap_ne
0823 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0825 : c052                     cpy #'R'
                                trap_ne
0827 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
0829 : ad0002          >            lda test_case   ;previous test
082c : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
082e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
0830 : a909            >            lda #test_num   ;*** next tests' number
0832 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0835 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0837 : 48              >            pha         ;use stack to load status
0838 : 28              >            plp
                        
0839 : a949                     lda #'I'
083b : a24e                     ldx #'N'
083d : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
083f : 6cd233                   jmp (ptr_tst_ind)
0842 : ea                       nop
                                trap_ne         ;runover protection
0843 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0845 : 88                       dey
0846 : 88                       dey
0847 :                  ind_ret 
0847 : 08                       php             ;either SP or Y count will fail, if we do not hit
0848 : 88                       dey
0849 : 88                       dey
084a : 88                       dey
084b : 28                       plp
                                trap_eq         ;returned flags OK?
084c : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
084e : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
0850 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0852 : 50fe            >        bvc *           ;failed overflow clear
                        
0854 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0856 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0858 : e04f                     cpx #('N'+1)
                                trap_ne
085a : d0fe            >        bne *         ;failed not equal (non zero)
                        
085c : c03e                     cpy #('D'-6)
                                trap_ne
085e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0860 : ba                       tsx             ;SP check
0861 : e0ff                     cpx #$ff
                                trap_ne
0863 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
0865 : ad0002          >            lda test_case   ;previous test
0868 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
086a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
086c : a90a            >            lda #test_num   ;*** next tests' number
086e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
0871 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0873 : 48              >            pha         ;use stack to load status
0874 : 28              >            plp
                        
0875 : a94a                     lda #'J'
0877 : a253                     ldx #'S'
0879 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
087b : 201134                   jsr test_jsr
                        ;jsr_ret = *-1           ;last address of jsr = return address
087e =                  jsr_ret = *
087e : 08                       php             ;either SP or Y count will fail, if we do not hit
087f : 88                       dey
0880 : 88                       dey
0881 : 88                       dey
0882 : 28                       plp
                                trap_eq         ;returned flags OK?
0883 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0885 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
0887 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0889 : 50fe            >        bvc *           ;failed overflow clear
                        
088b : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
088d : d0fe            >        bne *         ;failed not equal (non zero)
                        
088f : e054                     cpx #('S'+1)
                                trap_ne
0891 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0893 : c04c                     cpy #('R'-6)
                                trap_ne
0895 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0897 : ba                       tsx             ;sp?
0898 : e0ff                     cpx #$ff
                                trap_ne
089a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
089c : ad0002          >            lda test_case   ;previous test
089f : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08a1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
08a3 : a90b            >            lda #test_num   ;*** next tests' number
08a5 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
08a8 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
08aa : 48                       pha
08ab : a942                     lda #'B'
08ad : a252                     ldx #'R'
08af : a04b                     ldy #'K'
08b1 : 28                       plp             ;N=0, V=0, Z=0, C=0
08b2 : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
08b3 : 88                       dey             ;should not be executed
08b4 :                  brk_ret0                ;address of break return
08b4 : 08                       php             ;either SP or Y count will fail, if we do not hit
08b5 : 88                       dey
08b6 : 88                       dey
08b7 : 88                       dey
08b8 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
08ba : d0fe            >        bne *         ;failed not equal (non zero)
                        
08bc : e053                     cpx #'R'+1
                                trap_ne
08be : d0fe            >        bne *         ;failed not equal (non zero)
                        
08c0 : c045                     cpy #'K'-6
                                trap_ne
08c2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08c4 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
08c5 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
08c7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08c9 : ba                       tsx             ;sp?
08ca : e0ff                     cpx #$ff
                                trap_ne
08cc : d0fe            >        bne *         ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
08ce : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
08d0 : 48                       pha
08d1 : a9bd                     lda #$ff-'B'
08d3 : a2ad                     ldx #$ff-'R'
08d5 : a0b4                     ldy #$ff-'K'
08d7 : 28                       plp             ;N=1, V=1, Z=1, C=1
08d8 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
08d9 : 88                       dey             ;should not be executed
08da :                  brk_ret1                ;address of break return
08da : 08                       php             ;either SP or Y count will fail, if we do not hit
08db : 88                       dey
08dc : 88                       dey
08dd : 88                       dey
08de : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
08e0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08e2 : e0ae                     cpx #$ff-'R'+1
                                trap_ne
08e4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08e6 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
08e8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08ea : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
08eb : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
08ed : d0fe            >        bne *         ;failed not equal (non zero)
                        
08ef : ba                       tsx             ;sp?
08f0 : e0ff                     cpx #$ff
                                trap_ne
08f2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
08f4 : ad0002          >            lda test_case   ;previous test
08f7 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08f9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
08fb : a90c            >            lda #test_num   ;*** next tests' number
08fd : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
0900 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0902 : 48              >            pha         ;use stack to load status
0903 : 28              >            plp
                        
0904 : 18                       clc
                                tst_stat $ff-carry
0905 : 08              >            php         ;save status
0906 : 68              >            pla         ;use stack to retrieve status
0907 : 48              >            pha
                       >            cmp_flag $ff-carry
0908 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
090a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
090c : 28              >            plp         ;restore status
                        
090d : 38                       sec
                                tst_stat $ff
090e : 08              >            php         ;save status
090f : 68              >            pla         ;use stack to retrieve status
0910 : 48              >            pha
                       >            cmp_flag $ff
0911 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0913 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0915 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0916 : 58                       cli
                                tst_stat $ff-intdis
0917 : 08              >            php         ;save status
0918 : 68              >            pla         ;use stack to retrieve status
0919 : 48              >            pha
                       >            cmp_flag $ff-intdis
091a : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
091c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
091e : 28              >            plp         ;restore status
                        
091f : 78                       sei
                                tst_stat $ff
0920 : 08              >            php         ;save status
0921 : 68              >            pla         ;use stack to retrieve status
0922 : 48              >            pha
                       >            cmp_flag $ff
0923 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0925 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0927 : 28              >            plp         ;restore status
                        
                            endif
0928 : d8                       cld
                                tst_stat $ff-decmode
0929 : 08              >            php         ;save status
092a : 68              >            pla         ;use stack to retrieve status
092b : 48              >            pha
                       >            cmp_flag $ff-decmode
092c : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
092e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0930 : 28              >            plp         ;restore status
                        
0931 : f8                       sed
                                tst_stat $ff
0932 : 08              >            php         ;save status
0933 : 68              >            pla         ;use stack to retrieve status
0934 : 48              >            pha
                       >            cmp_flag $ff
0935 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0937 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0939 : 28              >            plp         ;restore status
                        
093a : b8                       clv
                                tst_stat $ff-overfl
093b : 08              >            php         ;save status
093c : 68              >            pla         ;use stack to retrieve status
093d : 48              >            pha
                       >            cmp_flag $ff-overfl
093e : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0940 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0942 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0943 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0945 : 48              >            pha         ;use stack to load status
0946 : 28              >            plp
                        
                                tst_stat 0
0947 : 08              >            php         ;save status
0948 : 68              >            pla         ;use stack to retrieve status
0949 : 48              >            pha
                       >            cmp_flag 0
094a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
094c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
094e : 28              >            plp         ;restore status
                        
094f : 38                       sec
                                tst_stat carry
0950 : 08              >            php         ;save status
0951 : 68              >            pla         ;use stack to retrieve status
0952 : 48              >            pha
                       >            cmp_flag carry
0953 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0955 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0957 : 28              >            plp         ;restore status
                        
0958 : 18                       clc
                                tst_stat 0  
0959 : 08              >            php         ;save status
095a : 68              >            pla         ;use stack to retrieve status
095b : 48              >            pha
                       >            cmp_flag 0  
095c : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
095e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0960 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0961 : 78                       sei
                                tst_stat intdis
0962 : 08              >            php         ;save status
0963 : 68              >            pla         ;use stack to retrieve status
0964 : 48              >            pha
                       >            cmp_flag intdis
0965 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0967 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0969 : 28              >            plp         ;restore status
                        
096a : 58                       cli
                                tst_stat 0
096b : 08              >            php         ;save status
096c : 68              >            pla         ;use stack to retrieve status
096d : 48              >            pha
                       >            cmp_flag 0
096e : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0970 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0972 : 28              >            plp         ;restore status
                        
                            endif  
0973 : f8                       sed
                                tst_stat decmode
0974 : 08              >            php         ;save status
0975 : 68              >            pla         ;use stack to retrieve status
0976 : 48              >            pha
                       >            cmp_flag decmode
0977 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0979 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
097b : 28              >            plp         ;restore status
                        
097c : d8                       cld
                                tst_stat 0  
097d : 08              >            php         ;save status
097e : 68              >            pla         ;use stack to retrieve status
097f : 48              >            pha
                       >            cmp_flag 0  
0980 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0982 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0984 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0985 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0987 : 48              >            pha         ;use stack to load status
0988 : 28              >            plp
                        
                                tst_stat overfl
0989 : 08              >            php         ;save status
098a : 68              >            pla         ;use stack to retrieve status
098b : 48              >            pha
                       >            cmp_flag overfl
098c : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
098e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0990 : 28              >            plp         ;restore status
                        
0991 : b8                       clv
                                tst_stat 0
0992 : 08              >            php         ;save status
0993 : 68              >            pla         ;use stack to retrieve status
0994 : 48              >            pha
                       >            cmp_flag 0
0995 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0997 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0999 : 28              >            plp         ;restore status
                        
                                next_test
099a : ad0002          >            lda test_case   ;previous test
099d : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
099f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
09a1 : a90d            >            lda #test_num   ;*** next tests' number
09a3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
09a6 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
09a8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
09aa : 48              >            pha         ;use stack to load status
09ab : 28              >            plp
                        
09ac : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
09ad : 08              >            php         ;save flags
09ae : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
09b0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09b2 : 68              >            pla         ;load status
09b3 : 48              >            pha
                       >            cmp_flag $ff-zero
09b4 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09b6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09b8 : 28              >            plp         ;restore status
                        
09b9 : e8                       inx             ;00
                                tst_x 0,$ff-minus
09ba : 08              >            php         ;save flags
09bb : e000            >            cpx #0     ;test result
                       >            trap_ne
09bd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09bf : 68              >            pla         ;load status
09c0 : 48              >            pha
                       >            cmp_flag $ff-minus
09c1 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09c3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09c5 : 28              >            plp         ;restore status
                        
09c6 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
09c7 : 08              >            php         ;save flags
09c8 : e001            >            cpx #1     ;test result
                       >            trap_ne
09ca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09cc : 68              >            pla         ;load status
09cd : 48              >            pha
                       >            cmp_flag $ff-minus-zero
09ce : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09d0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09d2 : 28              >            plp         ;restore status
                        
09d3 : ca                       dex             ;00
                                tst_x 0,$ff-minus
09d4 : 08              >            php         ;save flags
09d5 : e000            >            cpx #0     ;test result
                       >            trap_ne
09d7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09d9 : 68              >            pla         ;load status
09da : 48              >            pha
                       >            cmp_flag $ff-minus
09db : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09dd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09df : 28              >            plp         ;restore status
                        
09e0 : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
09e1 : 08              >            php         ;save flags
09e2 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
09e4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09e6 : 68              >            pla         ;load status
09e7 : 48              >            pha
                       >            cmp_flag $ff-zero
09e8 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09ea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09ec : 28              >            plp         ;restore status
                        
09ed : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
09ee : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
09f0 : 48              >            pha         ;use stack to load status
09f1 : 28              >            plp
                        
09f2 : e8                       inx             ;ff
                                tst_x $ff,minus
09f3 : 08              >            php         ;save flags
09f4 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
09f6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09f8 : 68              >            pla         ;load status
09f9 : 48              >            pha
                       >            cmp_flag minus
09fa : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09fc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09fe : 28              >            plp         ;restore status
                        
09ff : e8                       inx             ;00
                                tst_x 0,zero
0a00 : 08              >            php         ;save flags
0a01 : e000            >            cpx #0     ;test result
                       >            trap_ne
0a03 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a05 : 68              >            pla         ;load status
0a06 : 48              >            pha
                       >            cmp_flag zero
0a07 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a09 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a0b : 28              >            plp         ;restore status
                        
0a0c : e8                       inx             ;01
                                tst_x 1,0
0a0d : 08              >            php         ;save flags
0a0e : e001            >            cpx #1     ;test result
                       >            trap_ne
0a10 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a12 : 68              >            pla         ;load status
0a13 : 48              >            pha
                       >            cmp_flag 0
0a14 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a16 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a18 : 28              >            plp         ;restore status
                        
0a19 : ca                       dex             ;00
                                tst_x 0,zero
0a1a : 08              >            php         ;save flags
0a1b : e000            >            cpx #0     ;test result
                       >            trap_ne
0a1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a1f : 68              >            pla         ;load status
0a20 : 48              >            pha
                       >            cmp_flag zero
0a21 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a23 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a25 : 28              >            plp         ;restore status
                        
0a26 : ca                       dex             ;ff
                                tst_x $ff,minus
0a27 : 08              >            php         ;save flags
0a28 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0a2a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a2c : 68              >            pla         ;load status
0a2d : 48              >            pha
                       >            cmp_flag minus
0a2e : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a30 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a32 : 28              >            plp         ;restore status
                        
                        
0a33 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0a35 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a37 : 48              >            pha         ;use stack to load status
0a38 : 28              >            plp
                        
0a39 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0a3a : 08              >            php         ;save flags
0a3b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0a3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a3f : 68              >            pla         ;load status
0a40 : 48              >            pha
                       >            cmp_flag $ff-zero
0a41 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a43 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a45 : 28              >            plp         ;restore status
                        
0a46 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0a47 : 08              >            php         ;save flags
0a48 : c000            >            cpy #0     ;test result
                       >            trap_ne
0a4a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a4c : 68              >            pla         ;load status
0a4d : 48              >            pha
                       >            cmp_flag $ff-minus
0a4e : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a50 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a52 : 28              >            plp         ;restore status
                        
0a53 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0a54 : 08              >            php         ;save flags
0a55 : c001            >            cpy #1     ;test result
                       >            trap_ne
0a57 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a59 : 68              >            pla         ;load status
0a5a : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0a5b : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a5d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a5f : 28              >            plp         ;restore status
                        
0a60 : 88                       dey             ;00
                                tst_y 0,$ff-minus
0a61 : 08              >            php         ;save flags
0a62 : c000            >            cpy #0     ;test result
                       >            trap_ne
0a64 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a66 : 68              >            pla         ;load status
0a67 : 48              >            pha
                       >            cmp_flag $ff-minus
0a68 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a6a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a6c : 28              >            plp         ;restore status
                        
0a6d : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0a6e : 08              >            php         ;save flags
0a6f : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0a71 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a73 : 68              >            pla         ;load status
0a74 : 48              >            pha
                       >            cmp_flag $ff-zero
0a75 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a77 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a79 : 28              >            plp         ;restore status
                        
0a7a : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0a7b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a7d : 48              >            pha         ;use stack to load status
0a7e : 28              >            plp
                        
0a7f : c8                       iny             ;ff
                                tst_y $ff,0+minus
0a80 : 08              >            php         ;save flags
0a81 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0a83 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a85 : 68              >            pla         ;load status
0a86 : 48              >            pha
                       >            cmp_flag 0+minus
0a87 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a89 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a8b : 28              >            plp         ;restore status
                        
0a8c : c8                       iny             ;00
                                tst_y 0,zero
0a8d : 08              >            php         ;save flags
0a8e : c000            >            cpy #0     ;test result
                       >            trap_ne
0a90 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a92 : 68              >            pla         ;load status
0a93 : 48              >            pha
                       >            cmp_flag zero
0a94 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a96 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a98 : 28              >            plp         ;restore status
                        
0a99 : c8                       iny             ;01
                                tst_y 1,0
0a9a : 08              >            php         ;save flags
0a9b : c001            >            cpy #1     ;test result
                       >            trap_ne
0a9d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a9f : 68              >            pla         ;load status
0aa0 : 48              >            pha
                       >            cmp_flag 0
0aa1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aa3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0aa5 : 28              >            plp         ;restore status
                        
0aa6 : 88                       dey             ;00
                                tst_y 0,zero
0aa7 : 08              >            php         ;save flags
0aa8 : c000            >            cpy #0     ;test result
                       >            trap_ne
0aaa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0aac : 68              >            pla         ;load status
0aad : 48              >            pha
                       >            cmp_flag zero
0aae : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ab0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ab2 : 28              >            plp         ;restore status
                        
0ab3 : 88                       dey             ;ff
                                tst_y $ff,minus
0ab4 : 08              >            php         ;save flags
0ab5 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0ab7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ab9 : 68              >            pla         ;load status
0aba : 48              >            pha
                       >            cmp_flag minus
0abb : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0abd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0abf : 28              >            plp         ;restore status
                        
                                        
0ac0 : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0ac2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ac4 : 48              >            pha         ;use stack to load status
0ac5 : 28              >            plp
                        
0ac6 : 8a                       txa
                                tst_a $ff,$ff-zero
0ac7 : 08              >            php         ;save flags
0ac8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0aca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0acc : 68              >            pla         ;load status
0acd : 48              >            pha
                       >            cmp_flag $ff-zero
0ace : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ad0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ad2 : 28              >            plp         ;restore status
                        
0ad3 : 08                       php
0ad4 : e8                       inx             ;00
0ad5 : 28                       plp
0ad6 : 8a                       txa
                                tst_a 0,$ff-minus
0ad7 : 08              >            php         ;save flags
0ad8 : c900            >            cmp #0     ;test result
                       >            trap_ne
0ada : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0adc : 68              >            pla         ;load status
0add : 48              >            pha
                       >            cmp_flag $ff-minus
0ade : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ae0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ae2 : 28              >            plp         ;restore status
                        
0ae3 : 08                       php
0ae4 : e8                       inx             ;01
0ae5 : 28                       plp
0ae6 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0ae7 : 08              >            php         ;save flags
0ae8 : c901            >            cmp #1     ;test result
                       >            trap_ne
0aea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0aec : 68              >            pla         ;load status
0aed : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0aee : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0af0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0af2 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0af3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0af5 : 48              >            pha         ;use stack to load status
0af6 : 28              >            plp
                        
0af7 : 8a                       txa
                                tst_a 1,0
0af8 : 08              >            php         ;save flags
0af9 : c901            >            cmp #1     ;test result
                       >            trap_ne
0afb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0afd : 68              >            pla         ;load status
0afe : 48              >            pha
                       >            cmp_flag 0
0aff : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b01 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b03 : 28              >            plp         ;restore status
                        
0b04 : 08                       php
0b05 : ca                       dex             ;00
0b06 : 28                       plp
0b07 : 8a                       txa
                                tst_a 0,zero
0b08 : 08              >            php         ;save flags
0b09 : c900            >            cmp #0     ;test result
                       >            trap_ne
0b0b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b0d : 68              >            pla         ;load status
0b0e : 48              >            pha
                       >            cmp_flag zero
0b0f : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b11 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b13 : 28              >            plp         ;restore status
                        
0b14 : 08                       php
0b15 : ca                       dex             ;ff
0b16 : 28                       plp
0b17 : 8a                       txa
                                tst_a $ff,minus
0b18 : 08              >            php         ;save flags
0b19 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0b1b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b1d : 68              >            pla         ;load status
0b1e : 48              >            pha
                       >            cmp_flag minus
0b1f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b23 : 28              >            plp         ;restore status
                        
                                                
0b24 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0b26 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b28 : 48              >            pha         ;use stack to load status
0b29 : 28              >            plp
                        
0b2a : 98                       tya
                                tst_a $ff,$ff-zero
0b2b : 08              >            php         ;save flags
0b2c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0b2e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b30 : 68              >            pla         ;load status
0b31 : 48              >            pha
                       >            cmp_flag $ff-zero
0b32 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b34 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b36 : 28              >            plp         ;restore status
                        
0b37 : 08                       php
0b38 : c8                       iny             ;00
0b39 : 28                       plp
0b3a : 98                       tya
                                tst_a 0,$ff-minus
0b3b : 08              >            php         ;save flags
0b3c : c900            >            cmp #0     ;test result
                       >            trap_ne
0b3e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b40 : 68              >            pla         ;load status
0b41 : 48              >            pha
                       >            cmp_flag $ff-minus
0b42 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b44 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b46 : 28              >            plp         ;restore status
                        
0b47 : 08                       php
0b48 : c8                       iny             ;01
0b49 : 28                       plp
0b4a : 98                       tya
                                tst_a 1,$ff-minus-zero
0b4b : 08              >            php         ;save flags
0b4c : c901            >            cmp #1     ;test result
                       >            trap_ne
0b4e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b50 : 68              >            pla         ;load status
0b51 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b52 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b54 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b56 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0b57 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b59 : 48              >            pha         ;use stack to load status
0b5a : 28              >            plp
                        
0b5b : 98                       tya
                                tst_a 1,0
0b5c : 08              >            php         ;save flags
0b5d : c901            >            cmp #1     ;test result
                       >            trap_ne
0b5f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b61 : 68              >            pla         ;load status
0b62 : 48              >            pha
                       >            cmp_flag 0
0b63 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b65 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b67 : 28              >            plp         ;restore status
                        
0b68 : 08                       php
0b69 : 88                       dey             ;00
0b6a : 28                       plp
0b6b : 98                       tya
                                tst_a 0,zero
0b6c : 08              >            php         ;save flags
0b6d : c900            >            cmp #0     ;test result
                       >            trap_ne
0b6f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b71 : 68              >            pla         ;load status
0b72 : 48              >            pha
                       >            cmp_flag zero
0b73 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b75 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b77 : 28              >            plp         ;restore status
                        
0b78 : 08                       php
0b79 : 88                       dey             ;ff
0b7a : 28                       plp
0b7b : 98                       tya
                                tst_a $ff,minus
0b7c : 08              >            php         ;save flags
0b7d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0b7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b81 : 68              >            pla         ;load status
0b82 : 48              >            pha
                       >            cmp_flag minus
0b83 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b85 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b87 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0b88 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0b8a : 48                       pha
0b8b : a2ff                     ldx #$ff        ;ff
0b8d : 8a                       txa
0b8e : 28                       plp             
0b8f : a8                       tay
                                tst_y $ff,$ff-zero
0b90 : 08              >            php         ;save flags
0b91 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b95 : 68              >            pla         ;load status
0b96 : 48              >            pha
                       >            cmp_flag $ff-zero
0b97 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b99 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b9b : 28              >            plp         ;restore status
                        
0b9c : 08                       php
0b9d : e8                       inx             ;00
0b9e : 8a                       txa
0b9f : 28                       plp
0ba0 : a8                       tay
                                tst_y 0,$ff-minus
0ba1 : 08              >            php         ;save flags
0ba2 : c000            >            cpy #0     ;test result
                       >            trap_ne
0ba4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ba6 : 68              >            pla         ;load status
0ba7 : 48              >            pha
                       >            cmp_flag $ff-minus
0ba8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0baa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bac : 28              >            plp         ;restore status
                        
0bad : 08                       php
0bae : e8                       inx             ;01
0baf : 8a                       txa
0bb0 : 28                       plp
0bb1 : a8                       tay
                                tst_y 1,$ff-minus-zero
0bb2 : 08              >            php         ;save flags
0bb3 : c001            >            cpy #1     ;test result
                       >            trap_ne
0bb5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bb7 : 68              >            pla         ;load status
0bb8 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0bb9 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bbb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bbd : 28              >            plp         ;restore status
                        
                                load_flag 0
0bbe : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0bc0 : 48                       pha
0bc1 : a900                     lda #0
0bc3 : 8a                       txa
0bc4 : 28                       plp
0bc5 : a8                       tay
                                tst_y 1,0
0bc6 : 08              >            php         ;save flags
0bc7 : c001            >            cpy #1     ;test result
                       >            trap_ne
0bc9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bcb : 68              >            pla         ;load status
0bcc : 48              >            pha
                       >            cmp_flag 0
0bcd : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bcf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bd1 : 28              >            plp         ;restore status
                        
0bd2 : 08                       php
0bd3 : ca                       dex             ;00
0bd4 : 8a                       txa
0bd5 : 28                       plp
0bd6 : a8                       tay
                                tst_y 0,zero
0bd7 : 08              >            php         ;save flags
0bd8 : c000            >            cpy #0     ;test result
                       >            trap_ne
0bda : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bdc : 68              >            pla         ;load status
0bdd : 48              >            pha
                       >            cmp_flag zero
0bde : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0be0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0be2 : 28              >            plp         ;restore status
                        
0be3 : 08                       php
0be4 : ca                       dex             ;ff
0be5 : 8a                       txa
0be6 : 28                       plp
0be7 : a8                       tay
                                tst_y $ff,minus
0be8 : 08              >            php         ;save flags
0be9 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0beb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bed : 68              >            pla         ;load status
0bee : 48              >            pha
                       >            cmp_flag minus
0bef : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bf1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bf3 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0bf4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0bf6 : 48                       pha
0bf7 : a0ff                     ldy #$ff        ;ff
0bf9 : 98                       tya
0bfa : 28                       plp
0bfb : aa                       tax
                                tst_x $ff,$ff-zero
0bfc : 08              >            php         ;save flags
0bfd : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0bff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c01 : 68              >            pla         ;load status
0c02 : 48              >            pha
                       >            cmp_flag $ff-zero
0c03 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c05 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c07 : 28              >            plp         ;restore status
                        
0c08 : 08                       php
0c09 : c8                       iny             ;00
0c0a : 98                       tya
0c0b : 28                       plp
0c0c : aa                       tax
                                tst_x 0,$ff-minus
0c0d : 08              >            php         ;save flags
0c0e : e000            >            cpx #0     ;test result
                       >            trap_ne
0c10 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c12 : 68              >            pla         ;load status
0c13 : 48              >            pha
                       >            cmp_flag $ff-minus
0c14 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c16 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c18 : 28              >            plp         ;restore status
                        
0c19 : 08                       php
0c1a : c8                       iny             ;01
0c1b : 98                       tya
0c1c : 28                       plp
0c1d : aa                       tax
                                tst_x 1,$ff-minus-zero
0c1e : 08              >            php         ;save flags
0c1f : e001            >            cpx #1     ;test result
                       >            trap_ne
0c21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c23 : 68              >            pla         ;load status
0c24 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c25 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c27 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c29 : 28              >            plp         ;restore status
                        
                                load_flag 0
0c2a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0c2c : 48                       pha
0c2d : a900                     lda #0          ;preset status
0c2f : 98                       tya
0c30 : 28                       plp
0c31 : aa                       tax
                                tst_x 1,0
0c32 : 08              >            php         ;save flags
0c33 : e001            >            cpx #1     ;test result
                       >            trap_ne
0c35 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c37 : 68              >            pla         ;load status
0c38 : 48              >            pha
                       >            cmp_flag 0
0c39 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c3b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c3d : 28              >            plp         ;restore status
                        
0c3e : 08                       php
0c3f : 88                       dey             ;00
0c40 : 98                       tya
0c41 : 28                       plp
0c42 : aa                       tax
                                tst_x 0,zero
0c43 : 08              >            php         ;save flags
0c44 : e000            >            cpx #0     ;test result
                       >            trap_ne
0c46 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c48 : 68              >            pla         ;load status
0c49 : 48              >            pha
                       >            cmp_flag zero
0c4a : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c4c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c4e : 28              >            plp         ;restore status
                        
0c4f : 08                       php
0c50 : 88                       dey             ;ff
0c51 : 98                       tya
0c52 : 28                       plp
0c53 : aa                       tax
                                tst_x $ff,minus
0c54 : 08              >            php         ;save flags
0c55 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0c57 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c59 : 68              >            pla         ;load status
0c5a : 48              >            pha
                       >            cmp_flag minus
0c5b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c5d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c5f : 28              >            plp         ;restore status
                        
                                next_test
0c60 : ad0002          >            lda test_case   ;previous test
0c63 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0c65 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0c67 : a90e            >            lda #test_num   ;*** next tests' number
0c69 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0c6c : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0c6e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c70 : 48              >            pha         ;use stack to load status
0c71 : 28              >            plp
                        
0c72 : 9a                       txs
0c73 : 08                       php
0c74 : ad0101                   lda $101
                                cmp_flag $ff
0c77 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0c79 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0c7b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c7d : 48              >            pha         ;use stack to load status
0c7e : 28              >            plp
                        
0c7f : 9a                       txs
0c80 : 08                       php
0c81 : ad0101                   lda $101
                                cmp_flag 0
0c84 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0c86 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0c88 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0c89 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c8b : 48              >            pha         ;use stack to load status
0c8c : 28              >            plp
                        
0c8d : 9a                       txs
0c8e : 08                       php
0c8f : ad0001                   lda $100
                                cmp_flag $ff
0c92 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0c94 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0c96 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c98 : 48              >            pha         ;use stack to load status
0c99 : 28              >            plp
                        
0c9a : 9a                       txs
0c9b : 08                       php
0c9c : ad0001                   lda $100
                                cmp_flag 0
0c9f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0ca1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ca3 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0ca4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ca6 : 48              >            pha         ;use stack to load status
0ca7 : 28              >            plp
                        
0ca8 : 9a                       txs
0ca9 : 08                       php
0caa : adff01                   lda $1ff
                                cmp_flag $ff
0cad : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0caf : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0cb1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0cb3 : 48              >            pha         ;use stack to load status
0cb4 : 28              >            plp
                        
0cb5 : 9a                       txs
0cb6 : 08                       php
0cb7 : adff01                   lda $1ff
                                cmp_flag 0
0cba : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
0cbc : a201                     ldx #1
0cbe : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0cbf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cc1 : 48              >            pha         ;use stack to load status
0cc2 : 28              >            plp
                        
0cc3 : ba                       tsx             ;clears Z, N
0cc4 : 08                       php             ;sp=00
0cc5 : e001                     cpx #1
                                trap_ne
0cc7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0cc9 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0ccc : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0cce : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0cd0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cd2 : 48              >            pha         ;use stack to load status
0cd3 : 28              >            plp
                        
0cd4 : ba                       tsx             ;clears N, sets Z
0cd5 : 08                       php             ;sp=ff
0cd6 : e000                     cpx #0
                                trap_ne
0cd8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0cda : ad0001                   lda $100
                                cmp_flag $ff-minus
0cdd : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0cdf : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0ce1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ce3 : 48              >            pha         ;use stack to load status
0ce4 : 28              >            plp
                        
0ce5 : ba                       tsx             ;clears N, sets Z
0ce6 : 08                       php             ;sp=fe
0ce7 : e0ff                     cpx #$ff
                                trap_ne
0ce9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ceb : adff01                   lda $1ff
                                cmp_flag $ff-zero
0cee : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0cf0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
0cf2 : a201                     ldx #1
0cf4 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0cf5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0cf7 : 48              >            pha         ;use stack to load status
0cf8 : 28              >            plp
                        
0cf9 : ba                       tsx             ;clears Z, N
0cfa : 08                       php             ;sp=00
0cfb : e001                     cpx #1
                                trap_ne
0cfd : d0fe            >        bne *         ;failed not equal (non zero)
                        
0cff : ad0101                   lda $101
                                cmp_flag 0
0d02 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d04 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d06 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d08 : 48              >            pha         ;use stack to load status
0d09 : 28              >            plp
                        
0d0a : ba                       tsx             ;clears N, sets Z
0d0b : 08                       php             ;sp=ff
0d0c : e000                     cpx #0
                                trap_ne
0d0e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d10 : ad0001                   lda $100
                                cmp_flag zero
0d13 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d15 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d17 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d19 : 48              >            pha         ;use stack to load status
0d1a : 28              >            plp
                        
0d1b : ba                       tsx             ;clears N, sets Z
0d1c : 08                       php             ;sp=fe
0d1d : e0ff                     cpx #$ff
                                trap_ne
0d1f : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d21 : adff01                   lda $1ff
                                cmp_flag minus
0d24 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d26 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d28 : 68                       pla             ;sp=ff
                                next_test
0d29 : ad0002          >            lda test_case   ;previous test
0d2c : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d2e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0d30 : a90f            >            lda #test_num   ;*** next tests' number
0d32 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0d35 : a003                     ldy #3
0d37 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0d37 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d39 : 48              >            pha         ;use stack to load status
0d3a : 28              >            plp
                        
0d3b : b60b                     ldx zp1,y
0d3d : 08                       php         ;test stores do not alter flags
0d3e : 8a                       txa
0d3f : 49c3                     eor #$c3
0d41 : 28                       plp
0d42 : 990302                   sta abst,y
0d45 : 08                       php         ;flags after load/store sequence
0d46 : 49c3                     eor #$c3
0d48 : d91802                   cmp abs1,y  ;test result
                                trap_ne
0d4b : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d4d : 68                       pla         ;load status
                                eor_flag 0
0d4e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0d50 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0d53 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d55 : 88                       dey
0d56 : 10df                     bpl tldx                  
                        
0d58 : a003                     ldy #3
0d5a :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0d5a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d5c : 48              >            pha         ;use stack to load status
0d5d : 28              >            plp
                        
0d5e : b60b                     ldx zp1,y
0d60 : 08                       php         ;test stores do not alter flags
0d61 : 8a                       txa
0d62 : 49c3                     eor #$c3
0d64 : 28                       plp
0d65 : 990302                   sta abst,y
0d68 : 08                       php         ;flags after load/store sequence
0d69 : 49c3                     eor #$c3
0d6b : d91802                   cmp abs1,y  ;test result
                                trap_ne
0d6e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d70 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0d71 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0d73 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0d76 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d78 : 88                       dey
0d79 : 10df                     bpl tldx1                  
                        
0d7b : a003                     ldy #3
0d7d :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0d7d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d7f : 48              >            pha         ;use stack to load status
0d80 : 28              >            plp
                        
0d81 : be1802                   ldx abs1,y
0d84 : 08                       php         ;test stores do not alter flags
0d85 : 8a                       txa
0d86 : 49c3                     eor #$c3
0d88 : aa                       tax
0d89 : 28                       plp
0d8a : 9602                     stx zpt,y
0d8c : 08                       php         ;flags after load/store sequence
0d8d : 49c3                     eor #$c3
0d8f : d90b00                   cmp zp1,y   ;test result
                                trap_ne
0d92 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d94 : 68                       pla         ;load status
                                eor_flag 0
0d95 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0d97 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0d9a : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d9c : 88                       dey
0d9d : 10de                     bpl tldx2                  
                        
0d9f : a003                     ldy #3
0da1 :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0da1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0da3 : 48              >            pha         ;use stack to load status
0da4 : 28              >            plp
                        
0da5 : be1802                   ldx abs1,y
0da8 : 08                       php         ;test stores do not alter flags
0da9 : 8a                       txa
0daa : 49c3                     eor #$c3
0dac : aa                       tax
0dad : 28                       plp
0dae : 9602                     stx zpt,y
0db0 : 08                       php         ;flags after load/store sequence
0db1 : 49c3                     eor #$c3
0db3 : d90b00                   cmp zp1,y   ;test result
                                trap_ne
0db6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0db8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0db9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0dbb : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0dbe : d0fe            >        bne *         ;failed not equal (non zero)
                        
0dc0 : 88                       dey
0dc1 : 10de                     bpl tldx3
                                
0dc3 : a003                     ldy #3      ;testing store result
0dc5 : a200                     ldx #0
0dc7 : b90200           tstx    lda zpt,y
0dca : 49c3                     eor #$c3
0dcc : d90b00                   cmp zp1,y
                                trap_ne     ;store to zp data
0dcf : d0fe            >        bne *         ;failed not equal (non zero)
                        
0dd1 : 9602                     stx zpt,y   ;clear                
0dd3 : b90302                   lda abst,y
0dd6 : 49c3                     eor #$c3
0dd8 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
0ddb : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ddd : 8a                       txa
0dde : 990302                   sta abst,y  ;clear                
0de1 : 88                       dey
0de2 : 10e3                     bpl tstx
                                next_test
0de4 : ad0002          >            lda test_case   ;previous test
0de7 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0de9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0deb : a910            >            lda #test_num   ;*** next tests' number
0ded : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0df0 : a0fd                     ldy #3+$fa
0df2 : b611             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0df4 : 8a                       txa
0df5 : 990901                   sta abst-$fa,y      ;no STX abs,y!
0df8 : 88                       dey
0df9 : c0fa                     cpy #$fa
0dfb : b0f5                     bcs tldx4                  
0dfd : a0fd                     ldy #3+$fa
0dff : be1e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0e02 : 9608                     stx zpt-$fa&$ff,y
0e04 : 88                       dey
0e05 : c0fa                     cpy #$fa
0e07 : b0f6                     bcs tldx5                  
0e09 : a003                     ldy #3      ;testing wraparound result
0e0b : a200                     ldx #0
0e0d : b90200           tstx1   lda zpt,y
0e10 : d90b00                   cmp zp1,y
                                trap_ne     ;store to zp data
0e13 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e15 : 9602                     stx zpt,y   ;clear                
0e17 : b90302                   lda abst,y
0e1a : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
0e1d : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e1f : 8a                       txa
0e20 : 990302                   sta abst,y  ;clear                
0e23 : 88                       dey
0e24 : 10e7                     bpl tstx1
                                next_test
0e26 : ad0002          >            lda test_case   ;previous test
0e29 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e2b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0e2d : a911            >            lda #test_num   ;*** next tests' number
0e2f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0e32 : a203                     ldx #3
0e34 :                  tldy    
                                set_stat 0
                       >            load_flag 0
0e34 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e36 : 48              >            pha         ;use stack to load status
0e37 : 28              >            plp
                        
0e38 : b40b                     ldy zp1,x
0e3a : 08                       php         ;test stores do not alter flags
0e3b : 98                       tya
0e3c : 49c3                     eor #$c3
0e3e : 28                       plp
0e3f : 9d0302                   sta abst,x
0e42 : 08                       php         ;flags after load/store sequence
0e43 : 49c3                     eor #$c3
0e45 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
0e48 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e4a : 68                       pla         ;load status
                                eor_flag 0
0e4b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e4d : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0e50 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e52 : ca                       dex
0e53 : 10df                     bpl tldy                  
                        
0e55 : a203                     ldx #3
0e57 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0e57 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e59 : 48              >            pha         ;use stack to load status
0e5a : 28              >            plp
                        
0e5b : b40b                     ldy zp1,x
0e5d : 08                       php         ;test stores do not alter flags
0e5e : 98                       tya
0e5f : 49c3                     eor #$c3
0e61 : 28                       plp
0e62 : 9d0302                   sta abst,x
0e65 : 08                       php         ;flags after load/store sequence
0e66 : 49c3                     eor #$c3
0e68 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
0e6b : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e6d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e6e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e70 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0e73 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e75 : ca                       dex
0e76 : 10df                     bpl tldy1                  
                        
0e78 : a203                     ldx #3
0e7a :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0e7a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e7c : 48              >            pha         ;use stack to load status
0e7d : 28              >            plp
                        
0e7e : bc1802                   ldy abs1,x
0e81 : 08                       php         ;test stores do not alter flags
0e82 : 98                       tya
0e83 : 49c3                     eor #$c3
0e85 : a8                       tay
0e86 : 28                       plp
0e87 : 9402                     sty zpt,x
0e89 : 08                       php         ;flags after load/store sequence
0e8a : 49c3                     eor #$c3
0e8c : d50b                     cmp zp1,x   ;test result
                                trap_ne
0e8e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e90 : 68                       pla         ;load status
                                eor_flag 0
0e91 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e93 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0e96 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e98 : ca                       dex
0e99 : 10df                     bpl tldy2                  
                        
0e9b : a203                     ldx #3
0e9d :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0e9d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e9f : 48              >            pha         ;use stack to load status
0ea0 : 28              >            plp
                        
0ea1 : bc1802                   ldy abs1,x
0ea4 : 08                       php         ;test stores do not alter flags
0ea5 : 98                       tya
0ea6 : 49c3                     eor #$c3
0ea8 : a8                       tay
0ea9 : 28                       plp
0eaa : 9402                     sty zpt,x
0eac : 08                       php         ;flags after load/store sequence
0ead : 49c3                     eor #$c3
0eaf : d50b                     cmp zp1,x   ;test result
                                trap_ne
0eb1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0eb3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0eb4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0eb6 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0eb9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ebb : ca                       dex
0ebc : 10df                     bpl tldy3
                        
0ebe : a203                     ldx #3      ;testing store result
0ec0 : a000                     ldy #0
0ec2 : b502             tsty    lda zpt,x
0ec4 : 49c3                     eor #$c3
0ec6 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0ec8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0eca : 9402                     sty zpt,x   ;clear                
0ecc : bd0302                   lda abst,x
0ecf : 49c3                     eor #$c3
0ed1 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0ed4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ed6 : 8a                       txa
0ed7 : 9d0302                   sta abst,x  ;clear                
0eda : ca                       dex
0edb : 10e5                     bpl tsty
                                next_test
0edd : ad0002          >            lda test_case   ;previous test
0ee0 : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ee2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
0ee4 : a912            >            lda #test_num   ;*** next tests' number
0ee6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
0ee9 : a2fd                     ldx #3+$fa
0eeb : b411             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
0eed : 98                       tya
0eee : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
0ef1 : ca                       dex
0ef2 : e0fa                     cpx #$fa
0ef4 : b0f5                     bcs tldy4                  
0ef6 : a2fd                     ldx #3+$fa
0ef8 : bc1e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
0efb : 9408                     sty zpt-$fa&$ff,x
0efd : ca                       dex
0efe : e0fa                     cpx #$fa
0f00 : b0f6                     bcs tldy5                  
0f02 : a203                     ldx #3      ;testing wraparound result
0f04 : a000                     ldy #0
0f06 : b502             tsty1   lda zpt,x
0f08 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0f0a : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f0c : 9402                     sty zpt,x   ;clear                
0f0e : bd0302                   lda abst,x
0f11 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0f14 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f16 : 8a                       txa
0f17 : 9d0302                   sta abst,x  ;clear                
0f1a : ca                       dex
0f1b : 10e9                     bpl tsty1
                                next_test
0f1d : ad0002          >            lda test_case   ;previous test
0f20 : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f22 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
0f24 : a913            >            lda #test_num   ;*** next tests' number
0f26 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
0f29 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
0f2b : 48              >            pha         ;use stack to load status
0f2c : 28              >            plp
                        
0f2d : a60b                     ldx zp1
0f2f : 08                       php         ;test stores do not alter flags
0f30 : 8a                       txa
0f31 : 49c3                     eor #$c3
0f33 : aa                       tax
0f34 : 28                       plp
0f35 : 8e0302                   stx abst
0f38 : 08                       php         ;flags after load/store sequence
0f39 : 49c3                     eor #$c3
0f3b : aa                       tax
0f3c : e0c3                     cpx #$c3    ;test result
                                trap_ne
0f3e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f40 : 68                       pla         ;load status
                                eor_flag 0
0f41 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f43 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
0f46 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0f48 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f4a : 48              >            pha         ;use stack to load status
0f4b : 28              >            plp
                        
0f4c : a60c                     ldx zp1+1
0f4e : 08                       php         ;test stores do not alter flags
0f4f : 8a                       txa
0f50 : 49c3                     eor #$c3
0f52 : aa                       tax
0f53 : 28                       plp
0f54 : 8e0402                   stx abst+1
0f57 : 08                       php         ;flags after load/store sequence
0f58 : 49c3                     eor #$c3
0f5a : aa                       tax
0f5b : e082                     cpx #$82    ;test result
                                trap_ne
0f5d : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f5f : 68                       pla         ;load status
                                eor_flag 0
0f60 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f62 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
0f65 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0f67 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f69 : 48              >            pha         ;use stack to load status
0f6a : 28              >            plp
                        
0f6b : a60d                     ldx zp1+2
0f6d : 08                       php         ;test stores do not alter flags
0f6e : 8a                       txa
0f6f : 49c3                     eor #$c3
0f71 : aa                       tax
0f72 : 28                       plp
0f73 : 8e0502                   stx abst+2
0f76 : 08                       php         ;flags after load/store sequence
0f77 : 49c3                     eor #$c3
0f79 : aa                       tax
0f7a : e041                     cpx #$41    ;test result
                                trap_ne
0f7c : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f7e : 68                       pla         ;load status
                                eor_flag 0
0f7f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f81 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
0f84 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0f86 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f88 : 48              >            pha         ;use stack to load status
0f89 : 28              >            plp
                        
0f8a : a60e                     ldx zp1+3
0f8c : 08                       php         ;test stores do not alter flags
0f8d : 8a                       txa
0f8e : 49c3                     eor #$c3
0f90 : aa                       tax
0f91 : 28                       plp
0f92 : 8e0602                   stx abst+3
0f95 : 08                       php         ;flags after load/store sequence
0f96 : 49c3                     eor #$c3
0f98 : aa                       tax
0f99 : e000                     cpx #0      ;test result
                                trap_ne
0f9b : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f9d : 68                       pla         ;load status
                                eor_flag 0
0f9e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0fa0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
0fa3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
0fa5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fa7 : 48              >            pha         ;use stack to load status
0fa8 : 28              >            plp
                        
0fa9 : a60b                     ldx zp1  
0fab : 08                       php         ;test stores do not alter flags
0fac : 8a                       txa
0fad : 49c3                     eor #$c3
0faf : aa                       tax
0fb0 : 28                       plp
0fb1 : 8e0302                   stx abst  
0fb4 : 08                       php         ;flags after load/store sequence
0fb5 : 49c3                     eor #$c3
0fb7 : aa                       tax
0fb8 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
0fba : d0fe            >        bne *         ;failed not equal (non zero)
                        
0fbc : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fbd : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0fbf : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
0fc2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0fc4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fc6 : 48              >            pha         ;use stack to load status
0fc7 : 28              >            plp
                        
0fc8 : a60c                     ldx zp1+1
0fca : 08                       php         ;test stores do not alter flags
0fcb : 8a                       txa
0fcc : 49c3                     eor #$c3
0fce : aa                       tax
0fcf : 28                       plp
0fd0 : 8e0402                   stx abst+1
0fd3 : 08                       php         ;flags after load/store sequence
0fd4 : 49c3                     eor #$c3
0fd6 : aa                       tax
0fd7 : e082                     cpx #$82    ;test result
                                trap_ne
0fd9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0fdb : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fdc : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0fde : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
0fe1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0fe3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fe5 : 48              >            pha         ;use stack to load status
0fe6 : 28              >            plp
                        
0fe7 : a60d                     ldx zp1+2
0fe9 : 08                       php         ;test stores do not alter flags
0fea : 8a                       txa
0feb : 49c3                     eor #$c3
0fed : aa                       tax
0fee : 28                       plp
0fef : 8e0502                   stx abst+2
0ff2 : 08                       php         ;flags after load/store sequence
0ff3 : 49c3                     eor #$c3
0ff5 : aa                       tax
0ff6 : e041                     cpx #$41    ;test result
                                trap_ne     ;
0ff8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ffa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0ffb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0ffd : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1000 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1002 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1004 : 48              >            pha         ;use stack to load status
1005 : 28              >            plp
                        
1006 : a60e                     ldx zp1+3
1008 : 08                       php         ;test stores do not alter flags
1009 : 8a                       txa
100a : 49c3                     eor #$c3
100c : aa                       tax
100d : 28                       plp
100e : 8e0602                   stx abst+3
1011 : 08                       php         ;flags after load/store sequence
1012 : 49c3                     eor #$c3
1014 : aa                       tax
1015 : e000                     cpx #0      ;test result
                                trap_ne
1017 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1019 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
101a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
101c : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
101f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
1021 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1023 : 48              >            pha         ;use stack to load status
1024 : 28              >            plp
                        
1025 : ae1802                   ldx abs1  
1028 : 08                       php         ;test stores do not alter flags
1029 : 8a                       txa
102a : 49c3                     eor #$c3
102c : aa                       tax
102d : 28                       plp
102e : 8602                     stx zpt  
1030 : 08                       php         ;flags after load/store sequence
1031 : 49c3                     eor #$c3
1033 : c50b                     cmp zp1     ;test result
                                trap_ne
1035 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1037 : 68                       pla         ;load status
                                eor_flag 0
1038 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
103a : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
103d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
103f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1041 : 48              >            pha         ;use stack to load status
1042 : 28              >            plp
                        
1043 : ae1902                   ldx abs1+1
1046 : 08                       php         ;test stores do not alter flags
1047 : 8a                       txa
1048 : 49c3                     eor #$c3
104a : aa                       tax
104b : 28                       plp
104c : 8603                     stx zpt+1
104e : 08                       php         ;flags after load/store sequence
104f : 49c3                     eor #$c3
1051 : c50c                     cmp zp1+1   ;test result
                                trap_ne
1053 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1055 : 68                       pla         ;load status
                                eor_flag 0
1056 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1058 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
105b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
105d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
105f : 48              >            pha         ;use stack to load status
1060 : 28              >            plp
                        
1061 : ae1a02                   ldx abs1+2
1064 : 08                       php         ;test stores do not alter flags
1065 : 8a                       txa
1066 : 49c3                     eor #$c3
1068 : aa                       tax
1069 : 28                       plp
106a : 8604                     stx zpt+2
106c : 08                       php         ;flags after load/store sequence
106d : 49c3                     eor #$c3
106f : c50d                     cmp zp1+2   ;test result
                                trap_ne
1071 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1073 : 68                       pla         ;load status
                                eor_flag 0
1074 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1076 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1079 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
107b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
107d : 48              >            pha         ;use stack to load status
107e : 28              >            plp
                        
107f : ae1b02                   ldx abs1+3
1082 : 08                       php         ;test stores do not alter flags
1083 : 8a                       txa
1084 : 49c3                     eor #$c3
1086 : aa                       tax
1087 : 28                       plp
1088 : 8605                     stx zpt+3
108a : 08                       php         ;flags after load/store sequence
108b : 49c3                     eor #$c3
108d : c50e                     cmp zp1+3   ;test result
                                trap_ne
108f : d0fe            >        bne *         ;failed not equal (non zero)
                        
1091 : 68                       pla         ;load status
                                eor_flag 0
1092 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1094 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1097 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1099 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
109b : 48              >            pha         ;use stack to load status
109c : 28              >            plp
                        
109d : ae1802                   ldx abs1  
10a0 : 08                       php         ;test stores do not alter flags
10a1 : 8a                       txa
10a2 : 49c3                     eor #$c3
10a4 : aa                       tax
10a5 : 28                       plp
10a6 : 8602                     stx zpt  
10a8 : 08                       php         ;flags after load/store sequence
10a9 : 49c3                     eor #$c3
10ab : aa                       tax
10ac : e40b                     cpx zp1     ;test result
                                trap_ne
10ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
10b0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10b1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10b3 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
10b6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10b8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10ba : 48              >            pha         ;use stack to load status
10bb : 28              >            plp
                        
10bc : ae1902                   ldx abs1+1
10bf : 08                       php         ;test stores do not alter flags
10c0 : 8a                       txa
10c1 : 49c3                     eor #$c3
10c3 : aa                       tax
10c4 : 28                       plp
10c5 : 8603                     stx zpt+1
10c7 : 08                       php         ;flags after load/store sequence
10c8 : 49c3                     eor #$c3
10ca : aa                       tax
10cb : e40c                     cpx zp1+1   ;test result
                                trap_ne
10cd : d0fe            >        bne *         ;failed not equal (non zero)
                        
10cf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10d0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10d2 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
10d5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10d7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10d9 : 48              >            pha         ;use stack to load status
10da : 28              >            plp
                        
10db : ae1a02                   ldx abs1+2
10de : 08                       php         ;test stores do not alter flags
10df : 8a                       txa
10e0 : 49c3                     eor #$c3
10e2 : aa                       tax
10e3 : 28                       plp
10e4 : 8604                     stx zpt+2
10e6 : 08                       php         ;flags after load/store sequence
10e7 : 49c3                     eor #$c3
10e9 : aa                       tax
10ea : e40d                     cpx zp1+2   ;test result
                                trap_ne
10ec : d0fe            >        bne *         ;failed not equal (non zero)
                        
10ee : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10ef : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10f1 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
10f4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10f6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10f8 : 48              >            pha         ;use stack to load status
10f9 : 28              >            plp
                        
10fa : ae1b02                   ldx abs1+3
10fd : 08                       php         ;test stores do not alter flags
10fe : 8a                       txa
10ff : 49c3                     eor #$c3
1101 : aa                       tax
1102 : 28                       plp
1103 : 8605                     stx zpt+3
1105 : 08                       php         ;flags after load/store sequence
1106 : 49c3                     eor #$c3
1108 : aa                       tax
1109 : e40e                     cpx zp1+3   ;test result
                                trap_ne
110b : d0fe            >        bne *         ;failed not equal (non zero)
                        
110d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
110e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1110 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1113 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
1115 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1117 : 48              >            pha         ;use stack to load status
1118 : 28              >            plp
                        
1119 : a2c3                     ldx #$c3
111b : 08                       php
111c : ec1802                   cpx abs1    ;test result
                                trap_ne
111f : d0fe            >        bne *         ;failed not equal (non zero)
                        
1121 : 68                       pla         ;load status
                                eor_flag 0
1122 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1124 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1127 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1129 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
112b : 48              >            pha         ;use stack to load status
112c : 28              >            plp
                        
112d : a282                     ldx #$82
112f : 08                       php
1130 : ec1902                   cpx abs1+1  ;test result
                                trap_ne
1133 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1135 : 68                       pla         ;load status
                                eor_flag 0
1136 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1138 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
113b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
113d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
113f : 48              >            pha         ;use stack to load status
1140 : 28              >            plp
                        
1141 : a241                     ldx #$41
1143 : 08                       php
1144 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
1147 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1149 : 68                       pla         ;load status
                                eor_flag 0
114a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
114c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
114f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1151 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1153 : 48              >            pha         ;use stack to load status
1154 : 28              >            plp
                        
1155 : a200                     ldx #0
1157 : 08                       php
1158 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
115b : d0fe            >        bne *         ;failed not equal (non zero)
                        
115d : 68                       pla         ;load status
                                eor_flag 0
115e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1160 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1163 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1165 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1167 : 48              >            pha         ;use stack to load status
1168 : 28              >            plp
                        
1169 : a2c3                     ldx #$c3  
116b : 08                       php
116c : ec1802                   cpx abs1    ;test result
                                trap_ne
116f : d0fe            >        bne *         ;failed not equal (non zero)
                        
1171 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1172 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1174 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1177 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1179 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
117b : 48              >            pha         ;use stack to load status
117c : 28              >            plp
                        
117d : a282                     ldx #$82
117f : 08                       php
1180 : ec1902                   cpx abs1+1  ;test result
                                trap_ne
1183 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1185 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1186 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1188 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
118b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
118d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
118f : 48              >            pha         ;use stack to load status
1190 : 28              >            plp
                        
1191 : a241                     ldx #$41
1193 : 08                       php
1194 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
1197 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1199 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
119a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
119c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
119f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11a1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11a3 : 48              >            pha         ;use stack to load status
11a4 : 28              >            plp
                        
11a5 : a200                     ldx #0
11a7 : 08                       php
11a8 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
11ab : d0fe            >        bne *         ;failed not equal (non zero)
                        
11ad : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11ae : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11b0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
11b3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
11b5 : a200                     ldx #0
11b7 : a502                     lda zpt  
11b9 : 49c3                     eor #$c3
11bb : c50b                     cmp zp1  
                                trap_ne     ;store to zp data
11bd : d0fe            >        bne *         ;failed not equal (non zero)
                        
11bf : 8602                     stx zpt     ;clear                
11c1 : ad0302                   lda abst  
11c4 : 49c3                     eor #$c3
11c6 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
11c9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11cb : 8e0302                   stx abst    ;clear                
11ce : a503                     lda zpt+1
11d0 : 49c3                     eor #$c3
11d2 : c50c                     cmp zp1+1
                                trap_ne     ;store to zp data
11d4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11d6 : 8603                     stx zpt+1   ;clear                
11d8 : ad0402                   lda abst+1
11db : 49c3                     eor #$c3
11dd : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
11e0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11e2 : 8e0402                   stx abst+1  ;clear                
11e5 : a504                     lda zpt+2
11e7 : 49c3                     eor #$c3
11e9 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp data
11eb : d0fe            >        bne *         ;failed not equal (non zero)
                        
11ed : 8604                     stx zpt+2   ;clear                
11ef : ad0502                   lda abst+2
11f2 : 49c3                     eor #$c3
11f4 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
11f7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11f9 : 8e0502                   stx abst+2  ;clear                
11fc : a505                     lda zpt+3
11fe : 49c3                     eor #$c3
1200 : c50e                     cmp zp1+3
                                trap_ne     ;store to zp data
1202 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1204 : 8605                     stx zpt+3   ;clear                
1206 : ad0602                   lda abst+3
1209 : 49c3                     eor #$c3
120b : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
120e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1210 : 8e0602                   stx abst+3  ;clear                
                                next_test
1213 : ad0002          >            lda test_case   ;previous test
1216 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1218 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
121a : a914            >            lda #test_num   ;*** next tests' number
121c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
121f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1221 : 48              >            pha         ;use stack to load status
1222 : 28              >            plp
                        
1223 : a40b                     ldy zp1  
1225 : 08                       php         ;test stores do not alter flags
1226 : 98                       tya
1227 : 49c3                     eor #$c3
1229 : a8                       tay
122a : 28                       plp
122b : 8c0302                   sty abst  
122e : 08                       php         ;flags after load/store sequence
122f : 49c3                     eor #$c3
1231 : a8                       tay
1232 : c0c3                     cpy #$c3    ;test result
                                trap_ne
1234 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1236 : 68                       pla         ;load status
                                eor_flag 0
1237 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1239 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
123c : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
123e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1240 : 48              >            pha         ;use stack to load status
1241 : 28              >            plp
                        
1242 : a40c                     ldy zp1+1
1244 : 08                       php         ;test stores do not alter flags
1245 : 98                       tya
1246 : 49c3                     eor #$c3
1248 : a8                       tay
1249 : 28                       plp
124a : 8c0402                   sty abst+1
124d : 08                       php         ;flags after load/store sequence
124e : 49c3                     eor #$c3
1250 : a8                       tay
1251 : c082                     cpy #$82    ;test result
                                trap_ne
1253 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1255 : 68                       pla         ;load status
                                eor_flag 0
1256 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1258 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
125b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
125d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
125f : 48              >            pha         ;use stack to load status
1260 : 28              >            plp
                        
1261 : a40d                     ldy zp1+2
1263 : 08                       php         ;test stores do not alter flags
1264 : 98                       tya
1265 : 49c3                     eor #$c3
1267 : a8                       tay
1268 : 28                       plp
1269 : 8c0502                   sty abst+2
126c : 08                       php         ;flags after load/store sequence
126d : 49c3                     eor #$c3
126f : a8                       tay
1270 : c041                     cpy #$41    ;test result
                                trap_ne
1272 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1274 : 68                       pla         ;load status
                                eor_flag 0
1275 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1277 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
127a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
127c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
127e : 48              >            pha         ;use stack to load status
127f : 28              >            plp
                        
1280 : a40e                     ldy zp1+3
1282 : 08                       php         ;test stores do not alter flags
1283 : 98                       tya
1284 : 49c3                     eor #$c3
1286 : a8                       tay
1287 : 28                       plp
1288 : 8c0602                   sty abst+3
128b : 08                       php         ;flags after load/store sequence
128c : 49c3                     eor #$c3
128e : a8                       tay
128f : c000                     cpy #0      ;test result
                                trap_ne
1291 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1293 : 68                       pla         ;load status
                                eor_flag 0
1294 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1296 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1299 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
129b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
129d : 48              >            pha         ;use stack to load status
129e : 28              >            plp
                        
129f : a40b                     ldy zp1  
12a1 : 08                       php         ;test stores do not alter flags
12a2 : 98                       tya
12a3 : 49c3                     eor #$c3
12a5 : a8                       tay
12a6 : 28                       plp
12a7 : 8c0302                   sty abst  
12aa : 08                       php         ;flags after load/store sequence
12ab : 49c3                     eor #$c3
12ad : a8                       tay
12ae : c0c3                     cpy #$c3    ;test result
                                trap_ne
12b0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
12b2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12b3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12b5 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
12b8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12ba : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12bc : 48              >            pha         ;use stack to load status
12bd : 28              >            plp
                        
12be : a40c                     ldy zp1+1
12c0 : 08                       php         ;test stores do not alter flags
12c1 : 98                       tya
12c2 : 49c3                     eor #$c3
12c4 : a8                       tay
12c5 : 28                       plp
12c6 : 8c0402                   sty abst+1
12c9 : 08                       php         ;flags after load/store sequence
12ca : 49c3                     eor #$c3
12cc : a8                       tay
12cd : c082                     cpy #$82   ;test result
                                trap_ne
12cf : d0fe            >        bne *         ;failed not equal (non zero)
                        
12d1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12d2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12d4 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
12d7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12d9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12db : 48              >            pha         ;use stack to load status
12dc : 28              >            plp
                        
12dd : a40d                     ldy zp1+2
12df : 08                       php         ;test stores do not alter flags
12e0 : 98                       tya
12e1 : 49c3                     eor #$c3
12e3 : a8                       tay
12e4 : 28                       plp
12e5 : 8c0502                   sty abst+2
12e8 : 08                       php         ;flags after load/store sequence
12e9 : 49c3                     eor #$c3
12eb : a8                       tay
12ec : c041                     cpy #$41    ;test result
                                trap_ne
12ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
12f0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12f1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12f3 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
12f6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12f8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12fa : 48              >            pha         ;use stack to load status
12fb : 28              >            plp
                        
12fc : a40e                     ldy zp1+3
12fe : 08                       php         ;test stores do not alter flags
12ff : 98                       tya
1300 : 49c3                     eor #$c3
1302 : a8                       tay
1303 : 28                       plp
1304 : 8c0602                   sty abst+3
1307 : 08                       php         ;flags after load/store sequence
1308 : 49c3                     eor #$c3
130a : a8                       tay
130b : c000                     cpy #0      ;test result
                                trap_ne
130d : d0fe            >        bne *         ;failed not equal (non zero)
                        
130f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1310 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1312 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1315 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
1317 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1319 : 48              >            pha         ;use stack to load status
131a : 28              >            plp
                        
131b : ac1802                   ldy abs1  
131e : 08                       php         ;test stores do not alter flags
131f : 98                       tya
1320 : 49c3                     eor #$c3
1322 : a8                       tay
1323 : 28                       plp
1324 : 8402                     sty zpt  
1326 : 08                       php         ;flags after load/store sequence
1327 : 49c3                     eor #$c3
1329 : a8                       tay
132a : c40b                     cpy zp1     ;test result
                                trap_ne
132c : d0fe            >        bne *         ;failed not equal (non zero)
                        
132e : 68                       pla         ;load status
                                eor_flag 0
132f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1331 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1334 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1336 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1338 : 48              >            pha         ;use stack to load status
1339 : 28              >            plp
                        
133a : ac1902                   ldy abs1+1
133d : 08                       php         ;test stores do not alter flags
133e : 98                       tya
133f : 49c3                     eor #$c3
1341 : a8                       tay
1342 : 28                       plp
1343 : 8403                     sty zpt+1
1345 : 08                       php         ;flags after load/store sequence
1346 : 49c3                     eor #$c3
1348 : a8                       tay
1349 : c40c                     cpy zp1+1   ;test result
                                trap_ne
134b : d0fe            >        bne *         ;failed not equal (non zero)
                        
134d : 68                       pla         ;load status
                                eor_flag 0
134e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1350 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1353 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1355 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1357 : 48              >            pha         ;use stack to load status
1358 : 28              >            plp
                        
1359 : ac1a02                   ldy abs1+2
135c : 08                       php         ;test stores do not alter flags
135d : 98                       tya
135e : 49c3                     eor #$c3
1360 : a8                       tay
1361 : 28                       plp
1362 : 8404                     sty zpt+2
1364 : 08                       php         ;flags after load/store sequence
1365 : 49c3                     eor #$c3
1367 : a8                       tay
1368 : c40d                     cpy zp1+2   ;test result
                                trap_ne
136a : d0fe            >        bne *         ;failed not equal (non zero)
                        
136c : 68                       pla         ;load status
                                eor_flag 0
136d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
136f : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1372 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1374 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1376 : 48              >            pha         ;use stack to load status
1377 : 28              >            plp
                        
1378 : ac1b02                   ldy abs1+3
137b : 08                       php         ;test stores do not alter flags
137c : 98                       tya
137d : 49c3                     eor #$c3
137f : a8                       tay
1380 : 28                       plp
1381 : 8405                     sty zpt+3
1383 : 08                       php         ;flags after load/store sequence
1384 : 49c3                     eor #$c3
1386 : a8                       tay
1387 : c40e                     cpy zp1+3   ;test result
                                trap_ne
1389 : d0fe            >        bne *         ;failed not equal (non zero)
                        
138b : 68                       pla         ;load status
                                eor_flag 0
138c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
138e : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1391 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1393 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1395 : 48              >            pha         ;use stack to load status
1396 : 28              >            plp
                        
1397 : ac1802                   ldy abs1  
139a : 08                       php         ;test stores do not alter flags
139b : 98                       tya
139c : 49c3                     eor #$c3
139e : a8                       tay
139f : 28                       plp
13a0 : 8402                     sty zpt  
13a2 : 08                       php         ;flags after load/store sequence
13a3 : 49c3                     eor #$c3
13a5 : a8                       tay
13a6 : c50b                     cmp zp1     ;test result
                                trap_ne
13a8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
13aa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13ab : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13ad : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
13b0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13b2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13b4 : 48              >            pha         ;use stack to load status
13b5 : 28              >            plp
                        
13b6 : ac1902                   ldy abs1+1
13b9 : 08                       php         ;test stores do not alter flags
13ba : 98                       tya
13bb : 49c3                     eor #$c3
13bd : a8                       tay
13be : 28                       plp
13bf : 8403                     sty zpt+1
13c1 : 08                       php         ;flags after load/store sequence
13c2 : 49c3                     eor #$c3
13c4 : a8                       tay
13c5 : c50c                     cmp zp1+1   ;test result
                                trap_ne
13c7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
13c9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13ca : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13cc : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
13cf : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13d1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13d3 : 48              >            pha         ;use stack to load status
13d4 : 28              >            plp
                        
13d5 : ac1a02                   ldy abs1+2
13d8 : 08                       php         ;test stores do not alter flags
13d9 : 98                       tya
13da : 49c3                     eor #$c3
13dc : a8                       tay
13dd : 28                       plp
13de : 8404                     sty zpt+2
13e0 : 08                       php         ;flags after load/store sequence
13e1 : 49c3                     eor #$c3
13e3 : a8                       tay
13e4 : c50d                     cmp zp1+2   ;test result
                                trap_ne
13e6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
13e8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13e9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13eb : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
13ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13f0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13f2 : 48              >            pha         ;use stack to load status
13f3 : 28              >            plp
                        
13f4 : ac1b02                   ldy abs1+3
13f7 : 08                       php         ;test stores do not alter flags
13f8 : 98                       tya
13f9 : 49c3                     eor #$c3
13fb : a8                       tay
13fc : 28                       plp
13fd : 8405                     sty zpt+3
13ff : 08                       php         ;flags after load/store sequence
1400 : 49c3                     eor #$c3
1402 : a8                       tay
1403 : c50e                     cmp zp1+3   ;test result
                                trap_ne
1405 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1407 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1408 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
140a : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
140d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
140f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1411 : 48              >            pha         ;use stack to load status
1412 : 28              >            plp
                        
1413 : a0c3                     ldy #$c3  
1415 : 08                       php
1416 : cc1802                   cpy abs1    ;test result
                                trap_ne
1419 : d0fe            >        bne *         ;failed not equal (non zero)
                        
141b : 68                       pla         ;load status
                                eor_flag 0
141c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
141e : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1421 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1423 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1425 : 48              >            pha         ;use stack to load status
1426 : 28              >            plp
                        
1427 : a082                     ldy #$82
1429 : 08                       php
142a : cc1902                   cpy abs1+1  ;test result
                                trap_ne
142d : d0fe            >        bne *         ;failed not equal (non zero)
                        
142f : 68                       pla         ;load status
                                eor_flag 0
1430 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1432 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1435 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1437 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1439 : 48              >            pha         ;use stack to load status
143a : 28              >            plp
                        
143b : a041                     ldy #$41
143d : 08                       php
143e : cc1a02                   cpy abs1+2  ;test result
                                trap_ne
1441 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1443 : 68                       pla         ;load status
                                eor_flag 0
1444 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1446 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1449 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
144b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
144d : 48              >            pha         ;use stack to load status
144e : 28              >            plp
                        
144f : a000                     ldy #0
1451 : 08                       php
1452 : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
1455 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1457 : 68                       pla         ;load status
                                eor_flag 0
1458 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
145a : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
145d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
145f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1461 : 48              >            pha         ;use stack to load status
1462 : 28              >            plp
                        
1463 : a0c3                     ldy #$c3  
1465 : 08                       php
1466 : cc1802                   cpy abs1    ;test result
                                trap_ne
1469 : d0fe            >        bne *         ;failed not equal (non zero)
                        
146b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
146c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
146e : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1471 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1473 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1475 : 48              >            pha         ;use stack to load status
1476 : 28              >            plp
                        
1477 : a082                     ldy #$82
1479 : 08                       php
147a : cc1902                   cpy abs1+1  ;test result
                                trap_ne
147d : d0fe            >        bne *         ;failed not equal (non zero)
                        
147f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1480 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1482 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1485 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1487 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1489 : 48              >            pha         ;use stack to load status
148a : 28              >            plp
                        
148b : a041                     ldy #$41
148d : 08                       php
148e : cc1a02                   cpy abs1+2   ;test result
                                trap_ne
1491 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1493 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1494 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1496 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1499 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
149b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
149d : 48              >            pha         ;use stack to load status
149e : 28              >            plp
                        
149f : a000                     ldy #0
14a1 : 08                       php
14a2 : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
14a5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14a7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14a8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14aa : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
14ad : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
14af : a000                     ldy #0
14b1 : a502                     lda zpt  
14b3 : 49c3                     eor #$c3
14b5 : c50b                     cmp zp1  
                                trap_ne     ;store to zp   data
14b7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14b9 : 8402                     sty zpt     ;clear                
14bb : ad0302                   lda abst  
14be : 49c3                     eor #$c3
14c0 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs   data
14c3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14c5 : 8c0302                   sty abst    ;clear                
14c8 : a503                     lda zpt+1
14ca : 49c3                     eor #$c3
14cc : c50c                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
14ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
14d0 : 8403                     sty zpt+1   ;clear                
14d2 : ad0402                   lda abst+1
14d5 : 49c3                     eor #$c3
14d7 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
14da : d0fe            >        bne *         ;failed not equal (non zero)
                        
14dc : 8c0402                   sty abst+1  ;clear                
14df : a504                     lda zpt+2
14e1 : 49c3                     eor #$c3
14e3 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
14e5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14e7 : 8404                     sty zpt+2   ;clear                
14e9 : ad0502                   lda abst+2
14ec : 49c3                     eor #$c3
14ee : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
14f1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14f3 : 8c0502                   sty abst+2  ;clear                
14f6 : a505                     lda zpt+3
14f8 : 49c3                     eor #$c3
14fa : c50e                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
14fc : d0fe            >        bne *         ;failed not equal (non zero)
                        
14fe : 8405                     sty zpt+3   ;clear                
1500 : ad0602                   lda abst+3
1503 : 49c3                     eor #$c3
1505 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
1508 : d0fe            >        bne *         ;failed not equal (non zero)
                        
150a : 8c0602                   sty abst+3  ;clear                
                                next_test
150d : ad0002          >            lda test_case   ;previous test
1510 : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1512 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
1514 : a915            >            lda #test_num   ;*** next tests' number
1516 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
1519 : a203                     ldx #3
151b :                  tldax    
                                set_stat 0
                       >            load_flag 0
151b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
151d : 48              >            pha         ;use stack to load status
151e : 28              >            plp
                        
151f : b50b                     lda zp1,x
1521 : 08                       php         ;test stores do not alter flags
1522 : 49c3                     eor #$c3
1524 : 28                       plp
1525 : 9d0302                   sta abst,x
1528 : 08                       php         ;flags after load/store sequence
1529 : 49c3                     eor #$c3
152b : dd1802                   cmp abs1,x  ;test result
                                trap_ne
152e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1530 : 68                       pla         ;load status
                                eor_flag 0
1531 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1533 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1536 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1538 : ca                       dex
1539 : 10e0                     bpl tldax                  
                        
153b : a203                     ldx #3
153d :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
153d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
153f : 48              >            pha         ;use stack to load status
1540 : 28              >            plp
                        
1541 : b50b                     lda zp1,x
1543 : 08                       php         ;test stores do not alter flags
1544 : 49c3                     eor #$c3
1546 : 28                       plp
1547 : 9d0302                   sta abst,x
154a : 08                       php         ;flags after load/store sequence
154b : 49c3                     eor #$c3
154d : dd1802                   cmp abs1,x   ;test result
                                trap_ne
1550 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1552 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1553 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1555 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1558 : d0fe            >        bne *         ;failed not equal (non zero)
                        
155a : ca                       dex
155b : 10e0                     bpl tldax1                  
                        
155d : a203                     ldx #3
155f :                  tldax2   
                                set_stat 0
                       >            load_flag 0
155f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1561 : 48              >            pha         ;use stack to load status
1562 : 28              >            plp
                        
1563 : bd1802                   lda abs1,x
1566 : 08                       php         ;test stores do not alter flags
1567 : 49c3                     eor #$c3
1569 : 28                       plp
156a : 9502                     sta zpt,x
156c : 08                       php         ;flags after load/store sequence
156d : 49c3                     eor #$c3
156f : d50b                     cmp zp1,x   ;test result
                                trap_ne
1571 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1573 : 68                       pla         ;load status
                                eor_flag 0
1574 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1576 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1579 : d0fe            >        bne *         ;failed not equal (non zero)
                        
157b : ca                       dex
157c : 10e1                     bpl tldax2                  
                        
157e : a203                     ldx #3
1580 :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
1580 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1582 : 48              >            pha         ;use stack to load status
1583 : 28              >            plp
                        
1584 : bd1802                   lda abs1,x
1587 : 08                       php         ;test stores do not alter flags
1588 : 49c3                     eor #$c3
158a : 28                       plp
158b : 9502                     sta zpt,x
158d : 08                       php         ;flags after load/store sequence
158e : 49c3                     eor #$c3
1590 : d50b                     cmp zp1,x   ;test result
                                trap_ne
1592 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1594 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1595 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1597 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
159a : d0fe            >        bne *         ;failed not equal (non zero)
                        
159c : ca                       dex
159d : 10e1                     bpl tldax3
                        
159f : a203                     ldx #3      ;testing store result
15a1 : a000                     ldy #0
15a3 : b502             tstax   lda zpt,x
15a5 : 49c3                     eor #$c3
15a7 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
15a9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
15ab : 9402                     sty zpt,x   ;clear                
15ad : bd0302                   lda abst,x
15b0 : 49c3                     eor #$c3
15b2 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
15b5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
15b7 : 8a                       txa
15b8 : 9d0302                   sta abst,x  ;clear                
15bb : ca                       dex
15bc : 10e5                     bpl tstax
                                next_test
15be : ad0002          >            lda test_case   ;previous test
15c1 : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
15c3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
15c5 : a916            >            lda #test_num   ;*** next tests' number
15c7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
15ca : a003                     ldy #3
15cc :                  tlday    
                                set_stat 0
                       >            load_flag 0
15cc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
15ce : 48              >            pha         ;use stack to load status
15cf : 28              >            plp
                        
15d0 : b11c                     lda (ind1),y
15d2 : 08                       php         ;test stores do not alter flags
15d3 : 49c3                     eor #$c3
15d5 : 28                       plp
15d6 : 990302                   sta abst,y
15d9 : 08                       php         ;flags after load/store sequence
15da : 49c3                     eor #$c3
15dc : d91802                   cmp abs1,y  ;test result
                                trap_ne
15df : d0fe            >        bne *         ;failed not equal (non zero)
                        
15e1 : 68                       pla         ;load status
                                eor_flag 0
15e2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
15e4 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
15e7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
15e9 : 88                       dey
15ea : 10e0                     bpl tlday                  
                        
15ec : a003                     ldy #3
15ee :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
15ee : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15f0 : 48              >            pha         ;use stack to load status
15f1 : 28              >            plp
                        
15f2 : b11c                     lda (ind1),y
15f4 : 08                       php         ;test stores do not alter flags
15f5 : 49c3                     eor #$c3
15f7 : 28                       plp
15f8 : 990302                   sta abst,y
15fb : 08                       php         ;flags after load/store sequence
15fc : 49c3                     eor #$c3
15fe : d91802                   cmp abs1,y  ;test result
                                trap_ne
1601 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1603 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1604 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1606 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
1609 : d0fe            >        bne *         ;failed not equal (non zero)
                        
160b : 88                       dey
160c : 10e0                     bpl tlday1                  
                        
160e : a003                     ldy #3      ;testing store result
1610 : a200                     ldx #0
1612 : b90302           tstay   lda abst,y
1615 : 49c3                     eor #$c3
1617 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
161a : d0fe            >        bne *         ;failed not equal (non zero)
                        
161c : 8a                       txa
161d : 990302                   sta abst,y  ;clear                
1620 : 88                       dey
1621 : 10ef                     bpl tstay
                        
1623 : a003                     ldy #3
1625 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
1625 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1627 : 48              >            pha         ;use stack to load status
1628 : 28              >            plp
                        
1629 : b91802                   lda abs1,y
162c : 08                       php         ;test stores do not alter flags
162d : 49c3                     eor #$c3
162f : 28                       plp
1630 : 9128                     sta (indt),y
1632 : 08                       php         ;flags after load/store sequence
1633 : 49c3                     eor #$c3
1635 : d11c                     cmp (ind1),y    ;test result
                                trap_ne
1637 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1639 : 68                       pla         ;load status
                                eor_flag 0
163a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
163c : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
163f : d0fe            >        bne *         ;failed not equal (non zero)
                        
1641 : 88                       dey
1642 : 10e1                     bpl tlday2                  
                        
1644 : a003                     ldy #3
1646 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1646 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1648 : 48              >            pha         ;use stack to load status
1649 : 28              >            plp
                        
164a : b91802                   lda abs1,y
164d : 08                       php         ;test stores do not alter flags
164e : 49c3                     eor #$c3
1650 : 28                       plp
1651 : 9128                     sta (indt),y
1653 : 08                       php         ;flags after load/store sequence
1654 : 49c3                     eor #$c3
1656 : d11c                     cmp (ind1),y   ;test result
                                trap_ne
1658 : d0fe            >        bne *         ;failed not equal (non zero)
                        
165a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
165b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
165d : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
1660 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1662 : 88                       dey
1663 : 10e1                     bpl tlday3
                                
1665 : a003                     ldy #3      ;testing store result
1667 : a200                     ldx #0
1669 : b90302           tstay1  lda abst,y
166c : 49c3                     eor #$c3
166e : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1671 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1673 : 8a                       txa
1674 : 990302                   sta abst,y  ;clear                
1677 : 88                       dey
1678 : 10ef                     bpl tstay1
                                
167a : a206                     ldx #6
167c : a003                     ldy #3
167e :                  tldax4   
                                set_stat 0
                       >            load_flag 0
167e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1680 : 48              >            pha         ;use stack to load status
1681 : 28              >            plp
                        
1682 : a11c                     lda (ind1,x)
1684 : 08                       php         ;test stores do not alter flags
1685 : 49c3                     eor #$c3
1687 : 28                       plp
1688 : 8128                     sta (indt,x)
168a : 08                       php         ;flags after load/store sequence
168b : 49c3                     eor #$c3
168d : d91802                   cmp abs1,y  ;test result
                                trap_ne
1690 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1692 : 68                       pla         ;load status
                                eor_flag 0
1693 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1695 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
1698 : d0fe            >        bne *         ;failed not equal (non zero)
                        
169a : ca                       dex
169b : ca                       dex
169c : 88                       dey
169d : 10df                     bpl tldax4                  
                        
169f : a206                     ldx #6
16a1 : a003                     ldy #3
16a3 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
16a3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16a5 : 48              >            pha         ;use stack to load status
16a6 : 28              >            plp
                        
16a7 : a11c                     lda (ind1,x)
16a9 : 08                       php         ;test stores do not alter flags
16aa : 49c3                     eor #$c3
16ac : 28                       plp
16ad : 8128                     sta (indt,x)
16af : 08                       php         ;flags after load/store sequence
16b0 : 49c3                     eor #$c3
16b2 : d91802                   cmp abs1,y  ;test result
                                trap_ne
16b5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
16b7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16b8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16ba : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
16bd : d0fe            >        bne *         ;failed not equal (non zero)
                        
16bf : ca                       dex
16c0 : ca                       dex
16c1 : 88                       dey
16c2 : 10df                     bpl tldax5
                        
16c4 : a003                     ldy #3      ;testing store result
16c6 : a200                     ldx #0
16c8 : b90302           tstay2  lda abst,y
16cb : 49c3                     eor #$c3
16cd : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
16d0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
16d2 : 8a                       txa
16d3 : 990302                   sta abst,y  ;clear                
16d6 : 88                       dey
16d7 : 10ef                     bpl tstay2
                                next_test
16d9 : ad0002          >            lda test_case   ;previous test
16dc : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
16de : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
16e0 : a917            >            lda #test_num   ;*** next tests' number
16e2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
16e5 : a2fd                     ldx #3+$fa
16e7 : b511             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
16e9 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
16ec : ca                       dex
16ed : e0fa                     cpx #$fa
16ef : b0f6                     bcs tldax6                  
16f1 : a2fd                     ldx #3+$fa
16f3 : bd1e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
16f6 : 9508                     sta zpt-$fa&$ff,x
16f8 : ca                       dex
16f9 : e0fa                     cpx #$fa
16fb : b0f6                     bcs tldax7
                                                  
16fd : a203                     ldx #3      ;testing wraparound result
16ff : a000                     ldy #0
1701 : b502             tstax1  lda zpt,x
1703 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1705 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1707 : 9402                     sty zpt,x   ;clear                
1709 : bd0302                   lda abst,x
170c : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
170f : d0fe            >        bne *         ;failed not equal (non zero)
                        
1711 : 8a                       txa
1712 : 9d0302                   sta abst,x  ;clear                
1715 : ca                       dex
1716 : 10e9                     bpl tstax1
                        
1718 : a0fb                     ldy #3+$f8
171a : a2fe                     ldx #6+$f8
171c : a124             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
171e : 990b01                   sta abst-$f8,y
1721 : ca                       dex
1722 : ca                       dex
1723 : 88                       dey
1724 : c0f8                     cpy #$f8
1726 : b0f4                     bcs tlday4
1728 : a003                     ldy #3      ;testing wraparound result
172a : a200                     ldx #0
172c : b90302           tstay4  lda abst,y
172f : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1732 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1734 : 8a                       txa
1735 : 990302                   sta abst,y  ;clear                
1738 : 88                       dey
1739 : 10f1                     bpl tstay4
                                
173b : a0fb                     ldy #3+$f8
173d : b92001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
1740 : 9130                     sta (inwt),y
1742 : 88                       dey
1743 : c0f8                     cpy #$f8
1745 : b0f6                     bcs tlday5                  
1747 : a003                     ldy #3      ;testing wraparound result
1749 : a200                     ldx #0
174b : b90302           tstay5  lda abst,y
174e : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1751 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1753 : 8a                       txa
1754 : 990302                   sta abst,y  ;clear                
1757 : 88                       dey
1758 : 10f1                     bpl tstay5
                        
175a : a0fb                     ldy #3+$f8
175c : a2fe                     ldx #6+$f8
175e : b126             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
1760 : 8130                     sta (indt-$f8&$ff,x)
1762 : ca                       dex
1763 : ca                       dex
1764 : 88                       dey
1765 : c0f8                     cpy #$f8
1767 : b0f5                     bcs tlday6
1769 : a003                     ldy #3      ;testing wraparound result
176b : a200                     ldx #0
176d : b90302           tstay6  lda abst,y
1770 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1773 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1775 : 8a                       txa
1776 : 990302                   sta abst,y  ;clear                
1779 : 88                       dey
177a : 10f1                     bpl tstay6
                                next_test
177c : ad0002          >            lda test_case   ;previous test
177f : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1781 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
1783 : a918            >            lda #test_num   ;*** next tests' number
1785 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1788 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
178a : 48              >            pha         ;use stack to load status
178b : 28              >            plp
                        
178c : a50b                     lda zp1
178e : 08                       php         ;test stores do not alter flags
178f : 49c3                     eor #$c3
1791 : 28                       plp
1792 : 8d0302                   sta abst
1795 : 08                       php         ;flags after load/store sequence
1796 : 49c3                     eor #$c3
1798 : c9c3                     cmp #$c3    ;test result
                                trap_ne
179a : d0fe            >        bne *         ;failed not equal (non zero)
                        
179c : 68                       pla         ;load status
                                eor_flag 0
179d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
179f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
17a2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
17a4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
17a6 : 48              >            pha         ;use stack to load status
17a7 : 28              >            plp
                        
17a8 : a50c                     lda zp1+1
17aa : 08                       php         ;test stores do not alter flags
17ab : 49c3                     eor #$c3
17ad : 28                       plp
17ae : 8d0402                   sta abst+1
17b1 : 08                       php         ;flags after load/store sequence
17b2 : 49c3                     eor #$c3
17b4 : c982                     cmp #$82    ;test result
                                trap_ne
17b6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
17b8 : 68                       pla         ;load status
                                eor_flag 0
17b9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
17bb : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
17be : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
17c0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
17c2 : 48              >            pha         ;use stack to load status
17c3 : 28              >            plp
                        
17c4 : a50d                     lda zp1+2
17c6 : 08                       php         ;test stores do not alter flags
17c7 : 49c3                     eor #$c3
17c9 : 28                       plp
17ca : 8d0502                   sta abst+2
17cd : 08                       php         ;flags after load/store sequence
17ce : 49c3                     eor #$c3
17d0 : c941                     cmp #$41    ;test result
                                trap_ne
17d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
17d4 : 68                       pla         ;load status
                                eor_flag 0
17d5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
17d7 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
17da : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
17dc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
17de : 48              >            pha         ;use stack to load status
17df : 28              >            plp
                        
17e0 : a50e                     lda zp1+3
17e2 : 08                       php         ;test stores do not alter flags
17e3 : 49c3                     eor #$c3
17e5 : 28                       plp
17e6 : 8d0602                   sta abst+3
17e9 : 08                       php         ;flags after load/store sequence
17ea : 49c3                     eor #$c3
17ec : c900                     cmp #0      ;test result
                                trap_ne
17ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
17f0 : 68                       pla         ;load status
                                eor_flag 0
17f1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
17f3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
17f6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
17f8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
17fa : 48              >            pha         ;use stack to load status
17fb : 28              >            plp
                        
17fc : a50b                     lda zp1  
17fe : 08                       php         ;test stores do not alter flags
17ff : 49c3                     eor #$c3
1801 : 28                       plp
1802 : 8d0302                   sta abst  
1805 : 08                       php         ;flags after load/store sequence
1806 : 49c3                     eor #$c3
1808 : c9c3                     cmp #$c3    ;test result
                                trap_ne
180a : d0fe            >        bne *         ;failed not equal (non zero)
                        
180c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
180d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
180f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1812 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1814 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1816 : 48              >            pha         ;use stack to load status
1817 : 28              >            plp
                        
1818 : a50c                     lda zp1+1
181a : 08                       php         ;test stores do not alter flags
181b : 49c3                     eor #$c3
181d : 28                       plp
181e : 8d0402                   sta abst+1
1821 : 08                       php         ;flags after load/store sequence
1822 : 49c3                     eor #$c3
1824 : c982                     cmp #$82    ;test result
                                trap_ne
1826 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1828 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1829 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
182b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
182e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1830 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1832 : 48              >            pha         ;use stack to load status
1833 : 28              >            plp
                        
1834 : a50d                     lda zp1+2
1836 : 08                       php         ;test stores do not alter flags
1837 : 49c3                     eor #$c3
1839 : 28                       plp
183a : 8d0502                   sta abst+2
183d : 08                       php         ;flags after load/store sequence
183e : 49c3                     eor #$c3
1840 : c941                     cmp #$41    ;test result
                                trap_ne
1842 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1844 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1845 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1847 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
184a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
184c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
184e : 48              >            pha         ;use stack to load status
184f : 28              >            plp
                        
1850 : a50e                     lda zp1+3
1852 : 08                       php         ;test stores do not alter flags
1853 : 49c3                     eor #$c3
1855 : 28                       plp
1856 : 8d0602                   sta abst+3
1859 : 08                       php         ;flags after load/store sequence
185a : 49c3                     eor #$c3
185c : c900                     cmp #0      ;test result
                                trap_ne
185e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1860 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1861 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1863 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1866 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1868 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
186a : 48              >            pha         ;use stack to load status
186b : 28              >            plp
                        
186c : ad1802                   lda abs1  
186f : 08                       php         ;test stores do not alter flags
1870 : 49c3                     eor #$c3
1872 : 28                       plp
1873 : 8502                     sta zpt  
1875 : 08                       php         ;flags after load/store sequence
1876 : 49c3                     eor #$c3
1878 : c50b                     cmp zp1     ;test result
                                trap_ne
187a : d0fe            >        bne *         ;failed not equal (non zero)
                        
187c : 68                       pla         ;load status
                                eor_flag 0
187d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
187f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1882 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1884 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1886 : 48              >            pha         ;use stack to load status
1887 : 28              >            plp
                        
1888 : ad1902                   lda abs1+1
188b : 08                       php         ;test stores do not alter flags
188c : 49c3                     eor #$c3
188e : 28                       plp
188f : 8503                     sta zpt+1
1891 : 08                       php         ;flags after load/store sequence
1892 : 49c3                     eor #$c3
1894 : c50c                     cmp zp1+1   ;test result
                                trap_ne
1896 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1898 : 68                       pla         ;load status
                                eor_flag 0
1899 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
189b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
189e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18a0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18a2 : 48              >            pha         ;use stack to load status
18a3 : 28              >            plp
                        
18a4 : ad1a02                   lda abs1+2
18a7 : 08                       php         ;test stores do not alter flags
18a8 : 49c3                     eor #$c3
18aa : 28                       plp
18ab : 8504                     sta zpt+2
18ad : 08                       php         ;flags after load/store sequence
18ae : 49c3                     eor #$c3
18b0 : c50d                     cmp zp1+2   ;test result
                                trap_ne
18b2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
18b4 : 68                       pla         ;load status
                                eor_flag 0
18b5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18b7 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
18ba : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18bc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18be : 48              >            pha         ;use stack to load status
18bf : 28              >            plp
                        
18c0 : ad1b02                   lda abs1+3
18c3 : 08                       php         ;test stores do not alter flags
18c4 : 49c3                     eor #$c3
18c6 : 28                       plp
18c7 : 8505                     sta zpt+3
18c9 : 08                       php         ;flags after load/store sequence
18ca : 49c3                     eor #$c3
18cc : c50e                     cmp zp1+3   ;test result
                                trap_ne
18ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
18d0 : 68                       pla         ;load status
                                eor_flag 0
18d1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18d3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
18d6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18d8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18da : 48              >            pha         ;use stack to load status
18db : 28              >            plp
                        
18dc : ad1802                   lda abs1  
18df : 08                       php         ;test stores do not alter flags
18e0 : 49c3                     eor #$c3
18e2 : 28                       plp
18e3 : 8502                     sta zpt  
18e5 : 08                       php         ;flags after load/store sequence
18e6 : 49c3                     eor #$c3
18e8 : c50b                     cmp zp1     ;test result
                                trap_ne
18ea : d0fe            >        bne *         ;failed not equal (non zero)
                        
18ec : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18ed : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18ef : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
18f2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18f4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18f6 : 48              >            pha         ;use stack to load status
18f7 : 28              >            plp
                        
18f8 : ad1902                   lda abs1+1
18fb : 08                       php         ;test stores do not alter flags
18fc : 49c3                     eor #$c3
18fe : 28                       plp
18ff : 8503                     sta zpt+1
1901 : 08                       php         ;flags after load/store sequence
1902 : 49c3                     eor #$c3
1904 : c50c                     cmp zp1+1   ;test result
                                trap_ne
1906 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1908 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1909 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
190b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
190e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1910 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1912 : 48              >            pha         ;use stack to load status
1913 : 28              >            plp
                        
1914 : ad1a02                   lda abs1+2
1917 : 08                       php         ;test stores do not alter flags
1918 : 49c3                     eor #$c3
191a : 28                       plp
191b : 8504                     sta zpt+2
191d : 08                       php         ;flags after load/store sequence
191e : 49c3                     eor #$c3
1920 : c50d                     cmp zp1+2   ;test result
                                trap_ne
1922 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1924 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1925 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1927 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
192a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
192c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
192e : 48              >            pha         ;use stack to load status
192f : 28              >            plp
                        
1930 : ad1b02                   lda abs1+3
1933 : 08                       php         ;test stores do not alter flags
1934 : 49c3                     eor #$c3
1936 : 28                       plp
1937 : 8505                     sta zpt+3
1939 : 08                       php         ;flags after load/store sequence
193a : 49c3                     eor #$c3
193c : c50e                     cmp zp1+3   ;test result
                                trap_ne
193e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1940 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1941 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1943 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1946 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1948 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
194a : 48              >            pha         ;use stack to load status
194b : 28              >            plp
                        
194c : a9c3                     lda #$c3
194e : 08                       php
194f : cd1802                   cmp abs1    ;test result
                                trap_ne
1952 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1954 : 68                       pla         ;load status
                                eor_flag 0
1955 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1957 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
195a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
195c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
195e : 48              >            pha         ;use stack to load status
195f : 28              >            plp
                        
1960 : a982                     lda #$82
1962 : 08                       php
1963 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
1966 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1968 : 68                       pla         ;load status
                                eor_flag 0
1969 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
196b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
196e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1970 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1972 : 48              >            pha         ;use stack to load status
1973 : 28              >            plp
                        
1974 : a941                     lda #$41
1976 : 08                       php
1977 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
197a : d0fe            >        bne *         ;failed not equal (non zero)
                        
197c : 68                       pla         ;load status
                                eor_flag 0
197d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
197f : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1982 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1984 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1986 : 48              >            pha         ;use stack to load status
1987 : 28              >            plp
                        
1988 : a900                     lda #0
198a : 08                       php
198b : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
198e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1990 : 68                       pla         ;load status
                                eor_flag 0
1991 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1993 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1996 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1998 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
199a : 48              >            pha         ;use stack to load status
199b : 28              >            plp
                        
199c : a9c3                     lda #$c3  
199e : 08                       php
199f : cd1802                   cmp abs1    ;test result
                                trap_ne
19a2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
19a4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19a5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19a7 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
19aa : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19ac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19ae : 48              >            pha         ;use stack to load status
19af : 28              >            plp
                        
19b0 : a982                     lda #$82
19b2 : 08                       php
19b3 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
19b6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
19b8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19b9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19bb : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
19be : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19c0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19c2 : 48              >            pha         ;use stack to load status
19c3 : 28              >            plp
                        
19c4 : a941                     lda #$41
19c6 : 08                       php
19c7 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
19ca : d0fe            >        bne *         ;failed not equal (non zero)
                        
19cc : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19cd : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19cf : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
19d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19d4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19d6 : 48              >            pha         ;use stack to load status
19d7 : 28              >            plp
                        
19d8 : a900                     lda #0
19da : 08                       php
19db : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
19de : d0fe            >        bne *         ;failed not equal (non zero)
                        
19e0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19e1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19e3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
19e6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
19e8 : a200                     ldx #0
19ea : a502                     lda zpt  
19ec : 49c3                     eor #$c3
19ee : c50b                     cmp zp1  
                                trap_ne     ;store to zp data
19f0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
19f2 : 8602                     stx zpt     ;clear                
19f4 : ad0302                   lda abst  
19f7 : 49c3                     eor #$c3
19f9 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
19fc : d0fe            >        bne *         ;failed not equal (non zero)
                        
19fe : 8e0302                   stx abst    ;clear                
1a01 : a503                     lda zpt+1
1a03 : 49c3                     eor #$c3
1a05 : c50c                     cmp zp1+1
                                trap_ne     ;store to zp data
1a07 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a09 : 8603                     stx zpt+1   ;clear                
1a0b : ad0402                   lda abst+1
1a0e : 49c3                     eor #$c3
1a10 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
1a13 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a15 : 8e0402                   stx abst+1  ;clear                
1a18 : a504                     lda zpt+2
1a1a : 49c3                     eor #$c3
1a1c : c50d                     cmp zp1+2
                                trap_ne     ;store to zp data
1a1e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a20 : 8604                     stx zpt+2   ;clear                
1a22 : ad0502                   lda abst+2
1a25 : 49c3                     eor #$c3
1a27 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
1a2a : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a2c : 8e0502                   stx abst+2  ;clear                
1a2f : a505                     lda zpt+3
1a31 : 49c3                     eor #$c3
1a33 : c50e                     cmp zp1+3
                                trap_ne     ;store to zp data
1a35 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a37 : 8605                     stx zpt+3   ;clear                
1a39 : ad0602                   lda abst+3
1a3c : 49c3                     eor #$c3
1a3e : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
1a41 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a43 : 8e0602                   stx abst+3  ;clear                
                                next_test
1a46 : ad0002          >            lda test_case   ;previous test
1a49 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1a4b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1a4d : a919            >            lda #test_num   ;*** next tests' number
1a4f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1a52 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a54 : 48              >            pha         ;use stack to load status
1a55 : a9ff            >            lda #$ff     ;precharge accu
1a57 : 28              >            plp
                        
1a58 : 240e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1a5a : 08              >            php         ;save flags
1a5b : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1a5d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a5f : 68              >            pla         ;load status
1a60 : 48              >            pha
                       >            cmp_flag fz 
1a61 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a63 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a65 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1a66 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a68 : 48              >            pha         ;use stack to load status
1a69 : a901            >            lda #1     ;precharge accu
1a6b : 28              >            plp
                        
1a6c : 240d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1a6e : 08              >            php         ;save flags
1a6f : c901            >            cmp #1     ;test result
                       >            trap_ne
1a71 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a73 : 68              >            pla         ;load status
1a74 : 48              >            pha
                       >            cmp_flag fv
1a75 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a77 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a79 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1a7a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a7c : 48              >            pha         ;use stack to load status
1a7d : a901            >            lda #1     ;precharge accu
1a7f : 28              >            plp
                        
1a80 : 240c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1a82 : 08              >            php         ;save flags
1a83 : c901            >            cmp #1     ;test result
                       >            trap_ne
1a85 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a87 : 68              >            pla         ;load status
1a88 : 48              >            pha
                       >            cmp_flag fnz
1a89 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a8b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a8d : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1a8e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a90 : 48              >            pha         ;use stack to load status
1a91 : a901            >            lda #1     ;precharge accu
1a93 : 28              >            plp
                        
1a94 : 240b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1a96 : 08              >            php         ;save flags
1a97 : c901            >            cmp #1     ;test result
                       >            trap_ne
1a99 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a9b : 68              >            pla         ;load status
1a9c : 48              >            pha
                       >            cmp_flag fnv
1a9d : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a9f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1aa1 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1aa2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1aa4 : 48              >            pha         ;use stack to load status
1aa5 : a9ff            >            lda #$ff     ;precharge accu
1aa7 : 28              >            plp
                        
1aa8 : 240e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1aaa : 08              >            php         ;save flags
1aab : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1aad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1aaf : 68              >            pla         ;load status
1ab0 : 48              >            pha
                       >            cmp_flag ~fnv 
1ab1 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ab3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ab5 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1ab6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ab8 : 48              >            pha         ;use stack to load status
1ab9 : a901            >            lda #1     ;precharge accu
1abb : 28              >            plp
                        
1abc : 240d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1abe : 08              >            php         ;save flags
1abf : c901            >            cmp #1     ;test result
                       >            trap_ne
1ac1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ac3 : 68              >            pla         ;load status
1ac4 : 48              >            pha
                       >            cmp_flag ~fnz
1ac5 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ac7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ac9 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1aca : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1acc : 48              >            pha         ;use stack to load status
1acd : a901            >            lda #1     ;precharge accu
1acf : 28              >            plp
                        
1ad0 : 240c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1ad2 : 08              >            php         ;save flags
1ad3 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ad5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ad7 : 68              >            pla         ;load status
1ad8 : 48              >            pha
                       >            cmp_flag ~fv
1ad9 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1adb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1add : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1ade : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ae0 : 48              >            pha         ;use stack to load status
1ae1 : a901            >            lda #1     ;precharge accu
1ae3 : 28              >            plp
                        
1ae4 : 240b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1ae6 : 08              >            php         ;save flags
1ae7 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ae9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1aeb : 68              >            pla         ;load status
1aec : 48              >            pha
                       >            cmp_flag ~fz
1aed : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1aef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1af1 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1af2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1af4 : 48              >            pha         ;use stack to load status
1af5 : a9ff            >            lda #$ff     ;precharge accu
1af7 : 28              >            plp
                        
1af8 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1afb : 08              >            php         ;save flags
1afc : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1afe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b00 : 68              >            pla         ;load status
1b01 : 48              >            pha
                       >            cmp_flag fz 
1b02 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b04 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b06 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b07 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b09 : 48              >            pha         ;use stack to load status
1b0a : a901            >            lda #1     ;precharge accu
1b0c : 28              >            plp
                        
1b0d : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1b10 : 08              >            php         ;save flags
1b11 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b13 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b15 : 68              >            pla         ;load status
1b16 : 48              >            pha
                       >            cmp_flag fv
1b17 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b19 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b1b : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b1c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b1e : 48              >            pha         ;use stack to load status
1b1f : a901            >            lda #1     ;precharge accu
1b21 : 28              >            plp
                        
1b22 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1b25 : 08              >            php         ;save flags
1b26 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b28 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b2a : 68              >            pla         ;load status
1b2b : 48              >            pha
                       >            cmp_flag fnz
1b2c : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b2e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b30 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b31 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b33 : 48              >            pha         ;use stack to load status
1b34 : a901            >            lda #1     ;precharge accu
1b36 : 28              >            plp
                        
1b37 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1b3a : 08              >            php         ;save flags
1b3b : c901            >            cmp #1     ;test result
                       >            trap_ne
1b3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b3f : 68              >            pla         ;load status
1b40 : 48              >            pha
                       >            cmp_flag fnv
1b41 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b43 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b45 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1b46 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b48 : 48              >            pha         ;use stack to load status
1b49 : a9ff            >            lda #$ff     ;precharge accu
1b4b : 28              >            plp
                        
1b4c : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1b4f : 08              >            php         ;save flags
1b50 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b52 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b54 : 68              >            pla         ;load status
1b55 : 48              >            pha
                       >            cmp_flag ~fnv 
1b56 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b58 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b5a : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b5b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b5d : 48              >            pha         ;use stack to load status
1b5e : a901            >            lda #1     ;precharge accu
1b60 : 28              >            plp
                        
1b61 : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1b64 : 08              >            php         ;save flags
1b65 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b67 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b69 : 68              >            pla         ;load status
1b6a : 48              >            pha
                       >            cmp_flag ~fnz
1b6b : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b6d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b6f : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b70 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b72 : 48              >            pha         ;use stack to load status
1b73 : a901            >            lda #1     ;precharge accu
1b75 : 28              >            plp
                        
1b76 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1b79 : 08              >            php         ;save flags
1b7a : c901            >            cmp #1     ;test result
                       >            trap_ne
1b7c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b7e : 68              >            pla         ;load status
1b7f : 48              >            pha
                       >            cmp_flag ~fv
1b80 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b82 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b84 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b85 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b87 : 48              >            pha         ;use stack to load status
1b88 : a901            >            lda #1     ;precharge accu
1b8a : 28              >            plp
                        
1b8b : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1b8e : 08              >            php         ;save flags
1b8f : c901            >            cmp #1     ;test result
                       >            trap_ne
1b91 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b93 : 68              >            pla         ;load status
1b94 : 48              >            pha
                       >            cmp_flag ~fz
1b95 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b97 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b99 : 28              >            plp         ;restore status
                        
                                next_test
1b9a : ad0002          >            lda test_case   ;previous test
1b9d : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b9f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1ba1 : a91a            >            lda #test_num   ;*** next tests' number
1ba3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1ba6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ba8 : 48              >            pha         ;use stack to load status
1ba9 : a280            >            ldx #$80     ;precharge index x
1bab : 28              >            plp
                        
1bac : e40f                     cpx zp7f
                                tst_stat fc
1bae : 08              >            php         ;save status
1baf : 68              >            pla         ;use stack to retrieve status
1bb0 : 48              >            pha
                       >            cmp_flag fc
1bb1 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bb3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bb5 : 28              >            plp         ;restore status
                        
1bb6 : ca                       dex
1bb7 : e40f                     cpx zp7f
                                tst_stat fzc
1bb9 : 08              >            php         ;save status
1bba : 68              >            pla         ;use stack to retrieve status
1bbb : 48              >            pha
                       >            cmp_flag fzc
1bbc : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bbe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bc0 : 28              >            plp         ;restore status
                        
1bc1 : ca                       dex
1bc2 : e40f                     cpx zp7f
                                tst_x $7e,fn
1bc4 : 08              >            php         ;save flags
1bc5 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1bc7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bc9 : 68              >            pla         ;load status
1bca : 48              >            pha
                       >            cmp_flag fn
1bcb : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bcd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bcf : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1bd0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bd2 : 48              >            pha         ;use stack to load status
1bd3 : a280            >            ldx #$80     ;precharge index x
1bd5 : 28              >            plp
                        
1bd6 : e40f                     cpx zp7f
                                tst_stat ~fnz
1bd8 : 08              >            php         ;save status
1bd9 : 68              >            pla         ;use stack to retrieve status
1bda : 48              >            pha
                       >            cmp_flag ~fnz
1bdb : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bdd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bdf : 28              >            plp         ;restore status
                        
1be0 : ca                       dex
1be1 : e40f                     cpx zp7f
                                tst_stat ~fn
1be3 : 08              >            php         ;save status
1be4 : 68              >            pla         ;use stack to retrieve status
1be5 : 48              >            pha
                       >            cmp_flag ~fn
1be6 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1be8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bea : 28              >            plp         ;restore status
                        
1beb : ca                       dex
1bec : e40f                     cpx zp7f
                                tst_x $7e,~fzc
1bee : 08              >            php         ;save flags
1bef : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1bf1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bf3 : 68              >            pla         ;load status
1bf4 : 48              >            pha
                       >            cmp_flag ~fzc
1bf5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bf7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bf9 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1bfa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bfc : 48              >            pha         ;use stack to load status
1bfd : a280            >            ldx #$80     ;precharge index x
1bff : 28              >            plp
                        
1c00 : ec1c02                   cpx abs7f
                                tst_stat fc
1c03 : 08              >            php         ;save status
1c04 : 68              >            pla         ;use stack to retrieve status
1c05 : 48              >            pha
                       >            cmp_flag fc
1c06 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c08 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c0a : 28              >            plp         ;restore status
                        
1c0b : ca                       dex
1c0c : ec1c02                   cpx abs7f
                                tst_stat fzc
1c0f : 08              >            php         ;save status
1c10 : 68              >            pla         ;use stack to retrieve status
1c11 : 48              >            pha
                       >            cmp_flag fzc
1c12 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c14 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c16 : 28              >            plp         ;restore status
                        
1c17 : ca                       dex
1c18 : ec1c02                   cpx abs7f
                                tst_x $7e,fn
1c1b : 08              >            php         ;save flags
1c1c : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c1e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c20 : 68              >            pla         ;load status
1c21 : 48              >            pha
                       >            cmp_flag fn
1c22 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c24 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c26 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1c27 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c29 : 48              >            pha         ;use stack to load status
1c2a : a280            >            ldx #$80     ;precharge index x
1c2c : 28              >            plp
                        
1c2d : ec1c02                   cpx abs7f
                                tst_stat ~fnz
1c30 : 08              >            php         ;save status
1c31 : 68              >            pla         ;use stack to retrieve status
1c32 : 48              >            pha
                       >            cmp_flag ~fnz
1c33 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c35 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c37 : 28              >            plp         ;restore status
                        
1c38 : ca                       dex
1c39 : ec1c02                   cpx abs7f
                                tst_stat ~fn
1c3c : 08              >            php         ;save status
1c3d : 68              >            pla         ;use stack to retrieve status
1c3e : 48              >            pha
                       >            cmp_flag ~fn
1c3f : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c43 : 28              >            plp         ;restore status
                        
1c44 : ca                       dex
1c45 : ec1c02                   cpx abs7f
                                tst_x $7e,~fzc
1c48 : 08              >            php         ;save flags
1c49 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c4b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c4d : 68              >            pla         ;load status
1c4e : 48              >            pha
                       >            cmp_flag ~fzc
1c4f : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c51 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c53 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1c54 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c56 : 48              >            pha         ;use stack to load status
1c57 : a280            >            ldx #$80     ;precharge index x
1c59 : 28              >            plp
                        
1c5a : e07f                     cpx #$7f
                                tst_stat fc
1c5c : 08              >            php         ;save status
1c5d : 68              >            pla         ;use stack to retrieve status
1c5e : 48              >            pha
                       >            cmp_flag fc
1c5f : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c61 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c63 : 28              >            plp         ;restore status
                        
1c64 : ca                       dex
1c65 : e07f                     cpx #$7f
                                tst_stat fzc
1c67 : 08              >            php         ;save status
1c68 : 68              >            pla         ;use stack to retrieve status
1c69 : 48              >            pha
                       >            cmp_flag fzc
1c6a : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c6c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c6e : 28              >            plp         ;restore status
                        
1c6f : ca                       dex
1c70 : e07f                     cpx #$7f
                                tst_x $7e,fn
1c72 : 08              >            php         ;save flags
1c73 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c75 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c77 : 68              >            pla         ;load status
1c78 : 48              >            pha
                       >            cmp_flag fn
1c79 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c7b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c7d : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1c7e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c80 : 48              >            pha         ;use stack to load status
1c81 : a280            >            ldx #$80     ;precharge index x
1c83 : 28              >            plp
                        
1c84 : e07f                     cpx #$7f
                                tst_stat ~fnz
1c86 : 08              >            php         ;save status
1c87 : 68              >            pla         ;use stack to retrieve status
1c88 : 48              >            pha
                       >            cmp_flag ~fnz
1c89 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c8b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c8d : 28              >            plp         ;restore status
                        
1c8e : ca                       dex
1c8f : e07f                     cpx #$7f
                                tst_stat ~fn
1c91 : 08              >            php         ;save status
1c92 : 68              >            pla         ;use stack to retrieve status
1c93 : 48              >            pha
                       >            cmp_flag ~fn
1c94 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c96 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c98 : 28              >            plp         ;restore status
                        
1c99 : ca                       dex
1c9a : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1c9c : 08              >            php         ;save flags
1c9d : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c9f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ca1 : 68              >            pla         ;load status
1ca2 : 48              >            pha
                       >            cmp_flag ~fzc
1ca3 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ca5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ca7 : 28              >            plp         ;restore status
                        
                                next_test
1ca8 : ad0002          >            lda test_case   ;previous test
1cab : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1cad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1caf : a91b            >            lda #test_num   ;*** next tests' number
1cb1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1cb4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1cb6 : 48              >            pha         ;use stack to load status
1cb7 : a080            >            ldy #$80     ;precharge index y
1cb9 : 28              >            plp
                        
1cba : c40f                     cpy zp7f
                                tst_stat fc
1cbc : 08              >            php         ;save status
1cbd : 68              >            pla         ;use stack to retrieve status
1cbe : 48              >            pha
                       >            cmp_flag fc
1cbf : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cc1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cc3 : 28              >            plp         ;restore status
                        
1cc4 : 88                       dey
1cc5 : c40f                     cpy zp7f
                                tst_stat fzc
1cc7 : 08              >            php         ;save status
1cc8 : 68              >            pla         ;use stack to retrieve status
1cc9 : 48              >            pha
                       >            cmp_flag fzc
1cca : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ccc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cce : 28              >            plp         ;restore status
                        
1ccf : 88                       dey
1cd0 : c40f                     cpy zp7f
                                tst_y $7e,fn
1cd2 : 08              >            php         ;save flags
1cd3 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1cd5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cd7 : 68              >            pla         ;load status
1cd8 : 48              >            pha
                       >            cmp_flag fn
1cd9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cdb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cdd : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1cde : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ce0 : 48              >            pha         ;use stack to load status
1ce1 : a080            >            ldy #$80     ;precharge index y
1ce3 : 28              >            plp
                        
1ce4 : c40f                     cpy zp7f
                                tst_stat ~fnz
1ce6 : 08              >            php         ;save status
1ce7 : 68              >            pla         ;use stack to retrieve status
1ce8 : 48              >            pha
                       >            cmp_flag ~fnz
1ce9 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ceb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ced : 28              >            plp         ;restore status
                        
1cee : 88                       dey
1cef : c40f                     cpy zp7f
                                tst_stat ~fn
1cf1 : 08              >            php         ;save status
1cf2 : 68              >            pla         ;use stack to retrieve status
1cf3 : 48              >            pha
                       >            cmp_flag ~fn
1cf4 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cf6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cf8 : 28              >            plp         ;restore status
                        
1cf9 : 88                       dey
1cfa : c40f                     cpy zp7f
                                tst_y $7e,~fzc
1cfc : 08              >            php         ;save flags
1cfd : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1cff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d01 : 68              >            pla         ;load status
1d02 : 48              >            pha
                       >            cmp_flag ~fzc
1d03 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d05 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d07 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1d08 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d0a : 48              >            pha         ;use stack to load status
1d0b : a080            >            ldy #$80     ;precharge index y
1d0d : 28              >            plp
                        
1d0e : cc1c02                   cpy abs7f
                                tst_stat fc
1d11 : 08              >            php         ;save status
1d12 : 68              >            pla         ;use stack to retrieve status
1d13 : 48              >            pha
                       >            cmp_flag fc
1d14 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d16 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d18 : 28              >            plp         ;restore status
                        
1d19 : 88                       dey
1d1a : cc1c02                   cpy abs7f
                                tst_stat fzc
1d1d : 08              >            php         ;save status
1d1e : 68              >            pla         ;use stack to retrieve status
1d1f : 48              >            pha
                       >            cmp_flag fzc
1d20 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d22 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d24 : 28              >            plp         ;restore status
                        
1d25 : 88                       dey
1d26 : cc1c02                   cpy abs7f
                                tst_y $7e,fn
1d29 : 08              >            php         ;save flags
1d2a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1d2c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d2e : 68              >            pla         ;load status
1d2f : 48              >            pha
                       >            cmp_flag fn
1d30 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d32 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d34 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1d35 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d37 : 48              >            pha         ;use stack to load status
1d38 : a080            >            ldy #$80     ;precharge index y
1d3a : 28              >            plp
                        
1d3b : cc1c02                   cpy abs7f
                                tst_stat ~fnz
1d3e : 08              >            php         ;save status
1d3f : 68              >            pla         ;use stack to retrieve status
1d40 : 48              >            pha
                       >            cmp_flag ~fnz
1d41 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d43 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d45 : 28              >            plp         ;restore status
                        
1d46 : 88                       dey
1d47 : cc1c02                   cpy abs7f
                                tst_stat ~fn
1d4a : 08              >            php         ;save status
1d4b : 68              >            pla         ;use stack to retrieve status
1d4c : 48              >            pha
                       >            cmp_flag ~fn
1d4d : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d4f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d51 : 28              >            plp         ;restore status
                        
1d52 : 88                       dey
1d53 : cc1c02                   cpy abs7f
                                tst_y $7e,~fzc
1d56 : 08              >            php         ;save flags
1d57 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1d59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d5b : 68              >            pla         ;load status
1d5c : 48              >            pha
                       >            cmp_flag ~fzc
1d5d : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d5f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d61 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1d62 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d64 : 48              >            pha         ;use stack to load status
1d65 : a080            >            ldy #$80     ;precharge index y
1d67 : 28              >            plp
                        
1d68 : c07f                     cpy #$7f
                                tst_stat fc
1d6a : 08              >            php         ;save status
1d6b : 68              >            pla         ;use stack to retrieve status
1d6c : 48              >            pha
                       >            cmp_flag fc
1d6d : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d6f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d71 : 28              >            plp         ;restore status
                        
1d72 : 88                       dey
1d73 : c07f                     cpy #$7f
                                tst_stat fzc
1d75 : 08              >            php         ;save status
1d76 : 68              >            pla         ;use stack to retrieve status
1d77 : 48              >            pha
                       >            cmp_flag fzc
1d78 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d7a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d7c : 28              >            plp         ;restore status
                        
1d7d : 88                       dey
1d7e : c07f                     cpy #$7f
                                tst_y $7e,fn
1d80 : 08              >            php         ;save flags
1d81 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1d83 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d85 : 68              >            pla         ;load status
1d86 : 48              >            pha
                       >            cmp_flag fn
1d87 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d89 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d8b : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1d8c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d8e : 48              >            pha         ;use stack to load status
1d8f : a080            >            ldy #$80     ;precharge index y
1d91 : 28              >            plp
                        
1d92 : c07f                     cpy #$7f
                                tst_stat ~fnz
1d94 : 08              >            php         ;save status
1d95 : 68              >            pla         ;use stack to retrieve status
1d96 : 48              >            pha
                       >            cmp_flag ~fnz
1d97 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d99 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d9b : 28              >            plp         ;restore status
                        
1d9c : 88                       dey
1d9d : c07f                     cpy #$7f
                                tst_stat ~fn
1d9f : 08              >            php         ;save status
1da0 : 68              >            pla         ;use stack to retrieve status
1da1 : 48              >            pha
                       >            cmp_flag ~fn
1da2 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1da4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1da6 : 28              >            plp         ;restore status
                        
1da7 : 88                       dey
1da8 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1daa : 08              >            php         ;save flags
1dab : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1dad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1daf : 68              >            pla         ;load status
1db0 : 48              >            pha
                       >            cmp_flag ~fzc
1db1 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1db3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1db5 : 28              >            plp         ;restore status
                        
                                next_test
1db6 : ad0002          >            lda test_case   ;previous test
1db9 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1dbb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1dbd : a91c            >            lda #test_num   ;*** next tests' number
1dbf : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1dc2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1dc4 : 48              >            pha         ;use stack to load status
1dc5 : a980            >            lda #$80     ;precharge accu
1dc7 : 28              >            plp
                        
1dc8 : c50f                     cmp zp7f
                                tst_a $80,fc
1dca : 08              >            php         ;save flags
1dcb : c980            >            cmp #$80     ;test result
                       >            trap_ne
1dcd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1dcf : 68              >            pla         ;load status
1dd0 : 48              >            pha
                       >            cmp_flag fc
1dd1 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dd3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1dd5 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1dd6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1dd8 : 48              >            pha         ;use stack to load status
1dd9 : a97f            >            lda #$7f     ;precharge accu
1ddb : 28              >            plp
                        
1ddc : c50f                     cmp zp7f
                                tst_a $7f,fzc
1dde : 08              >            php         ;save flags
1ddf : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1de1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1de3 : 68              >            pla         ;load status
1de4 : 48              >            pha
                       >            cmp_flag fzc
1de5 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1de7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1de9 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1dea : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1dec : 48              >            pha         ;use stack to load status
1ded : a97e            >            lda #$7e     ;precharge accu
1def : 28              >            plp
                        
1df0 : c50f                     cmp zp7f
                                tst_a $7e,fn
1df2 : 08              >            php         ;save flags
1df3 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1df5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1df7 : 68              >            pla         ;load status
1df8 : 48              >            pha
                       >            cmp_flag fn
1df9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dfb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1dfd : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1dfe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e00 : 48              >            pha         ;use stack to load status
1e01 : a980            >            lda #$80     ;precharge accu
1e03 : 28              >            plp
                        
1e04 : c50f                     cmp zp7f
                                tst_a $80,~fnz
1e06 : 08              >            php         ;save flags
1e07 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1e09 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e0b : 68              >            pla         ;load status
1e0c : 48              >            pha
                       >            cmp_flag ~fnz
1e0d : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e0f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e11 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1e12 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e14 : 48              >            pha         ;use stack to load status
1e15 : a97f            >            lda #$7f     ;precharge accu
1e17 : 28              >            plp
                        
1e18 : c50f                     cmp zp7f
                                tst_a $7f,~fn
1e1a : 08              >            php         ;save flags
1e1b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1e1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e1f : 68              >            pla         ;load status
1e20 : 48              >            pha
                       >            cmp_flag ~fn
1e21 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e23 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e25 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1e26 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e28 : 48              >            pha         ;use stack to load status
1e29 : a97e            >            lda #$7e     ;precharge accu
1e2b : 28              >            plp
                        
1e2c : c50f                     cmp zp7f
                                tst_a $7e,~fzc
1e2e : 08              >            php         ;save flags
1e2f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1e31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e33 : 68              >            pla         ;load status
1e34 : 48              >            pha
                       >            cmp_flag ~fzc
1e35 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e37 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e39 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1e3a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e3c : 48              >            pha         ;use stack to load status
1e3d : a980            >            lda #$80     ;precharge accu
1e3f : 28              >            plp
                        
1e40 : cd1c02                   cmp abs7f
                                tst_a $80,fc
1e43 : 08              >            php         ;save flags
1e44 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1e46 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e48 : 68              >            pla         ;load status
1e49 : 48              >            pha
                       >            cmp_flag fc
1e4a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e4c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e4e : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1e4f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e51 : 48              >            pha         ;use stack to load status
1e52 : a97f            >            lda #$7f     ;precharge accu
1e54 : 28              >            plp
                        
1e55 : cd1c02                   cmp abs7f
                                tst_a $7f,fzc
1e58 : 08              >            php         ;save flags
1e59 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1e5b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e5d : 68              >            pla         ;load status
1e5e : 48              >            pha
                       >            cmp_flag fzc
1e5f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e61 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e63 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1e64 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e66 : 48              >            pha         ;use stack to load status
1e67 : a97e            >            lda #$7e     ;precharge accu
1e69 : 28              >            plp
                        
1e6a : cd1c02                   cmp abs7f
                                tst_a $7e,fn
1e6d : 08              >            php         ;save flags
1e6e : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1e70 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e72 : 68              >            pla         ;load status
1e73 : 48              >            pha
                       >            cmp_flag fn
1e74 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e76 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e78 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1e79 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e7b : 48              >            pha         ;use stack to load status
1e7c : a980            >            lda #$80     ;precharge accu
1e7e : 28              >            plp
                        
1e7f : cd1c02                   cmp abs7f
                                tst_a $80,~fnz
1e82 : 08              >            php         ;save flags
1e83 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1e85 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e87 : 68              >            pla         ;load status
1e88 : 48              >            pha
                       >            cmp_flag ~fnz
1e89 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e8b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e8d : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1e8e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e90 : 48              >            pha         ;use stack to load status
1e91 : a97f            >            lda #$7f     ;precharge accu
1e93 : 28              >            plp
                        
1e94 : cd1c02                   cmp abs7f
                                tst_a $7f,~fn
1e97 : 08              >            php         ;save flags
1e98 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1e9a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e9c : 68              >            pla         ;load status
1e9d : 48              >            pha
                       >            cmp_flag ~fn
1e9e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ea0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ea2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1ea3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ea5 : 48              >            pha         ;use stack to load status
1ea6 : a97e            >            lda #$7e     ;precharge accu
1ea8 : 28              >            plp
                        
1ea9 : cd1c02                   cmp abs7f
                                tst_a $7e,~fzc
1eac : 08              >            php         ;save flags
1ead : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1eaf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1eb1 : 68              >            pla         ;load status
1eb2 : 48              >            pha
                       >            cmp_flag ~fzc
1eb3 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eb5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1eb7 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1eb8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1eba : 48              >            pha         ;use stack to load status
1ebb : a980            >            lda #$80     ;precharge accu
1ebd : 28              >            plp
                        
1ebe : c97f                     cmp #$7f
                                tst_a $80,fc
1ec0 : 08              >            php         ;save flags
1ec1 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ec3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ec5 : 68              >            pla         ;load status
1ec6 : 48              >            pha
                       >            cmp_flag fc
1ec7 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ec9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ecb : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1ecc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ece : 48              >            pha         ;use stack to load status
1ecf : a97f            >            lda #$7f     ;precharge accu
1ed1 : 28              >            plp
                        
1ed2 : c97f                     cmp #$7f
                                tst_a $7f,fzc
1ed4 : 08              >            php         ;save flags
1ed5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1ed7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ed9 : 68              >            pla         ;load status
1eda : 48              >            pha
                       >            cmp_flag fzc
1edb : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1edd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1edf : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1ee0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ee2 : 48              >            pha         ;use stack to load status
1ee3 : a97e            >            lda #$7e     ;precharge accu
1ee5 : 28              >            plp
                        
1ee6 : c97f                     cmp #$7f
                                tst_a $7e,fn
1ee8 : 08              >            php         ;save flags
1ee9 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1eeb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1eed : 68              >            pla         ;load status
1eee : 48              >            pha
                       >            cmp_flag fn
1eef : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ef1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ef3 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1ef4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ef6 : 48              >            pha         ;use stack to load status
1ef7 : a980            >            lda #$80     ;precharge accu
1ef9 : 28              >            plp
                        
1efa : c97f                     cmp #$7f
                                tst_a $80,~fnz
1efc : 08              >            php         ;save flags
1efd : c980            >            cmp #$80     ;test result
                       >            trap_ne
1eff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f01 : 68              >            pla         ;load status
1f02 : 48              >            pha
                       >            cmp_flag ~fnz
1f03 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f05 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f07 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f08 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f0a : 48              >            pha         ;use stack to load status
1f0b : a97f            >            lda #$7f     ;precharge accu
1f0d : 28              >            plp
                        
1f0e : c97f                     cmp #$7f
                                tst_a $7f,~fn
1f10 : 08              >            php         ;save flags
1f11 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f13 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f15 : 68              >            pla         ;load status
1f16 : 48              >            pha
                       >            cmp_flag ~fn
1f17 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f19 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f1b : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f1c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f1e : 48              >            pha         ;use stack to load status
1f1f : a97e            >            lda #$7e     ;precharge accu
1f21 : 28              >            plp
                        
1f22 : c97f                     cmp #$7f
                                tst_a $7e,~fzc
1f24 : 08              >            php         ;save flags
1f25 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f27 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f29 : 68              >            pla         ;load status
1f2a : 48              >            pha
                       >            cmp_flag ~fzc
1f2b : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f2d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f2f : 28              >            plp         ;restore status
                        
                        
1f30 : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
1f32 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f34 : 48              >            pha         ;use stack to load status
1f35 : a980            >            lda #$80     ;precharge accu
1f37 : 28              >            plp
                        
1f38 : d50b                     cmp zp1,x
                                tst_a $80,fc
1f3a : 08              >            php         ;save flags
1f3b : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f3f : 68              >            pla         ;load status
1f40 : 48              >            pha
                       >            cmp_flag fc
1f41 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f43 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f45 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f46 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f48 : 48              >            pha         ;use stack to load status
1f49 : a97f            >            lda #$7f     ;precharge accu
1f4b : 28              >            plp
                        
1f4c : d50b                     cmp zp1,x
                                tst_a $7f,fzc
1f4e : 08              >            php         ;save flags
1f4f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f51 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f53 : 68              >            pla         ;load status
1f54 : 48              >            pha
                       >            cmp_flag fzc
1f55 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f57 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f59 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f5a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f5c : 48              >            pha         ;use stack to load status
1f5d : a97e            >            lda #$7e     ;precharge accu
1f5f : 28              >            plp
                        
1f60 : d50b                     cmp zp1,x
                                tst_a $7e,fn
1f62 : 08              >            php         ;save flags
1f63 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f65 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f67 : 68              >            pla         ;load status
1f68 : 48              >            pha
                       >            cmp_flag fn
1f69 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f6b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f6d : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f6e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f70 : 48              >            pha         ;use stack to load status
1f71 : a980            >            lda #$80     ;precharge accu
1f73 : 28              >            plp
                        
1f74 : d50b                     cmp zp1,x
                                tst_a $80,~fnz
1f76 : 08              >            php         ;save flags
1f77 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f79 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f7b : 68              >            pla         ;load status
1f7c : 48              >            pha
                       >            cmp_flag ~fnz
1f7d : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f81 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f82 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f84 : 48              >            pha         ;use stack to load status
1f85 : a97f            >            lda #$7f     ;precharge accu
1f87 : 28              >            plp
                        
1f88 : d50b                     cmp zp1,x
                                tst_a $7f,~fn
1f8a : 08              >            php         ;save flags
1f8b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f8d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f8f : 68              >            pla         ;load status
1f90 : 48              >            pha
                       >            cmp_flag ~fn
1f91 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f95 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f96 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f98 : 48              >            pha         ;use stack to load status
1f99 : a97e            >            lda #$7e     ;precharge accu
1f9b : 28              >            plp
                        
1f9c : d50b                     cmp zp1,x
                                tst_a $7e,~fzc
1f9e : 08              >            php         ;save flags
1f9f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fa1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fa3 : 68              >            pla         ;load status
1fa4 : 48              >            pha
                       >            cmp_flag ~fzc
1fa5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fa7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fa9 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1faa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fac : 48              >            pha         ;use stack to load status
1fad : a980            >            lda #$80     ;precharge accu
1faf : 28              >            plp
                        
1fb0 : dd1802                   cmp abs1,x
                                tst_a $80,fc
1fb3 : 08              >            php         ;save flags
1fb4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fb6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fb8 : 68              >            pla         ;load status
1fb9 : 48              >            pha
                       >            cmp_flag fc
1fba : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fbc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fbe : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1fbf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fc1 : 48              >            pha         ;use stack to load status
1fc2 : a97f            >            lda #$7f     ;precharge accu
1fc4 : 28              >            plp
                        
1fc5 : dd1802                   cmp abs1,x
                                tst_a $7f,fzc
1fc8 : 08              >            php         ;save flags
1fc9 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fcb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fcd : 68              >            pla         ;load status
1fce : 48              >            pha
                       >            cmp_flag fzc
1fcf : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fd1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fd3 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fd4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fd6 : 48              >            pha         ;use stack to load status
1fd7 : a97e            >            lda #$7e     ;precharge accu
1fd9 : 28              >            plp
                        
1fda : dd1802                   cmp abs1,x
                                tst_a $7e,fn
1fdd : 08              >            php         ;save flags
1fde : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fe0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fe2 : 68              >            pla         ;load status
1fe3 : 48              >            pha
                       >            cmp_flag fn
1fe4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fe6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fe8 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1fe9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1feb : 48              >            pha         ;use stack to load status
1fec : a980            >            lda #$80     ;precharge accu
1fee : 28              >            plp
                        
1fef : dd1802                   cmp abs1,x
                                tst_a $80,~fnz
1ff2 : 08              >            php         ;save flags
1ff3 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ff5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ff7 : 68              >            pla         ;load status
1ff8 : 48              >            pha
                       >            cmp_flag ~fnz
1ff9 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ffb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ffd : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1ffe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2000 : 48              >            pha         ;use stack to load status
2001 : a97f            >            lda #$7f     ;precharge accu
2003 : 28              >            plp
                        
2004 : dd1802                   cmp abs1,x
                                tst_a $7f,~fn
2007 : 08              >            php         ;save flags
2008 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
200a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
200c : 68              >            pla         ;load status
200d : 48              >            pha
                       >            cmp_flag ~fn
200e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2010 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2012 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2013 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2015 : 48              >            pha         ;use stack to load status
2016 : a97e            >            lda #$7e     ;precharge accu
2018 : 28              >            plp
                        
2019 : dd1802                   cmp abs1,x
                                tst_a $7e,~fzc
201c : 08              >            php         ;save flags
201d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
201f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2021 : 68              >            pla         ;load status
2022 : 48              >            pha
                       >            cmp_flag ~fzc
2023 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2025 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2027 : 28              >            plp         ;restore status
                        
                        
2028 : a004                     ldy #4          ;with indexing by Y
202a : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
202c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
202e : 48              >            pha         ;use stack to load status
202f : a980            >            lda #$80     ;precharge accu
2031 : 28              >            plp
                        
2032 : d91802                   cmp abs1,y
                                tst_a $80,fc
2035 : 08              >            php         ;save flags
2036 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2038 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
203a : 68              >            pla         ;load status
203b : 48              >            pha
                       >            cmp_flag fc
203c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
203e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2040 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2041 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2043 : 48              >            pha         ;use stack to load status
2044 : a97f            >            lda #$7f     ;precharge accu
2046 : 28              >            plp
                        
2047 : d91802                   cmp abs1,y
                                tst_a $7f,fzc
204a : 08              >            php         ;save flags
204b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
204d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
204f : 68              >            pla         ;load status
2050 : 48              >            pha
                       >            cmp_flag fzc
2051 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2053 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2055 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2056 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2058 : 48              >            pha         ;use stack to load status
2059 : a97e            >            lda #$7e     ;precharge accu
205b : 28              >            plp
                        
205c : d91802                   cmp abs1,y
                                tst_a $7e,fn
205f : 08              >            php         ;save flags
2060 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2062 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2064 : 68              >            pla         ;load status
2065 : 48              >            pha
                       >            cmp_flag fn
2066 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2068 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
206a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
206b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
206d : 48              >            pha         ;use stack to load status
206e : a980            >            lda #$80     ;precharge accu
2070 : 28              >            plp
                        
2071 : d91802                   cmp abs1,y
                                tst_a $80,~fnz
2074 : 08              >            php         ;save flags
2075 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2077 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2079 : 68              >            pla         ;load status
207a : 48              >            pha
                       >            cmp_flag ~fnz
207b : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
207d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
207f : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2080 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2082 : 48              >            pha         ;use stack to load status
2083 : a97f            >            lda #$7f     ;precharge accu
2085 : 28              >            plp
                        
2086 : d91802                   cmp abs1,y
                                tst_a $7f,~fn
2089 : 08              >            php         ;save flags
208a : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
208c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
208e : 68              >            pla         ;load status
208f : 48              >            pha
                       >            cmp_flag ~fn
2090 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2092 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2094 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2095 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2097 : 48              >            pha         ;use stack to load status
2098 : a97e            >            lda #$7e     ;precharge accu
209a : 28              >            plp
                        
209b : d91802                   cmp abs1,y
                                tst_a $7e,~fzc
209e : 08              >            php         ;save flags
209f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20a1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20a3 : 68              >            pla         ;load status
20a4 : 48              >            pha
                       >            cmp_flag ~fzc
20a5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20a7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20a9 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
20aa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20ac : 48              >            pha         ;use stack to load status
20ad : a980            >            lda #$80     ;precharge accu
20af : 28              >            plp
                        
20b0 : c11c                     cmp (ind1,x)
                                tst_a $80,fc
20b2 : 08              >            php         ;save flags
20b3 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20b7 : 68              >            pla         ;load status
20b8 : 48              >            pha
                       >            cmp_flag fc
20b9 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20bb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20bd : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
20be : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20c0 : 48              >            pha         ;use stack to load status
20c1 : a97f            >            lda #$7f     ;precharge accu
20c3 : 28              >            plp
                        
20c4 : c11c                     cmp (ind1,x)
                                tst_a $7f,fzc
20c6 : 08              >            php         ;save flags
20c7 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20c9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20cb : 68              >            pla         ;load status
20cc : 48              >            pha
                       >            cmp_flag fzc
20cd : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20cf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20d1 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
20d2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20d4 : 48              >            pha         ;use stack to load status
20d5 : a97e            >            lda #$7e     ;precharge accu
20d7 : 28              >            plp
                        
20d8 : c11c                     cmp (ind1,x)
                                tst_a $7e,fn
20da : 08              >            php         ;save flags
20db : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20dd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20df : 68              >            pla         ;load status
20e0 : 48              >            pha
                       >            cmp_flag fn
20e1 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20e3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20e5 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20e6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20e8 : 48              >            pha         ;use stack to load status
20e9 : a980            >            lda #$80     ;precharge accu
20eb : 28              >            plp
                        
20ec : c11c                     cmp (ind1,x)
                                tst_a $80,~fnz
20ee : 08              >            php         ;save flags
20ef : c980            >            cmp #$80     ;test result
                       >            trap_ne
20f1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20f3 : 68              >            pla         ;load status
20f4 : 48              >            pha
                       >            cmp_flag ~fnz
20f5 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20f7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20f9 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20fa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20fc : 48              >            pha         ;use stack to load status
20fd : a97f            >            lda #$7f     ;precharge accu
20ff : 28              >            plp
                        
2100 : c11c                     cmp (ind1,x)
                                tst_a $7f,~fn
2102 : 08              >            php         ;save flags
2103 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2105 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2107 : 68              >            pla         ;load status
2108 : 48              >            pha
                       >            cmp_flag ~fn
2109 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
210b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
210d : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
210e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2110 : 48              >            pha         ;use stack to load status
2111 : a97e            >            lda #$7e     ;precharge accu
2113 : 28              >            plp
                        
2114 : c11c                     cmp (ind1,x)
                                tst_a $7e,~fzc
2116 : 08              >            php         ;save flags
2117 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2119 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
211b : 68              >            pla         ;load status
211c : 48              >            pha
                       >            cmp_flag ~fzc
211d : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
211f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2121 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2122 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2124 : 48              >            pha         ;use stack to load status
2125 : a980            >            lda #$80     ;precharge accu
2127 : 28              >            plp
                        
2128 : d11c                     cmp (ind1),y
                                tst_a $80,fc
212a : 08              >            php         ;save flags
212b : c980            >            cmp #$80     ;test result
                       >            trap_ne
212d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
212f : 68              >            pla         ;load status
2130 : 48              >            pha
                       >            cmp_flag fc
2131 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2133 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2135 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2136 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2138 : 48              >            pha         ;use stack to load status
2139 : a97f            >            lda #$7f     ;precharge accu
213b : 28              >            plp
                        
213c : d11c                     cmp (ind1),y
                                tst_a $7f,fzc
213e : 08              >            php         ;save flags
213f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2141 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2143 : 68              >            pla         ;load status
2144 : 48              >            pha
                       >            cmp_flag fzc
2145 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2147 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2149 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
214a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
214c : 48              >            pha         ;use stack to load status
214d : a97e            >            lda #$7e     ;precharge accu
214f : 28              >            plp
                        
2150 : d11c                     cmp (ind1),y
                                tst_a $7e,fn
2152 : 08              >            php         ;save flags
2153 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2155 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2157 : 68              >            pla         ;load status
2158 : 48              >            pha
                       >            cmp_flag fn
2159 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
215b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
215d : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
215e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2160 : 48              >            pha         ;use stack to load status
2161 : a980            >            lda #$80     ;precharge accu
2163 : 28              >            plp
                        
2164 : d11c                     cmp (ind1),y
                                tst_a $80,~fnz
2166 : 08              >            php         ;save flags
2167 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2169 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
216b : 68              >            pla         ;load status
216c : 48              >            pha
                       >            cmp_flag ~fnz
216d : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
216f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2171 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2172 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2174 : 48              >            pha         ;use stack to load status
2175 : a97f            >            lda #$7f     ;precharge accu
2177 : 28              >            plp
                        
2178 : d11c                     cmp (ind1),y
                                tst_a $7f,~fn
217a : 08              >            php         ;save flags
217b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
217d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
217f : 68              >            pla         ;load status
2180 : 48              >            pha
                       >            cmp_flag ~fn
2181 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2183 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2185 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2186 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2188 : 48              >            pha         ;use stack to load status
2189 : a97e            >            lda #$7e     ;precharge accu
218b : 28              >            plp
                        
218c : d11c                     cmp (ind1),y
                                tst_a $7e,~fzc
218e : 08              >            php         ;save flags
218f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2191 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2193 : 68              >            pla         ;load status
2194 : 48              >            pha
                       >            cmp_flag ~fzc
2195 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2197 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2199 : 28              >            plp         ;restore status
                        
                                next_test
219a : ad0002          >            lda test_case   ;previous test
219d : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
219f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
21a1 : a91d            >            lda #test_num   ;*** next tests' number
21a3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
21a6 : a205                     ldx #5
21a8 :                  tasl
                                set_ax zps,0
                       >            load_flag 0
21a8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21aa : 48              >            pha         ;use stack to load status
21ab : b509            >            lda zps,x    ;precharge accu
21ad : 28              >            plp
                        
21ae : 0a                       asl a
                                tst_ax rASL,fASL,0
21af : 08              >            php         ;save flags
21b0 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
21b3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
21b5 : 68              >            pla         ;load status
                       >            eor_flag 0
21b6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
21b8 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
21bb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
21bd : ca                       dex
21be : 10e8                     bpl tasl
21c0 : a205                     ldx #5
21c2 :                  tasl1
                                set_ax zps,$ff
                       >            load_flag $ff
21c2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21c4 : 48              >            pha         ;use stack to load status
21c5 : b509            >            lda zps,x    ;precharge accu
21c7 : 28              >            plp
                        
21c8 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
21c9 : 08              >            php         ;save flags
21ca : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
21cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
21cf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
21d0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
21d2 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
21d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
21d7 : ca                       dex
21d8 : 10e8                     bpl tasl1
                        
21da : a205                     ldx #5
21dc :                  tlsr
                                set_ax zps,0
                       >            load_flag 0
21dc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21de : 48              >            pha         ;use stack to load status
21df : b509            >            lda zps,x    ;precharge accu
21e1 : 28              >            plp
                        
21e2 : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
21e3 : 08              >            php         ;save flags
21e4 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
21e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
21e9 : 68              >            pla         ;load status
                       >            eor_flag 0
21ea : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
21ec : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
21ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
21f1 : ca                       dex
21f2 : 10e8                     bpl tlsr
21f4 : a205                     ldx #5
21f6 :                  tlsr1
                                set_ax zps,$ff
                       >            load_flag $ff
21f6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21f8 : 48              >            pha         ;use stack to load status
21f9 : b509            >            lda zps,x    ;precharge accu
21fb : 28              >            plp
                        
21fc : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
21fd : 08              >            php         ;save flags
21fe : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2201 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2203 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2204 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2206 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
2209 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
220b : ca                       dex
220c : 10e8                     bpl tlsr1
                        
220e : a205                     ldx #5
2210 :                  trol
                                set_ax zps,0
                       >            load_flag 0
2210 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2212 : 48              >            pha         ;use stack to load status
2213 : b509            >            lda zps,x    ;precharge accu
2215 : 28              >            plp
                        
2216 : 2a                       rol a
                                tst_ax rROL,fROL,0
2217 : 08              >            php         ;save flags
2218 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
221b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
221d : 68              >            pla         ;load status
                       >            eor_flag 0
221e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2220 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2223 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2225 : ca                       dex
2226 : 10e8                     bpl trol
2228 : a205                     ldx #5
222a :                  trol1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
222a : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
222c : 48              >            pha         ;use stack to load status
222d : b509            >            lda zps,x    ;precharge accu
222f : 28              >            plp
                        
2230 : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
2231 : 08              >            php         ;save flags
2232 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2235 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2237 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2238 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
223a : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
223d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
223f : ca                       dex
2240 : 10e8                     bpl trol1
                        
2242 : a205                     ldx #5
2244 :                  trolc
                                set_ax zps,fc
                       >            load_flag fc
2244 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2246 : 48              >            pha         ;use stack to load status
2247 : b509            >            lda zps,x    ;precharge accu
2249 : 28              >            plp
                        
224a : 2a                       rol a
                                tst_ax rROLc,fROLc,0
224b : 08              >            php         ;save flags
224c : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
224f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2251 : 68              >            pla         ;load status
                       >            eor_flag 0
2252 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2254 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2257 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2259 : ca                       dex
225a : 10e8                     bpl trolc
225c : a205                     ldx #5
225e :                  trolc1
                                set_ax zps,$ff
                       >            load_flag $ff
225e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2260 : 48              >            pha         ;use stack to load status
2261 : b509            >            lda zps,x    ;precharge accu
2263 : 28              >            plp
                        
2264 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
2265 : 08              >            php         ;save flags
2266 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2269 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
226b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
226c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
226e : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2271 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2273 : ca                       dex
2274 : 10e8                     bpl trolc1
                        
2276 : a205                     ldx #5
2278 :                  tror
                                set_ax zps,0
                       >            load_flag 0
2278 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
227a : 48              >            pha         ;use stack to load status
227b : b509            >            lda zps,x    ;precharge accu
227d : 28              >            plp
                        
227e : 6a                       ror a
                                tst_ax rROR,fROR,0
227f : 08              >            php         ;save flags
2280 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2283 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2285 : 68              >            pla         ;load status
                       >            eor_flag 0
2286 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2288 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
228b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
228d : ca                       dex
228e : 10e8                     bpl tror
2290 : a205                     ldx #5
2292 :                  tror1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
2292 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2294 : 48              >            pha         ;use stack to load status
2295 : b509            >            lda zps,x    ;precharge accu
2297 : 28              >            plp
                        
2298 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
2299 : 08              >            php         ;save flags
229a : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
229d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
229f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22a0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22a2 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
22a5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
22a7 : ca                       dex
22a8 : 10e8                     bpl tror1
                        
22aa : a205                     ldx #5
22ac :                  trorc
                                set_ax zps,fc
                       >            load_flag fc
22ac : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
22ae : 48              >            pha         ;use stack to load status
22af : b509            >            lda zps,x    ;precharge accu
22b1 : 28              >            plp
                        
22b2 : 6a                       ror a
                                tst_ax rRORc,fRORc,0
22b3 : 08              >            php         ;save flags
22b4 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
22b7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
22b9 : 68              >            pla         ;load status
                       >            eor_flag 0
22ba : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22bc : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
22bf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
22c1 : ca                       dex
22c2 : 10e8                     bpl trorc
22c4 : a205                     ldx #5
22c6 :                  trorc1
                                set_ax zps,$ff
                       >            load_flag $ff
22c6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22c8 : 48              >            pha         ;use stack to load status
22c9 : b509            >            lda zps,x    ;precharge accu
22cb : 28              >            plp
                        
22cc : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
22cd : 08              >            php         ;save flags
22ce : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
22d1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
22d3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22d4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22d6 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
22d9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
22db : ca                       dex
22dc : 10e8                     bpl trorc1
                                next_test
22de : ad0002          >            lda test_case   ;previous test
22e1 : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
22e3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
22e5 : a91e            >            lda #test_num   ;*** next tests' number
22e7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
22ea : a205                     ldx #5
22ec :                  tasl2
                                set_z zps,0
                       >            load_flag 0
22ec : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22ee : 48              >            pha         ;use stack to load status
22ef : b509            >            lda zps,x    ;load to zeropage
22f1 : 8502            >            sta zpt
22f3 : 28              >            plp
                        
22f4 : 0602                     asl zpt
                                tst_z rASL,fASL,0
22f6 : 08              >            php         ;save flags
22f7 : a502            >            lda zpt
22f9 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
22fc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
22fe : 68              >            pla         ;load status
                       >            eor_flag 0
22ff : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2301 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2304 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2306 : ca                       dex
2307 : 10e3                     bpl tasl2
2309 : a205                     ldx #5
230b :                  tasl3
                                set_z zps,$ff
                       >            load_flag $ff
230b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
230d : 48              >            pha         ;use stack to load status
230e : b509            >            lda zps,x    ;load to zeropage
2310 : 8502            >            sta zpt
2312 : 28              >            plp
                        
2313 : 0602                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
2315 : 08              >            php         ;save flags
2316 : a502            >            lda zpt
2318 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
231b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
231d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
231e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2320 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2323 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2325 : ca                       dex
2326 : 10e3                     bpl tasl3
                        
2328 : a205                     ldx #5
232a :                  tlsr2
                                set_z zps,0
                       >            load_flag 0
232a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
232c : 48              >            pha         ;use stack to load status
232d : b509            >            lda zps,x    ;load to zeropage
232f : 8502            >            sta zpt
2331 : 28              >            plp
                        
2332 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,0
2334 : 08              >            php         ;save flags
2335 : a502            >            lda zpt
2337 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
233a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
233c : 68              >            pla         ;load status
                       >            eor_flag 0
233d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
233f : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2342 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2344 : ca                       dex
2345 : 10e3                     bpl tlsr2
2347 : a205                     ldx #5
2349 :                  tlsr3
                                set_z zps,$ff
                       >            load_flag $ff
2349 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
234b : 48              >            pha         ;use stack to load status
234c : b509            >            lda zps,x    ;load to zeropage
234e : 8502            >            sta zpt
2350 : 28              >            plp
                        
2351 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
2353 : 08              >            php         ;save flags
2354 : a502            >            lda zpt
2356 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2359 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
235b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
235c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
235e : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2361 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2363 : ca                       dex
2364 : 10e3                     bpl tlsr3
                        
2366 : a205                     ldx #5
2368 :                  trol2
                                set_z zps,0
                       >            load_flag 0
2368 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
236a : 48              >            pha         ;use stack to load status
236b : b509            >            lda zps,x    ;load to zeropage
236d : 8502            >            sta zpt
236f : 28              >            plp
                        
2370 : 2602                     rol zpt
                                tst_z rROL,fROL,0
2372 : 08              >            php         ;save flags
2373 : a502            >            lda zpt
2375 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2378 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
237a : 68              >            pla         ;load status
                       >            eor_flag 0
237b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
237d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2380 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2382 : ca                       dex
2383 : 10e3                     bpl trol2
2385 : a205                     ldx #5
2387 :                  trol3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
2387 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2389 : 48              >            pha         ;use stack to load status
238a : b509            >            lda zps,x    ;load to zeropage
238c : 8502            >            sta zpt
238e : 28              >            plp
                        
238f : 2602                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
2391 : 08              >            php         ;save flags
2392 : a502            >            lda zpt
2394 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2397 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2399 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
239a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
239c : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
239f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
23a1 : ca                       dex
23a2 : 10e3                     bpl trol3
                        
23a4 : a205                     ldx #5
23a6 :                  trolc2
                                set_z zps,fc
                       >            load_flag fc
23a6 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
23a8 : 48              >            pha         ;use stack to load status
23a9 : b509            >            lda zps,x    ;load to zeropage
23ab : 8502            >            sta zpt
23ad : 28              >            plp
                        
23ae : 2602                     rol zpt
                                tst_z rROLc,fROLc,0
23b0 : 08              >            php         ;save flags
23b1 : a502            >            lda zpt
23b3 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
23b6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
23b8 : 68              >            pla         ;load status
                       >            eor_flag 0
23b9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23bb : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
23be : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
23c0 : ca                       dex
23c1 : 10e3                     bpl trolc2
23c3 : a205                     ldx #5
23c5 :                  trolc3
                                set_z zps,$ff
                       >            load_flag $ff
23c5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23c7 : 48              >            pha         ;use stack to load status
23c8 : b509            >            lda zps,x    ;load to zeropage
23ca : 8502            >            sta zpt
23cc : 28              >            plp
                        
23cd : 2602                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
23cf : 08              >            php         ;save flags
23d0 : a502            >            lda zpt
23d2 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
23d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
23d7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23d8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23da : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
23dd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
23df : ca                       dex
23e0 : 10e3                     bpl trolc3
                        
23e2 : a205                     ldx #5
23e4 :                  tror2
                                set_z zps,0
                       >            load_flag 0
23e4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23e6 : 48              >            pha         ;use stack to load status
23e7 : b509            >            lda zps,x    ;load to zeropage
23e9 : 8502            >            sta zpt
23eb : 28              >            plp
                        
23ec : 6602                     ror zpt
                                tst_z rROR,fROR,0
23ee : 08              >            php         ;save flags
23ef : a502            >            lda zpt
23f1 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
23f4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
23f6 : 68              >            pla         ;load status
                       >            eor_flag 0
23f7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23f9 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
23fc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
23fe : ca                       dex
23ff : 10e3                     bpl tror2
2401 : a205                     ldx #5
2403 :                  tror3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
2403 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2405 : 48              >            pha         ;use stack to load status
2406 : b509            >            lda zps,x    ;load to zeropage
2408 : 8502            >            sta zpt
240a : 28              >            plp
                        
240b : 6602                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
240d : 08              >            php         ;save flags
240e : a502            >            lda zpt
2410 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2413 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2415 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2416 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2418 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
241b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
241d : ca                       dex
241e : 10e3                     bpl tror3
                        
2420 : a205                     ldx #5
2422 :                  trorc2
                                set_z zps,fc
                       >            load_flag fc
2422 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2424 : 48              >            pha         ;use stack to load status
2425 : b509            >            lda zps,x    ;load to zeropage
2427 : 8502            >            sta zpt
2429 : 28              >            plp
                        
242a : 6602                     ror zpt
                                tst_z rRORc,fRORc,0
242c : 08              >            php         ;save flags
242d : a502            >            lda zpt
242f : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2432 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2434 : 68              >            pla         ;load status
                       >            eor_flag 0
2435 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2437 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
243a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
243c : ca                       dex
243d : 10e3                     bpl trorc2
243f : a205                     ldx #5
2441 :                  trorc3
                                set_z zps,$ff
                       >            load_flag $ff
2441 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2443 : 48              >            pha         ;use stack to load status
2444 : b509            >            lda zps,x    ;load to zeropage
2446 : 8502            >            sta zpt
2448 : 28              >            plp
                        
2449 : 6602                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
244b : 08              >            php         ;save flags
244c : a502            >            lda zpt
244e : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2451 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2453 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2454 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2456 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2459 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
245b : ca                       dex
245c : 10e3                     bpl trorc3
                                next_test
245e : ad0002          >            lda test_case   ;previous test
2461 : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2463 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
2465 : a91f            >            lda #test_num   ;*** next tests' number
2467 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
246a : a205                     ldx #5
246c :                  tasl4
                                set_abs zps,0
                       >            load_flag 0
246c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
246e : 48              >            pha         ;use stack to load status
246f : b509            >            lda zps,x    ;load to memory
2471 : 8d0302          >            sta abst
2474 : 28              >            plp
                        
2475 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
2478 : 08              >            php         ;save flags
2479 : ad0302          >            lda abst
247c : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
247f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2481 : 68              >            pla         ;load status
                       >            eor_flag 0
2482 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2484 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2487 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2489 : ca                       dex
248a : 10e0                     bpl tasl4
248c : a205                     ldx #5
248e :                  tasl5
                                set_abs zps,$ff
                       >            load_flag $ff
248e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2490 : 48              >            pha         ;use stack to load status
2491 : b509            >            lda zps,x    ;load to memory
2493 : 8d0302          >            sta abst
2496 : 28              >            plp
                        
2497 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
249a : 08              >            php         ;save flags
249b : ad0302          >            lda abst
249e : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
24a1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
24a3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24a4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24a6 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
24a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
24ab : ca                       dex
24ac : 10e0                     bpl tasl5
                        
24ae : a205                     ldx #5
24b0 :                  tlsr4
                                set_abs zps,0
                       >            load_flag 0
24b0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24b2 : 48              >            pha         ;use stack to load status
24b3 : b509            >            lda zps,x    ;load to memory
24b5 : 8d0302          >            sta abst
24b8 : 28              >            plp
                        
24b9 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
24bc : 08              >            php         ;save flags
24bd : ad0302          >            lda abst
24c0 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
24c3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
24c5 : 68              >            pla         ;load status
                       >            eor_flag 0
24c6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24c8 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
24cb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
24cd : ca                       dex
24ce : 10e0                     bpl tlsr4
24d0 : a205                     ldx #5
24d2 :                  tlsr5
                                set_abs zps,$ff
                       >            load_flag $ff
24d2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
24d4 : 48              >            pha         ;use stack to load status
24d5 : b509            >            lda zps,x    ;load to memory
24d7 : 8d0302          >            sta abst
24da : 28              >            plp
                        
24db : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
24de : 08              >            php         ;save flags
24df : ad0302          >            lda abst
24e2 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
24e5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
24e7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24e8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24ea : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
24ed : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
24ef : ca                       dex
24f0 : 10e0                     bpl tlsr5
                        
24f2 : a205                     ldx #5
24f4 :                  trol4
                                set_abs zps,0
                       >            load_flag 0
24f4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24f6 : 48              >            pha         ;use stack to load status
24f7 : b509            >            lda zps,x    ;load to memory
24f9 : 8d0302          >            sta abst
24fc : 28              >            plp
                        
24fd : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
2500 : 08              >            php         ;save flags
2501 : ad0302          >            lda abst
2504 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2507 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2509 : 68              >            pla         ;load status
                       >            eor_flag 0
250a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
250c : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
250f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2511 : ca                       dex
2512 : 10e0                     bpl trol4
2514 : a205                     ldx #5
2516 :                  trol5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
2516 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2518 : 48              >            pha         ;use stack to load status
2519 : b509            >            lda zps,x    ;load to memory
251b : 8d0302          >            sta abst
251e : 28              >            plp
                        
251f : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
2522 : 08              >            php         ;save flags
2523 : ad0302          >            lda abst
2526 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2529 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
252b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
252c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
252e : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2531 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2533 : ca                       dex
2534 : 10e0                     bpl trol5
                        
2536 : a205                     ldx #5
2538 :                  trolc4
                                set_abs zps,fc
                       >            load_flag fc
2538 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
253a : 48              >            pha         ;use stack to load status
253b : b509            >            lda zps,x    ;load to memory
253d : 8d0302          >            sta abst
2540 : 28              >            plp
                        
2541 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
2544 : 08              >            php         ;save flags
2545 : ad0302          >            lda abst
2548 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
254b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
254d : 68              >            pla         ;load status
                       >            eor_flag 0
254e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2550 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2553 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2555 : ca                       dex
2556 : 10e0                     bpl trolc4
2558 : a205                     ldx #5
255a :                  trolc5
                                set_abs zps,$ff
                       >            load_flag $ff
255a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
255c : 48              >            pha         ;use stack to load status
255d : b509            >            lda zps,x    ;load to memory
255f : 8d0302          >            sta abst
2562 : 28              >            plp
                        
2563 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
2566 : 08              >            php         ;save flags
2567 : ad0302          >            lda abst
256a : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
256d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
256f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2570 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2572 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2575 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2577 : ca                       dex
2578 : 10e0                     bpl trolc5
                        
257a : a205                     ldx #5
257c :                  tror4
                                set_abs zps,0
                       >            load_flag 0
257c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
257e : 48              >            pha         ;use stack to load status
257f : b509            >            lda zps,x    ;load to memory
2581 : 8d0302          >            sta abst
2584 : 28              >            plp
                        
2585 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2588 : 08              >            php         ;save flags
2589 : ad0302          >            lda abst
258c : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
258f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2591 : 68              >            pla         ;load status
                       >            eor_flag 0
2592 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2594 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2597 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2599 : ca                       dex
259a : 10e0                     bpl tror4
259c : a205                     ldx #5
259e :                  tror5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
259e : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
25a0 : 48              >            pha         ;use stack to load status
25a1 : b509            >            lda zps,x    ;load to memory
25a3 : 8d0302          >            sta abst
25a6 : 28              >            plp
                        
25a7 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
25aa : 08              >            php         ;save flags
25ab : ad0302          >            lda abst
25ae : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
25b1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
25b3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25b4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25b6 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
25b9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
25bb : ca                       dex
25bc : 10e0                     bpl tror5
                        
25be : a205                     ldx #5
25c0 :                  trorc4
                                set_abs zps,fc
                       >            load_flag fc
25c0 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
25c2 : 48              >            pha         ;use stack to load status
25c3 : b509            >            lda zps,x    ;load to memory
25c5 : 8d0302          >            sta abst
25c8 : 28              >            plp
                        
25c9 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
25cc : 08              >            php         ;save flags
25cd : ad0302          >            lda abst
25d0 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
25d3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
25d5 : 68              >            pla         ;load status
                       >            eor_flag 0
25d6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25d8 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
25db : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
25dd : ca                       dex
25de : 10e0                     bpl trorc4
25e0 : a205                     ldx #5
25e2 :                  trorc5
                                set_abs zps,$ff
                       >            load_flag $ff
25e2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
25e4 : 48              >            pha         ;use stack to load status
25e5 : b509            >            lda zps,x    ;load to memory
25e7 : 8d0302          >            sta abst
25ea : 28              >            plp
                        
25eb : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
25ee : 08              >            php         ;save flags
25ef : ad0302          >            lda abst
25f2 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
25f5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
25f7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25f8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25fa : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
25fd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
25ff : ca                       dex
2600 : 10e0                     bpl trorc5
                                next_test
2602 : ad0002          >            lda test_case   ;previous test
2605 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2607 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
2609 : a920            >            lda #test_num   ;*** next tests' number
260b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
260e : a205                     ldx #5
2610 :                  tasl6
                                set_zx zps,0
                       >            load_flag 0
2610 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2612 : 48              >            pha         ;use stack to load status
2613 : b509            >            lda zps,x    ;load to indexed zeropage
2615 : 9502            >            sta zpt,x
2617 : 28              >            plp
                        
2618 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,0
261a : 08              >            php         ;save flags
261b : b502            >            lda zpt,x
261d : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2620 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2622 : 68              >            pla         ;load status
                       >            eor_flag 0
2623 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2625 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2628 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
262a : ca                       dex
262b : 10e3                     bpl tasl6
262d : a205                     ldx #5
262f :                  tasl7
                                set_zx zps,$ff
                       >            load_flag $ff
262f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2631 : 48              >            pha         ;use stack to load status
2632 : b509            >            lda zps,x    ;load to indexed zeropage
2634 : 9502            >            sta zpt,x
2636 : 28              >            plp
                        
2637 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2639 : 08              >            php         ;save flags
263a : b502            >            lda zpt,x
263c : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
263f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2641 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2642 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2644 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2647 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2649 : ca                       dex
264a : 10e3                     bpl tasl7
                        
264c : a205                     ldx #5
264e :                  tlsr6
                                set_zx zps,0
                       >            load_flag 0
264e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2650 : 48              >            pha         ;use stack to load status
2651 : b509            >            lda zps,x    ;load to indexed zeropage
2653 : 9502            >            sta zpt,x
2655 : 28              >            plp
                        
2656 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2658 : 08              >            php         ;save flags
2659 : b502            >            lda zpt,x
265b : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
265e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2660 : 68              >            pla         ;load status
                       >            eor_flag 0
2661 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2663 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2666 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2668 : ca                       dex
2669 : 10e3                     bpl tlsr6
266b : a205                     ldx #5
266d :                  tlsr7
                                set_zx zps,$ff
                       >            load_flag $ff
266d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
266f : 48              >            pha         ;use stack to load status
2670 : b509            >            lda zps,x    ;load to indexed zeropage
2672 : 9502            >            sta zpt,x
2674 : 28              >            plp
                        
2675 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
2677 : 08              >            php         ;save flags
2678 : b502            >            lda zpt,x
267a : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
267d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
267f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2680 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2682 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2685 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2687 : ca                       dex
2688 : 10e3                     bpl tlsr7
                        
268a : a205                     ldx #5
268c :                  trol6
                                set_zx zps,0
                       >            load_flag 0
268c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
268e : 48              >            pha         ;use stack to load status
268f : b509            >            lda zps,x    ;load to indexed zeropage
2691 : 9502            >            sta zpt,x
2693 : 28              >            plp
                        
2694 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,0
2696 : 08              >            php         ;save flags
2697 : b502            >            lda zpt,x
2699 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
269c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
269e : 68              >            pla         ;load status
                       >            eor_flag 0
269f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26a1 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
26a4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
26a6 : ca                       dex
26a7 : 10e3                     bpl trol6
26a9 : a205                     ldx #5
26ab :                  trol7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
26ab : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
26ad : 48              >            pha         ;use stack to load status
26ae : b509            >            lda zps,x    ;load to indexed zeropage
26b0 : 9502            >            sta zpt,x
26b2 : 28              >            plp
                        
26b3 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
26b5 : 08              >            php         ;save flags
26b6 : b502            >            lda zpt,x
26b8 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
26bb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
26bd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26be : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26c0 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
26c3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
26c5 : ca                       dex
26c6 : 10e3                     bpl trol7
                        
26c8 : a205                     ldx #5
26ca :                  trolc6
                                set_zx zps,fc
                       >            load_flag fc
26ca : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
26cc : 48              >            pha         ;use stack to load status
26cd : b509            >            lda zps,x    ;load to indexed zeropage
26cf : 9502            >            sta zpt,x
26d1 : 28              >            plp
                        
26d2 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,0
26d4 : 08              >            php         ;save flags
26d5 : b502            >            lda zpt,x
26d7 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
26da : d0fe            >        bne *         ;failed not equal (non zero)
                       >
26dc : 68              >            pla         ;load status
                       >            eor_flag 0
26dd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26df : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
26e2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
26e4 : ca                       dex
26e5 : 10e3                     bpl trolc6
26e7 : a205                     ldx #5
26e9 :                  trolc7
                                set_zx zps,$ff
                       >            load_flag $ff
26e9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26eb : 48              >            pha         ;use stack to load status
26ec : b509            >            lda zps,x    ;load to indexed zeropage
26ee : 9502            >            sta zpt,x
26f0 : 28              >            plp
                        
26f1 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
26f3 : 08              >            php         ;save flags
26f4 : b502            >            lda zpt,x
26f6 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
26f9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
26fb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26fc : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26fe : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2701 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2703 : ca                       dex
2704 : 10e3                     bpl trolc7
                        
2706 : a205                     ldx #5
2708 :                  tror6
                                set_zx zps,0
                       >            load_flag 0
2708 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
270a : 48              >            pha         ;use stack to load status
270b : b509            >            lda zps,x    ;load to indexed zeropage
270d : 9502            >            sta zpt,x
270f : 28              >            plp
                        
2710 : 7602                     ror zpt,x
                                tst_zx rROR,fROR,0
2712 : 08              >            php         ;save flags
2713 : b502            >            lda zpt,x
2715 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2718 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
271a : 68              >            pla         ;load status
                       >            eor_flag 0
271b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
271d : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2720 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2722 : ca                       dex
2723 : 10e3                     bpl tror6
2725 : a205                     ldx #5
2727 :                  tror7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
2727 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2729 : 48              >            pha         ;use stack to load status
272a : b509            >            lda zps,x    ;load to indexed zeropage
272c : 9502            >            sta zpt,x
272e : 28              >            plp
                        
272f : 7602                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
2731 : 08              >            php         ;save flags
2732 : b502            >            lda zpt,x
2734 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2737 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2739 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
273a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
273c : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
273f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2741 : ca                       dex
2742 : 10e3                     bpl tror7
                        
2744 : a205                     ldx #5
2746 :                  trorc6
                                set_zx zps,fc
                       >            load_flag fc
2746 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2748 : 48              >            pha         ;use stack to load status
2749 : b509            >            lda zps,x    ;load to indexed zeropage
274b : 9502            >            sta zpt,x
274d : 28              >            plp
                        
274e : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,0
2750 : 08              >            php         ;save flags
2751 : b502            >            lda zpt,x
2753 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2756 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2758 : 68              >            pla         ;load status
                       >            eor_flag 0
2759 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
275b : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
275e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2760 : ca                       dex
2761 : 10e3                     bpl trorc6
2763 : a205                     ldx #5
2765 :                  trorc7
                                set_zx zps,$ff
                       >            load_flag $ff
2765 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2767 : 48              >            pha         ;use stack to load status
2768 : b509            >            lda zps,x    ;load to indexed zeropage
276a : 9502            >            sta zpt,x
276c : 28              >            plp
                        
276d : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
276f : 08              >            php         ;save flags
2770 : b502            >            lda zpt,x
2772 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2775 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2777 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2778 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
277a : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
277d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
277f : ca                       dex
2780 : 10e3                     bpl trorc7
                                next_test
2782 : ad0002          >            lda test_case   ;previous test
2785 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2787 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2789 : a921            >            lda #test_num   ;*** next tests' number
278b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
278e : a205                     ldx #5
2790 :                  tasl8
                                set_absx zps,0
                       >            load_flag 0
2790 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2792 : 48              >            pha         ;use stack to load status
2793 : b509            >            lda zps,x    ;load to indexed memory
2795 : 9d0302          >            sta abst,x
2798 : 28              >            plp
                        
2799 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
279c : 08              >            php         ;save flags
279d : bd0302          >            lda abst,x
27a0 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
27a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
27a5 : 68              >            pla         ;load status
                       >            eor_flag 0
27a6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27a8 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
27ab : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
27ad : ca                       dex
27ae : 10e0                     bpl tasl8
27b0 : a205                     ldx #5
27b2 :                  tasl9
                                set_absx zps,$ff
                       >            load_flag $ff
27b2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27b4 : 48              >            pha         ;use stack to load status
27b5 : b509            >            lda zps,x    ;load to indexed memory
27b7 : 9d0302          >            sta abst,x
27ba : 28              >            plp
                        
27bb : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
27be : 08              >            php         ;save flags
27bf : bd0302          >            lda abst,x
27c2 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
27c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
27c7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27c8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27ca : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
27cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
27cf : ca                       dex
27d0 : 10e0                     bpl tasl9
                        
27d2 : a205                     ldx #5
27d4 :                  tlsr8
                                set_absx zps,0
                       >            load_flag 0
27d4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27d6 : 48              >            pha         ;use stack to load status
27d7 : b509            >            lda zps,x    ;load to indexed memory
27d9 : 9d0302          >            sta abst,x
27dc : 28              >            plp
                        
27dd : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
27e0 : 08              >            php         ;save flags
27e1 : bd0302          >            lda abst,x
27e4 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
27e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
27e9 : 68              >            pla         ;load status
                       >            eor_flag 0
27ea : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27ec : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
27ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
27f1 : ca                       dex
27f2 : 10e0                     bpl tlsr8
27f4 : a205                     ldx #5
27f6 :                  tlsr9
                                set_absx zps,$ff
                       >            load_flag $ff
27f6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27f8 : 48              >            pha         ;use stack to load status
27f9 : b509            >            lda zps,x    ;load to indexed memory
27fb : 9d0302          >            sta abst,x
27fe : 28              >            plp
                        
27ff : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
2802 : 08              >            php         ;save flags
2803 : bd0302          >            lda abst,x
2806 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2809 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
280b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
280c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
280e : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2811 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2813 : ca                       dex
2814 : 10e0                     bpl tlsr9
                        
2816 : a205                     ldx #5
2818 :                  trol8
                                set_absx zps,0
                       >            load_flag 0
2818 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
281a : 48              >            pha         ;use stack to load status
281b : b509            >            lda zps,x    ;load to indexed memory
281d : 9d0302          >            sta abst,x
2820 : 28              >            plp
                        
2821 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
2824 : 08              >            php         ;save flags
2825 : bd0302          >            lda abst,x
2828 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
282b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
282d : 68              >            pla         ;load status
                       >            eor_flag 0
282e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2830 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2833 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2835 : ca                       dex
2836 : 10e0                     bpl trol8
2838 : a205                     ldx #5
283a :                  trol9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
283a : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
283c : 48              >            pha         ;use stack to load status
283d : b509            >            lda zps,x    ;load to indexed memory
283f : 9d0302          >            sta abst,x
2842 : 28              >            plp
                        
2843 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2846 : 08              >            php         ;save flags
2847 : bd0302          >            lda abst,x
284a : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
284d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
284f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2850 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2852 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2855 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2857 : ca                       dex
2858 : 10e0                     bpl trol9
                        
285a : a205                     ldx #5
285c :                  trolc8
                                set_absx zps,fc
                       >            load_flag fc
285c : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
285e : 48              >            pha         ;use stack to load status
285f : b509            >            lda zps,x    ;load to indexed memory
2861 : 9d0302          >            sta abst,x
2864 : 28              >            plp
                        
2865 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2868 : 08              >            php         ;save flags
2869 : bd0302          >            lda abst,x
286c : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
286f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2871 : 68              >            pla         ;load status
                       >            eor_flag 0
2872 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2874 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2877 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2879 : ca                       dex
287a : 10e0                     bpl trolc8
287c : a205                     ldx #5
287e :                  trolc9
                                set_absx zps,$ff
                       >            load_flag $ff
287e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2880 : 48              >            pha         ;use stack to load status
2881 : b509            >            lda zps,x    ;load to indexed memory
2883 : 9d0302          >            sta abst,x
2886 : 28              >            plp
                        
2887 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
288a : 08              >            php         ;save flags
288b : bd0302          >            lda abst,x
288e : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2891 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2893 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2894 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2896 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2899 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
289b : ca                       dex
289c : 10e0                     bpl trolc9
                        
289e : a205                     ldx #5
28a0 :                  tror8
                                set_absx zps,0
                       >            load_flag 0
28a0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28a2 : 48              >            pha         ;use stack to load status
28a3 : b509            >            lda zps,x    ;load to indexed memory
28a5 : 9d0302          >            sta abst,x
28a8 : 28              >            plp
                        
28a9 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
28ac : 08              >            php         ;save flags
28ad : bd0302          >            lda abst,x
28b0 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
28b3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
28b5 : 68              >            pla         ;load status
                       >            eor_flag 0
28b6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28b8 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
28bb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
28bd : ca                       dex
28be : 10e0                     bpl tror8
28c0 : a205                     ldx #5
28c2 :                  tror9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
28c2 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
28c4 : 48              >            pha         ;use stack to load status
28c5 : b509            >            lda zps,x    ;load to indexed memory
28c7 : 9d0302          >            sta abst,x
28ca : 28              >            plp
                        
28cb : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
28ce : 08              >            php         ;save flags
28cf : bd0302          >            lda abst,x
28d2 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
28d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
28d7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28d8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28da : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
28dd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
28df : ca                       dex
28e0 : 10e0                     bpl tror9
                        
28e2 : a205                     ldx #5
28e4 :                  trorc8
                                set_absx zps,fc
                       >            load_flag fc
28e4 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
28e6 : 48              >            pha         ;use stack to load status
28e7 : b509            >            lda zps,x    ;load to indexed memory
28e9 : 9d0302          >            sta abst,x
28ec : 28              >            plp
                        
28ed : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
28f0 : 08              >            php         ;save flags
28f1 : bd0302          >            lda abst,x
28f4 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
28f7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
28f9 : 68              >            pla         ;load status
                       >            eor_flag 0
28fa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28fc : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
28ff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2901 : ca                       dex
2902 : 10e0                     bpl trorc8
2904 : a205                     ldx #5
2906 :                  trorc9
                                set_absx zps,$ff
                       >            load_flag $ff
2906 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2908 : 48              >            pha         ;use stack to load status
2909 : b509            >            lda zps,x    ;load to indexed memory
290b : 9d0302          >            sta abst,x
290e : 28              >            plp
                        
290f : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
2912 : 08              >            php         ;save flags
2913 : bd0302          >            lda abst,x
2916 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2919 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
291b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
291c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
291e : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2921 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2923 : ca                       dex
2924 : 10e0                     bpl trorc9
                                next_test
2926 : ad0002          >            lda test_case   ;previous test
2929 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
292b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
292d : a922            >            lda #test_num   ;*** next tests' number
292f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2932 : a200                     ldx #0
2934 : a97e                     lda #$7e
2936 : 8502                     sta zpt
2938 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2938 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
293a : 48              >            pha         ;use stack to load status
293b : 28              >            plp
                        
293c : e602                     inc zpt
                                tst_z rINC,fINC,0
293e : 08              >            php         ;save flags
293f : a502            >            lda zpt
2941 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2944 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2946 : 68              >            pla         ;load status
                       >            eor_flag 0
2947 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2949 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
294c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
294e : e8                       inx
294f : e002                     cpx #2
2951 : d004                     bne tinc1
2953 : a9fe                     lda #$fe
2955 : 8502                     sta zpt
2957 : e005             tinc1   cpx #5
2959 : d0dd                     bne tinc
295b : ca                       dex
295c : e602                     inc zpt
295e :                  tdec    
                                set_stat 0
                       >            load_flag 0
295e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2960 : 48              >            pha         ;use stack to load status
2961 : 28              >            plp
                        
2962 : c602                     dec zpt
                                tst_z rINC,fINC,0
2964 : 08              >            php         ;save flags
2965 : a502            >            lda zpt
2967 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
296a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
296c : 68              >            pla         ;load status
                       >            eor_flag 0
296d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
296f : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2972 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2974 : ca                       dex
2975 : 300a                     bmi tdec1
2977 : e001                     cpx #1
2979 : d0e3                     bne tdec
297b : a981                     lda #$81
297d : 8502                     sta zpt
297f : d0dd                     bne tdec
2981 :                  tdec1
2981 : a200                     ldx #0
2983 : a97e                     lda #$7e
2985 : 8502                     sta zpt
2987 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2987 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2989 : 48              >            pha         ;use stack to load status
298a : 28              >            plp
                        
298b : e602                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
298d : 08              >            php         ;save flags
298e : a502            >            lda zpt
2990 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2993 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2995 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2996 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2998 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
299b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
299d : e8                       inx
299e : e002                     cpx #2
29a0 : d004                     bne tinc11
29a2 : a9fe                     lda #$fe
29a4 : 8502                     sta zpt
29a6 : e005             tinc11  cpx #5
29a8 : d0dd                     bne tinc10
29aa : ca                       dex
29ab : e602                     inc zpt
29ad :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
29ad : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29af : 48              >            pha         ;use stack to load status
29b0 : 28              >            plp
                        
29b1 : c602                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
29b3 : 08              >            php         ;save flags
29b4 : a502            >            lda zpt
29b6 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
29b9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
29bb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
29bc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
29be : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
29c1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
29c3 : ca                       dex
29c4 : 300a                     bmi tdec11
29c6 : e001                     cpx #1
29c8 : d0e3                     bne tdec10
29ca : a981                     lda #$81
29cc : 8502                     sta zpt
29ce : d0dd                     bne tdec10
29d0 :                  tdec11
                                next_test
29d0 : ad0002          >            lda test_case   ;previous test
29d3 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
29d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
29d7 : a923            >            lda #test_num   ;*** next tests' number
29d9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
29dc : a200                     ldx #0
29de : a97e                     lda #$7e
29e0 : 8d0302                   sta abst
29e3 :                  tinc2    
                                set_stat 0
                       >            load_flag 0
29e3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
29e5 : 48              >            pha         ;use stack to load status
29e6 : 28              >            plp
                        
29e7 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
29ea : 08              >            php         ;save flags
29eb : ad0302          >            lda abst
29ee : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
29f1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
29f3 : 68              >            pla         ;load status
                       >            eor_flag 0
29f4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29f6 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
29f9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
29fb : e8                       inx
29fc : e002                     cpx #2
29fe : d005                     bne tinc3
2a00 : a9fe                     lda #$fe
2a02 : 8d0302                   sta abst
2a05 : e005             tinc3   cpx #5
2a07 : d0da                     bne tinc2
2a09 : ca                       dex
2a0a : ee0302                   inc abst
2a0d :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2a0d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a0f : 48              >            pha         ;use stack to load status
2a10 : 28              >            plp
                        
2a11 : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2a14 : 08              >            php         ;save flags
2a15 : ad0302          >            lda abst
2a18 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a1b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2a1d : 68              >            pla         ;load status
                       >            eor_flag 0
2a1e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a20 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a23 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2a25 : ca                       dex
2a26 : 300b                     bmi tdec3
2a28 : e001                     cpx #1
2a2a : d0e1                     bne tdec2
2a2c : a981                     lda #$81
2a2e : 8d0302                   sta abst
2a31 : d0da                     bne tdec2
2a33 :                  tdec3
2a33 : a200                     ldx #0
2a35 : a97e                     lda #$7e
2a37 : 8d0302                   sta abst
2a3a :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2a3a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a3c : 48              >            pha         ;use stack to load status
2a3d : 28              >            plp
                        
2a3e : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2a41 : 08              >            php         ;save flags
2a42 : ad0302          >            lda abst
2a45 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a48 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2a4a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a4b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a4d : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a50 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2a52 : e8                       inx
2a53 : e002                     cpx #2
2a55 : d005                     bne tinc13
2a57 : a9fe                     lda #$fe
2a59 : 8d0302                   sta abst
2a5c : e005             tinc13   cpx #5
2a5e : d0da                     bne tinc12
2a60 : ca                       dex
2a61 : ee0302                   inc abst
2a64 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2a64 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a66 : 48              >            pha         ;use stack to load status
2a67 : 28              >            plp
                        
2a68 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2a6b : 08              >            php         ;save flags
2a6c : ad0302          >            lda abst
2a6f : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a72 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2a74 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a75 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a77 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a7a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2a7c : ca                       dex
2a7d : 300b                     bmi tdec13
2a7f : e001                     cpx #1
2a81 : d0e1                     bne tdec12
2a83 : a981                     lda #$81
2a85 : 8d0302                   sta abst
2a88 : d0da                     bne tdec12
2a8a :                  tdec13
                                next_test
2a8a : ad0002          >            lda test_case   ;previous test
2a8d : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2a8f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2a91 : a924            >            lda #test_num   ;*** next tests' number
2a93 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2a96 : a200                     ldx #0
2a98 : a97e                     lda #$7e
2a9a : 9502             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2a9c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a9e : 48              >            pha         ;use stack to load status
2a9f : 28              >            plp
                        
2aa0 : f602                     inc zpt,x
                                tst_zx rINC,fINC,0
2aa2 : 08              >            php         ;save flags
2aa3 : b502            >            lda zpt,x
2aa5 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2aa8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2aaa : 68              >            pla         ;load status
                       >            eor_flag 0
2aab : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2aad : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ab0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ab2 : b502                     lda zpt,x
2ab4 : e8                       inx
2ab5 : e002                     cpx #2
2ab7 : d002                     bne tinc5
2ab9 : a9fe                     lda #$fe
2abb : e005             tinc5   cpx #5
2abd : d0db                     bne tinc4
2abf : ca                       dex
2ac0 : a902                     lda #2
2ac2 : 9502             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2ac4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ac6 : 48              >            pha         ;use stack to load status
2ac7 : 28              >            plp
                        
2ac8 : d602                     dec zpt,x
                                tst_zx rINC,fINC,0
2aca : 08              >            php         ;save flags
2acb : b502            >            lda zpt,x
2acd : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ad0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2ad2 : 68              >            pla         ;load status
                       >            eor_flag 0
2ad3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ad5 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ad8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ada : b502                     lda zpt,x
2adc : ca                       dex
2add : 3008                     bmi tdec5
2adf : e001                     cpx #1
2ae1 : d0df                     bne tdec4
2ae3 : a981                     lda #$81
2ae5 : d0db                     bne tdec4
2ae7 :                  tdec5
2ae7 : a200                     ldx #0
2ae9 : a97e                     lda #$7e
2aeb : 9502             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2aed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2aef : 48              >            pha         ;use stack to load status
2af0 : 28              >            plp
                        
2af1 : f602                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2af3 : 08              >            php         ;save flags
2af4 : b502            >            lda zpt,x
2af6 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2af9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2afb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2afc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2afe : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b01 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2b03 : b502                     lda zpt,x
2b05 : e8                       inx
2b06 : e002                     cpx #2
2b08 : d002                     bne tinc15
2b0a : a9fe                     lda #$fe
2b0c : e005             tinc15  cpx #5
2b0e : d0db                     bne tinc14
2b10 : ca                       dex
2b11 : a902                     lda #2
2b13 : 9502             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2b15 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b17 : 48              >            pha         ;use stack to load status
2b18 : 28              >            plp
                        
2b19 : d602                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2b1b : 08              >            php         ;save flags
2b1c : b502            >            lda zpt,x
2b1e : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2b23 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b24 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b26 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b29 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2b2b : b502                     lda zpt,x
2b2d : ca                       dex
2b2e : 3008                     bmi tdec15
2b30 : e001                     cpx #1
2b32 : d0df                     bne tdec14
2b34 : a981                     lda #$81
2b36 : d0db                     bne tdec14
2b38 :                  tdec15
                                next_test
2b38 : ad0002          >            lda test_case   ;previous test
2b3b : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2b3f : a925            >            lda #test_num   ;*** next tests' number
2b41 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2b44 : a200                     ldx #0
2b46 : a97e                     lda #$7e
2b48 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2b4b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b4d : 48              >            pha         ;use stack to load status
2b4e : 28              >            plp
                        
2b4f : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2b52 : 08              >            php         ;save flags
2b53 : bd0302          >            lda abst,x
2b56 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2b5b : 68              >            pla         ;load status
                       >            eor_flag 0
2b5c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b5e : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b61 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2b63 : bd0302                   lda abst,x
2b66 : e8                       inx
2b67 : e002                     cpx #2
2b69 : d002                     bne tinc7
2b6b : a9fe                     lda #$fe
2b6d : e005             tinc7   cpx #5
2b6f : d0d7                     bne tinc6
2b71 : ca                       dex
2b72 : a902                     lda #2
2b74 : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2b77 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b79 : 48              >            pha         ;use stack to load status
2b7a : 28              >            plp
                        
2b7b : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2b7e : 08              >            php         ;save flags
2b7f : bd0302          >            lda abst,x
2b82 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b85 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2b87 : 68              >            pla         ;load status
                       >            eor_flag 0
2b88 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b8a : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b8d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2b8f : bd0302                   lda abst,x
2b92 : ca                       dex
2b93 : 3008                     bmi tdec7
2b95 : e001                     cpx #1
2b97 : d0db                     bne tdec6
2b99 : a981                     lda #$81
2b9b : d0d7                     bne tdec6
2b9d :                  tdec7
2b9d : a200                     ldx #0
2b9f : a97e                     lda #$7e
2ba1 : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2ba4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ba6 : 48              >            pha         ;use stack to load status
2ba7 : 28              >            plp
                        
2ba8 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2bab : 08              >            php         ;save flags
2bac : bd0302          >            lda abst,x
2baf : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2bb2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2bb4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bb5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bb7 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2bbc : bd0302                   lda abst,x
2bbf : e8                       inx
2bc0 : e002                     cpx #2
2bc2 : d002                     bne tinc17
2bc4 : a9fe                     lda #$fe
2bc6 : e005             tinc17  cpx #5
2bc8 : d0d7                     bne tinc16
2bca : ca                       dex
2bcb : a902                     lda #2
2bcd : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2bd0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2bd2 : 48              >            pha         ;use stack to load status
2bd3 : 28              >            plp
                        
2bd4 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2bd7 : 08              >            php         ;save flags
2bd8 : bd0302          >            lda abst,x
2bdb : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2bde : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2be0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2be1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2be3 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2be6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2be8 : bd0302                   lda abst,x
2beb : ca                       dex
2bec : 3008                     bmi tdec17
2bee : e001                     cpx #1
2bf0 : d0db                     bne tdec16
2bf2 : a981                     lda #$81
2bf4 : d0d7                     bne tdec16
2bf6 :                  tdec17
                                next_test
2bf6 : ad0002          >            lda test_case   ;previous test
2bf9 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2bfb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2bfd : a926            >            lda #test_num   ;*** next tests' number
2bff : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2c02 : a203                     ldx #3          ;immediate
2c04 : b514             tand    lda zpAN,x
2c06 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2c09 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c0b : 48              >            pha         ;use stack to load status
2c0c : bd6b02          >            lda absANa,x    ;precharge accu
2c0f : 28              >            plp
                        
2c10 : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2c13 : 08              >            php         ;save flags
2c14 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c17 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c19 : 68              >            pla         ;load status
                       >            eor_flag 0
2c1a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c1c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2c1f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c21 : ca                       dex
2c22 : 10e0                     bpl tand
2c24 : a203                     ldx #3
2c26 : b514             tand1   lda zpAN,x
2c28 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2c2b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c2d : 48              >            pha         ;use stack to load status
2c2e : bd6b02          >            lda absANa,x    ;precharge accu
2c31 : 28              >            plp
                        
2c32 : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2c35 : 08              >            php         ;save flags
2c36 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c39 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c3b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c3c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c3e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2c41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c43 : ca                       dex
2c44 : 10e0                     bpl tand1
                            
2c46 : a203                     ldx #3      ;zp
2c48 : b514             tand2   lda zpAN,x
2c4a : 8502                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2c4c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c4e : 48              >            pha         ;use stack to load status
2c4f : bd6b02          >            lda absANa,x    ;precharge accu
2c52 : 28              >            plp
                        
2c53 : 2502                     and zpt
                                tst_ax  absrlo,absflo,0
2c55 : 08              >            php         ;save flags
2c56 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c5b : 68              >            pla         ;load status
                       >            eor_flag 0
2c5c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c5e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2c61 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c63 : ca                       dex
2c64 : 10e2                     bpl tand2
2c66 : a203                     ldx #3
2c68 : b514             tand3   lda zpAN,x
2c6a : 8502                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2c6c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c6e : 48              >            pha         ;use stack to load status
2c6f : bd6b02          >            lda absANa,x    ;precharge accu
2c72 : 28              >            plp
                        
2c73 : 2502                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2c75 : 08              >            php         ;save flags
2c76 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c79 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c7b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c7c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c7e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2c81 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c83 : ca                       dex
2c84 : 10e2                     bpl tand3
                        
2c86 : a203                     ldx #3      ;abs
2c88 : b514             tand4   lda zpAN,x
2c8a : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2c8d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c8f : 48              >            pha         ;use stack to load status
2c90 : bd6b02          >            lda absANa,x    ;precharge accu
2c93 : 28              >            plp
                        
2c94 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2c97 : 08              >            php         ;save flags
2c98 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c9b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c9d : 68              >            pla         ;load status
                       >            eor_flag 0
2c9e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ca0 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ca3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ca5 : ca                       dex
2ca6 : 10e0                     bpl tand4
2ca8 : a203                     ldx #3
2caa : b514             tand5   lda zpAN,x
2cac : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2caf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cb1 : 48              >            pha         ;use stack to load status
2cb2 : bd6b02          >            lda absANa,x    ;precharge accu
2cb5 : 28              >            plp
                        
2cb6 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2cb9 : 08              >            php         ;save flags
2cba : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2cbd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2cbf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cc0 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2cc2 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2cc5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2cc7 : ca                       dex
2cc8 : 1002                     bpl tand6
                        
2cca : a203                     ldx #3      ;zp,x
2ccc :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2ccc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cce : 48              >            pha         ;use stack to load status
2ccf : bd6b02          >            lda absANa,x    ;precharge accu
2cd2 : 28              >            plp
                        
2cd3 : 3514                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2cd5 : 08              >            php         ;save flags
2cd6 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2cd9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2cdb : 68              >            pla         ;load status
                       >            eor_flag 0
2cdc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2cde : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ce1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ce3 : ca                       dex
2ce4 : 10e6                     bpl tand6
2ce6 : a203                     ldx #3
2ce8 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2ce8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cea : 48              >            pha         ;use stack to load status
2ceb : bd6b02          >            lda absANa,x    ;precharge accu
2cee : 28              >            plp
                        
2cef : 3514                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2cf1 : 08              >            php         ;save flags
2cf2 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2cf5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2cf7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cf8 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2cfa : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2cfd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2cff : ca                       dex
2d00 : 10e6                     bpl tand7
                        
2d02 : a203                     ldx #3      ;abs,x
2d04 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2d04 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d06 : 48              >            pha         ;use stack to load status
2d07 : bd6b02          >            lda absANa,x    ;precharge accu
2d0a : 28              >            plp
                        
2d0b : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2d0e : 08              >            php         ;save flags
2d0f : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d12 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d14 : 68              >            pla         ;load status
                       >            eor_flag 0
2d15 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d17 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d1a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d1c : ca                       dex
2d1d : 10e5                     bpl tand8
2d1f : a203                     ldx #3
2d21 :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d21 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d23 : 48              >            pha         ;use stack to load status
2d24 : bd6b02          >            lda absANa,x    ;precharge accu
2d27 : 28              >            plp
                        
2d28 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2d2b : 08              >            php         ;save flags
2d2c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d2f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d31 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d32 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d34 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d37 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d39 : ca                       dex
2d3a : 10e5                     bpl tand9
                        
2d3c : a003                     ldy #3      ;abs,y
2d3e :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2d3e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d40 : 48              >            pha         ;use stack to load status
2d41 : b96b02          >            lda absANa,y    ;precharge accu
2d44 : 28              >            plp
                        
2d45 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2d48 : 08              >            php         ;save flags
2d49 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2d4c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d4e : 68              >            pla         ;load status
                       >            eor_flag 0
2d4f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d51 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2d54 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d56 : 88                       dey
2d57 : 10e5                     bpl tand10
2d59 : a003                     ldy #3
2d5b :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2d5b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d5d : 48              >            pha         ;use stack to load status
2d5e : b96b02          >            lda absANa,y    ;precharge accu
2d61 : 28              >            plp
                        
2d62 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2d65 : 08              >            php         ;save flags
2d66 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2d69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d6b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d6c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d6e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2d71 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d73 : 88                       dey
2d74 : 10e5                     bpl tand11
                        
2d76 : a206                     ldx #6      ;(zp,x)
2d78 : a003                     ldy #3
2d7a :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2d7a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d7c : 48              >            pha         ;use stack to load status
2d7d : b96b02          >            lda absANa,y    ;precharge accu
2d80 : 28              >            plp
                        
2d81 : 2132                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2d83 : 08              >            php         ;save flags
2d84 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2d87 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d89 : 68              >            pla         ;load status
                       >            eor_flag 0
2d8a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d8c : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2d8f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d91 : ca                       dex
2d92 : ca                       dex
2d93 : 88                       dey
2d94 : 10e4                     bpl tand12
2d96 : a206                     ldx #6
2d98 : a003                     ldy #3
2d9a :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2d9a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d9c : 48              >            pha         ;use stack to load status
2d9d : b96b02          >            lda absANa,y    ;precharge accu
2da0 : 28              >            plp
                        
2da1 : 2132                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2da3 : 08              >            php         ;save flags
2da4 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2da7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2da9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2daa : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2dac : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2daf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2db1 : ca                       dex
2db2 : ca                       dex
2db3 : 88                       dey
2db4 : 10e4                     bpl tand13
                        
2db6 : a003                     ldy #3      ;(zp),y
2db8 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2db8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2dba : 48              >            pha         ;use stack to load status
2dbb : b96b02          >            lda absANa,y    ;precharge accu
2dbe : 28              >            plp
                        
2dbf : 3132                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2dc1 : 08              >            php         ;save flags
2dc2 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2dc5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2dc7 : 68              >            pla         ;load status
                       >            eor_flag 0
2dc8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2dca : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2dcd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2dcf : 88                       dey
2dd0 : 10e6                     bpl tand14
2dd2 : a003                     ldy #3
2dd4 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2dd4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2dd6 : 48              >            pha         ;use stack to load status
2dd7 : b96b02          >            lda absANa,y    ;precharge accu
2dda : 28              >            plp
                        
2ddb : 3132                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2ddd : 08              >            php         ;save flags
2dde : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2de1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2de3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2de4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2de6 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2de9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2deb : 88                       dey
2dec : 10e6                     bpl tand15
                                next_test
2dee : ad0002          >            lda test_case   ;previous test
2df1 : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2df3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2df5 : a927            >            lda #test_num   ;*** next tests' number
2df7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2dfa : a203                     ldx #3          ;immediate - self modifying code
2dfc : b518             teor    lda zpEO,x
2dfe : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
2e01 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e03 : 48              >            pha         ;use stack to load status
2e04 : bd6f02          >            lda absEOa,x    ;precharge accu
2e07 : 28              >            plp
                        
2e08 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
2e0b : 08              >            php         ;save flags
2e0c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e0f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e11 : 68              >            pla         ;load status
                       >            eor_flag 0
2e12 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e14 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e17 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e19 : ca                       dex
2e1a : 10e0                     bpl teor
2e1c : a203                     ldx #3
2e1e : b518             teor1   lda zpEO,x
2e20 : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2e23 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e25 : 48              >            pha         ;use stack to load status
2e26 : bd6f02          >            lda absEOa,x    ;precharge accu
2e29 : 28              >            plp
                        
2e2a : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2e2d : 08              >            php         ;save flags
2e2e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e33 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e34 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e36 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e39 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e3b : ca                       dex
2e3c : 10e0                     bpl teor1
                            
2e3e : a203                     ldx #3      ;zp
2e40 : b518             teor2    lda zpEO,x
2e42 : 8502                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2e44 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e46 : 48              >            pha         ;use stack to load status
2e47 : bd6f02          >            lda absEOa,x    ;precharge accu
2e4a : 28              >            plp
                        
2e4b : 4502                     eor zpt
                                tst_ax  absrlo,absflo,0
2e4d : 08              >            php         ;save flags
2e4e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e51 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e53 : 68              >            pla         ;load status
                       >            eor_flag 0
2e54 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e56 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e5b : ca                       dex
2e5c : 10e2                     bpl teor2
2e5e : a203                     ldx #3
2e60 : b518             teor3   lda zpEO,x
2e62 : 8502                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2e64 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e66 : 48              >            pha         ;use stack to load status
2e67 : bd6f02          >            lda absEOa,x    ;precharge accu
2e6a : 28              >            plp
                        
2e6b : 4502                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2e6d : 08              >            php         ;save flags
2e6e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e71 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e73 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e74 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e76 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e79 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e7b : ca                       dex
2e7c : 10e2                     bpl teor3
                        
2e7e : a203                     ldx #3      ;abs
2e80 : b518             teor4   lda zpEO,x
2e82 : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2e85 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e87 : 48              >            pha         ;use stack to load status
2e88 : bd6f02          >            lda absEOa,x    ;precharge accu
2e8b : 28              >            plp
                        
2e8c : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2e8f : 08              >            php         ;save flags
2e90 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e95 : 68              >            pla         ;load status
                       >            eor_flag 0
2e96 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e98 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e9b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e9d : ca                       dex
2e9e : 10e0                     bpl teor4
2ea0 : a203                     ldx #3
2ea2 : b518             teor5   lda zpEO,x
2ea4 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2ea7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ea9 : 48              >            pha         ;use stack to load status
2eaa : bd6f02          >            lda absEOa,x    ;precharge accu
2ead : 28              >            plp
                        
2eae : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2eb1 : 08              >            php         ;save flags
2eb2 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2eb5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2eb7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2eb8 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2eba : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ebd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ebf : ca                       dex
2ec0 : 1002                     bpl teor6
                        
2ec2 : a203                     ldx #3      ;zp,x
2ec4 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
2ec4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ec6 : 48              >            pha         ;use stack to load status
2ec7 : bd6f02          >            lda absEOa,x    ;precharge accu
2eca : 28              >            plp
                        
2ecb : 5518                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
2ecd : 08              >            php         ;save flags
2ece : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ed1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2ed3 : 68              >            pla         ;load status
                       >            eor_flag 0
2ed4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ed6 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ed9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2edb : ca                       dex
2edc : 10e6                     bpl teor6
2ede : a203                     ldx #3
2ee0 :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2ee0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ee2 : 48              >            pha         ;use stack to load status
2ee3 : bd6f02          >            lda absEOa,x    ;precharge accu
2ee6 : 28              >            plp
                        
2ee7 : 5518                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2ee9 : 08              >            php         ;save flags
2eea : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2eed : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2eef : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ef0 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ef2 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ef5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ef7 : ca                       dex
2ef8 : 10e6                     bpl teor7
                        
2efa : a203                     ldx #3      ;abs,x
2efc :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
2efc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2efe : 48              >            pha         ;use stack to load status
2eff : bd6f02          >            lda absEOa,x    ;precharge accu
2f02 : 28              >            plp
                        
2f03 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
2f06 : 08              >            php         ;save flags
2f07 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f0a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f0c : 68              >            pla         ;load status
                       >            eor_flag 0
2f0d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f0f : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f12 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f14 : ca                       dex
2f15 : 10e5                     bpl teor8
2f17 : a203                     ldx #3
2f19 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f19 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f1b : 48              >            pha         ;use stack to load status
2f1c : bd6f02          >            lda absEOa,x    ;precharge accu
2f1f : 28              >            plp
                        
2f20 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2f23 : 08              >            php         ;save flags
2f24 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f27 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f29 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f2a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f2c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f2f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f31 : ca                       dex
2f32 : 10e5                     bpl teor9
                        
2f34 : a003                     ldy #3      ;abs,y
2f36 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
2f36 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f38 : 48              >            pha         ;use stack to load status
2f39 : b96f02          >            lda absEOa,y    ;precharge accu
2f3c : 28              >            plp
                        
2f3d : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
2f40 : 08              >            php         ;save flags
2f41 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f44 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f46 : 68              >            pla         ;load status
                       >            eor_flag 0
2f47 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f49 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f4c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f4e : 88                       dey
2f4f : 10e5                     bpl teor10
2f51 : a003                     ldy #3
2f53 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
2f53 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f55 : 48              >            pha         ;use stack to load status
2f56 : b96f02          >            lda absEOa,y    ;precharge accu
2f59 : 28              >            plp
                        
2f5a : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
2f5d : 08              >            php         ;save flags
2f5e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f61 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f63 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f64 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f66 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f6b : 88                       dey
2f6c : 10e5                     bpl teor11
                        
2f6e : a206                     ldx #6      ;(zp,x)
2f70 : a003                     ldy #3
2f72 :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
2f72 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f74 : 48              >            pha         ;use stack to load status
2f75 : b96f02          >            lda absEOa,y    ;precharge accu
2f78 : 28              >            plp
                        
2f79 : 413a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
2f7b : 08              >            php         ;save flags
2f7c : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f81 : 68              >            pla         ;load status
                       >            eor_flag 0
2f82 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f84 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f87 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f89 : ca                       dex
2f8a : ca                       dex
2f8b : 88                       dey
2f8c : 10e4                     bpl teor12
2f8e : a206                     ldx #6
2f90 : a003                     ldy #3
2f92 :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
2f92 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f94 : 48              >            pha         ;use stack to load status
2f95 : b96f02          >            lda absEOa,y    ;precharge accu
2f98 : 28              >            plp
                        
2f99 : 413a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2f9b : 08              >            php         ;save flags
2f9c : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f9f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2fa1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fa2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fa4 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2fa7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2fa9 : ca                       dex
2faa : ca                       dex
2fab : 88                       dey
2fac : 10e4                     bpl teor13
                        
2fae : a003                     ldy #3      ;(zp),y
2fb0 :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
2fb0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fb2 : 48              >            pha         ;use stack to load status
2fb3 : b96f02          >            lda absEOa,y    ;precharge accu
2fb6 : 28              >            plp
                        
2fb7 : 513a                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
2fb9 : 08              >            php         ;save flags
2fba : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2fbd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2fbf : 68              >            pla         ;load status
                       >            eor_flag 0
2fc0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fc2 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2fc5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2fc7 : 88                       dey
2fc8 : 10e6                     bpl teor14
2fca : a003                     ldy #3
2fcc :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
2fcc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fce : 48              >            pha         ;use stack to load status
2fcf : b96f02          >            lda absEOa,y    ;precharge accu
2fd2 : 28              >            plp
                        
2fd3 : 513a                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
2fd5 : 08              >            php         ;save flags
2fd6 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2fd9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2fdb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fdc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fde : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2fe1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2fe3 : 88                       dey
2fe4 : 10e6                     bpl teor15
                                next_test
2fe6 : ad0002          >            lda test_case   ;previous test
2fe9 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2feb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
2fed : a928            >            lda #test_num   ;*** next tests' number
2fef : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
2ff2 : a203                     ldx #3          ;immediate - self modifying code
2ff4 : b510             tora    lda zpOR,x
2ff6 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
2ff9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ffb : 48              >            pha         ;use stack to load status
2ffc : bd6702          >            lda absORa,x    ;precharge accu
2fff : 28              >            plp
                        
3000 : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
3003 : 08              >            php         ;save flags
3004 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3007 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3009 : 68              >            pla         ;load status
                       >            eor_flag 0
300a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
300c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
300f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3011 : ca                       dex
3012 : 10e0                     bpl tora
3014 : a203                     ldx #3
3016 : b510             tora1   lda zpOR,x
3018 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
301b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
301d : 48              >            pha         ;use stack to load status
301e : bd6702          >            lda absORa,x    ;precharge accu
3021 : 28              >            plp
                        
3022 : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3025 : 08              >            php         ;save flags
3026 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3029 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
302b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
302c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
302e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3031 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3033 : ca                       dex
3034 : 10e0                     bpl tora1
                            
3036 : a203                     ldx #3      ;zp
3038 : b510             tora2   lda zpOR,x
303a : 8502                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
303c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
303e : 48              >            pha         ;use stack to load status
303f : bd6702          >            lda absORa,x    ;precharge accu
3042 : 28              >            plp
                        
3043 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,0
3045 : 08              >            php         ;save flags
3046 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3049 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
304b : 68              >            pla         ;load status
                       >            eor_flag 0
304c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
304e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3051 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3053 : ca                       dex
3054 : 10e2                     bpl tora2
3056 : a203                     ldx #3
3058 : b510             tora3   lda zpOR,x
305a : 8502                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
305c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
305e : 48              >            pha         ;use stack to load status
305f : bd6702          >            lda absORa,x    ;precharge accu
3062 : 28              >            plp
                        
3063 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
3065 : 08              >            php         ;save flags
3066 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3069 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
306b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
306c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
306e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3071 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3073 : ca                       dex
3074 : 10e2                     bpl tora3
                        
3076 : a203                     ldx #3      ;abs
3078 : b510             tora4   lda zpOR,x
307a : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
307d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
307f : 48              >            pha         ;use stack to load status
3080 : bd6702          >            lda absORa,x    ;precharge accu
3083 : 28              >            plp
                        
3084 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
3087 : 08              >            php         ;save flags
3088 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
308b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
308d : 68              >            pla         ;load status
                       >            eor_flag 0
308e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3090 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3093 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3095 : ca                       dex
3096 : 10e0                     bpl tora4
3098 : a203                     ldx #3
309a : b510             tora5   lda zpOR,x
309c : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
309f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30a1 : 48              >            pha         ;use stack to load status
30a2 : bd6702          >            lda absORa,x    ;precharge accu
30a5 : 28              >            plp
                        
30a6 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
30a9 : 08              >            php         ;save flags
30aa : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30ad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
30af : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30b0 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30b2 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
30b7 : ca                       dex
30b8 : 1002                     bpl tora6
                        
30ba : a203                     ldx #3      ;zp,x
30bc :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
30bc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30be : 48              >            pha         ;use stack to load status
30bf : bd6702          >            lda absORa,x    ;precharge accu
30c2 : 28              >            plp
                        
30c3 : 1510                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
30c5 : 08              >            php         ;save flags
30c6 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30c9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
30cb : 68              >            pla         ;load status
                       >            eor_flag 0
30cc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30ce : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30d1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
30d3 : ca                       dex
30d4 : 10e6                     bpl tora6
30d6 : a203                     ldx #3
30d8 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
30d8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30da : 48              >            pha         ;use stack to load status
30db : bd6702          >            lda absORa,x    ;precharge accu
30de : 28              >            plp
                        
30df : 1510                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
30e1 : 08              >            php         ;save flags
30e2 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30e5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
30e7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30e8 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30ea : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30ed : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
30ef : ca                       dex
30f0 : 10e6                     bpl tora7
                        
30f2 : a203                     ldx #3      ;abs,x
30f4 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
30f4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30f6 : 48              >            pha         ;use stack to load status
30f7 : bd6702          >            lda absORa,x    ;precharge accu
30fa : 28              >            plp
                        
30fb : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
30fe : 08              >            php         ;save flags
30ff : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3102 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3104 : 68              >            pla         ;load status
                       >            eor_flag 0
3105 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3107 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
310a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
310c : ca                       dex
310d : 10e5                     bpl tora8
310f : a203                     ldx #3
3111 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
3111 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3113 : 48              >            pha         ;use stack to load status
3114 : bd6702          >            lda absORa,x    ;precharge accu
3117 : 28              >            plp
                        
3118 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
311b : 08              >            php         ;save flags
311c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
311f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3121 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3122 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3124 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3127 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3129 : ca                       dex
312a : 10e5                     bpl tora9
                        
312c : a003                     ldy #3      ;abs,y
312e :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
312e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3130 : 48              >            pha         ;use stack to load status
3131 : b96702          >            lda absORa,y    ;precharge accu
3134 : 28              >            plp
                        
3135 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
3138 : 08              >            php         ;save flags
3139 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
313c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
313e : 68              >            pla         ;load status
                       >            eor_flag 0
313f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3141 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3144 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3146 : 88                       dey
3147 : 10e5                     bpl tora10
3149 : a003                     ldy #3
314b :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
314b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
314d : 48              >            pha         ;use stack to load status
314e : b96702          >            lda absORa,y    ;precharge accu
3151 : 28              >            plp
                        
3152 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
3155 : 08              >            php         ;save flags
3156 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3159 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
315b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
315c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
315e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3161 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3163 : 88                       dey
3164 : 10e5                     bpl tora11
                        
3166 : a206                     ldx #6      ;(zp,x)
3168 : a003                     ldy #3
316a :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
316a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
316c : 48              >            pha         ;use stack to load status
316d : b96702          >            lda absORa,y    ;precharge accu
3170 : 28              >            plp
                        
3171 : 0142                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
3173 : 08              >            php         ;save flags
3174 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3177 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3179 : 68              >            pla         ;load status
                       >            eor_flag 0
317a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
317c : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
317f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3181 : ca                       dex
3182 : ca                       dex
3183 : 88                       dey
3184 : 10e4                     bpl tora12
3186 : a206                     ldx #6
3188 : a003                     ldy #3
318a :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
318a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
318c : 48              >            pha         ;use stack to load status
318d : b96702          >            lda absORa,y    ;precharge accu
3190 : 28              >            plp
                        
3191 : 0142                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3193 : 08              >            php         ;save flags
3194 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3197 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3199 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
319a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
319c : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
319f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
31a1 : ca                       dex
31a2 : ca                       dex
31a3 : 88                       dey
31a4 : 10e4                     bpl tora13
                        
31a6 : a003                     ldy #3      ;(zp),y
31a8 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
31a8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31aa : 48              >            pha         ;use stack to load status
31ab : b96702          >            lda absORa,y    ;precharge accu
31ae : 28              >            plp
                        
31af : 1142                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
31b1 : 08              >            php         ;save flags
31b2 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
31b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
31b7 : 68              >            pla         ;load status
                       >            eor_flag 0
31b8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31ba : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
31bd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
31bf : 88                       dey
31c0 : 10e6                     bpl tora14
31c2 : a003                     ldy #3
31c4 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
31c4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31c6 : 48              >            pha         ;use stack to load status
31c7 : b96702          >            lda absORa,y    ;precharge accu
31ca : 28              >            plp
                        
31cb : 1142                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
31cd : 08              >            php         ;save flags
31ce : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
31d1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
31d3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31d4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31d6 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
31d9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
31db : 88                       dey
31dc : 10e6                     bpl tora15
                            if I_flag = 3
31de : 58                       cli
                            endif                
                                next_test
31df : ad0002          >            lda test_case   ;previous test
31e2 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
31e4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
31e6 : a929            >            lda #test_num   ;*** next tests' number
31e8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
31eb : d8                       cld
31ec : a204                     ldx #ad2        ;for indexed test
31ee : a0ff                     ldy #$ff        ;max range
31f0 : a900                     lda #0          ;start with adding zeroes & no carry
31f2 : 8502                     sta adfc        ;carry in - for diag
31f4 : 8503                     sta ad1         ;operand 1 - accumulator
31f6 : 8504                     sta ad2         ;operand 2 - memory or immediate
31f8 : 8d0302                   sta ada2        ;non zp
31fb : 8505                     sta adrl        ;expected result bits 0-7
31fd : 8506                     sta adrh        ;expected result bit 8 (carry out)
31ff : a9ff                     lda #$ff        ;complemented operand 2 for subtract
3201 : 8508                     sta sb2
3203 : 8d0402                   sta sba2        ;non zp
3206 : a902                     lda #2          ;expected Z-flag
3208 : 8507                     sta adrf
320a : 18               tadd    clc             ;test with carry clear
320b : 205632                   jsr chkadd
320e : e602                     inc adfc        ;now with carry
3210 : e605                     inc adrl        ;result +1
3212 : 08                       php             ;save N & Z from low result
3213 : 08                       php
3214 : 68                       pla             ;accu holds expected flags
3215 : 2982                     and #$82        ;mask N & Z
3217 : 28                       plp
3218 : d002                     bne tadd1
321a : e606                     inc adrh        ;result bit 8 - carry
321c : 0506             tadd1   ora adrh        ;merge C to expected flags
321e : 8507                     sta adrf        ;save expected flags except overflow
3220 : 38                       sec             ;test with carry set
3221 : 205632                   jsr chkadd
3224 : c602                     dec adfc        ;same for operand +1 but no carry
3226 : e603                     inc ad1
3228 : d0e0                     bne tadd        ;iterate op1
322a : a900                     lda #0          ;preset result to op2 when op1 = 0
322c : 8506                     sta adrh
322e : ee0302                   inc ada2
3231 : e604                     inc ad2
3233 : 08                       php             ;save NZ as operand 2 becomes the new result
3234 : 68                       pla
3235 : 2982                     and #$82        ;mask N00000Z0
3237 : 8507                     sta adrf        ;no need to check carry as we are adding to 0
3239 : c608                     dec sb2         ;complement subtract operand 2
323b : ce0402                   dec sba2
323e : a504                     lda ad2         
3240 : 8505                     sta adrl
3242 : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
3244 : ad0002                   lda test_case
3247 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
3249 : d0fe            >        bne *         ;failed not equal (non zero)
                        
324b : a9f0                     lda #$f0        ;mark opcode testing complete
324d : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
3250 : 4c5032          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
3253 : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3256 : a507             chkadd  lda adrf        ;add V-flag if overflow
3258 : 2983                     and #$83        ;keep N-----ZC / clear V
325a : 48                       pha
325b : a503                     lda ad1         ;test sign unequal between operands
325d : 4504                     eor ad2
325f : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
3261 : a503                     lda ad1         ;test sign equal between operands and result
3263 : 4505                     eor adrl
3265 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
3267 : 68                       pla
3268 : 0940                     ora #$40        ;set V
326a : 48                       pha
326b : 68               ckad1   pla
326c : 8507                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
326e : 08                       php             ;save carry for subtract
326f : a503                     lda ad1
3271 : 6504                     adc ad2         ;perform add
3273 : 08                       php          
3274 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3276 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3278 : 68                       pla             ;check flags
3279 : 29c3                     and #$c3        ;mask NV----ZC
327b : c507                     cmp adrf
                                trap_ne         ;bad flags
327d : d0fe            >        bne *         ;failed not equal (non zero)
                        
327f : 28                       plp
3280 : 08                       php             ;save carry for next add
3281 : a503                     lda ad1
3283 : e508                     sbc sb2         ;perform subtract
3285 : 08                       php          
3286 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3288 : d0fe            >        bne *         ;failed not equal (non zero)
                        
328a : 68                       pla             ;check flags
328b : 29c3                     and #$c3        ;mask NV----ZC
328d : c507                     cmp adrf
                                trap_ne         ;bad flags
328f : d0fe            >        bne *         ;failed not equal (non zero)
                        
3291 : 28                       plp
                        ; binary ADC / SBC abs
3292 : 08                       php             ;save carry for subtract
3293 : a503                     lda ad1
3295 : 6d0302                   adc ada2        ;perform add
3298 : 08                       php          
3299 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
329b : d0fe            >        bne *         ;failed not equal (non zero)
                        
329d : 68                       pla             ;check flags
329e : 29c3                     and #$c3        ;mask NV----ZC
32a0 : c507                     cmp adrf
                                trap_ne         ;bad flags
32a2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32a4 : 28                       plp
32a5 : 08                       php             ;save carry for next add
32a6 : a503                     lda ad1
32a8 : ed0402                   sbc sba2        ;perform subtract
32ab : 08                       php          
32ac : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
32b0 : 68                       pla             ;check flags
32b1 : 29c3                     and #$c3        ;mask NV----ZC
32b3 : c507                     cmp adrf
                                trap_ne         ;bad flags
32b5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32b7 : 28                       plp
                        ; binary ADC / SBC #
32b8 : 08                       php             ;save carry for subtract
32b9 : a504                     lda ad2
32bb : 8d1302                   sta ex_adci+1   ;set ADC # operand
32be : a503                     lda ad1
32c0 : 201202                   jsr ex_adci     ;execute ADC # in RAM
32c3 : 08                       php          
32c4 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32c6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32c8 : 68                       pla             ;check flags
32c9 : 29c3                     and #$c3        ;mask NV----ZC
32cb : c507                     cmp adrf
                                trap_ne         ;bad flags
32cd : d0fe            >        bne *         ;failed not equal (non zero)
                        
32cf : 28                       plp
32d0 : 08                       php             ;save carry for next add
32d1 : a508                     lda sb2
32d3 : 8d1602                   sta ex_sbci+1   ;set SBC # operand
32d6 : a503                     lda ad1
32d8 : 201502                   jsr ex_sbci     ;execute SBC # in RAM
32db : 08                       php          
32dc : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32de : d0fe            >        bne *         ;failed not equal (non zero)
                        
32e0 : 68                       pla             ;check flags
32e1 : 29c3                     and #$c3        ;mask NV----ZC
32e3 : c507                     cmp adrf
                                trap_ne         ;bad flags
32e5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32e7 : 28                       plp
                        ; binary ADC / SBC zp,x
32e8 : 08                       php             ;save carry for subtract
32e9 : a503                     lda ad1
32eb : 7500                     adc 0,x         ;perform add
32ed : 08                       php          
32ee : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32f0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32f2 : 68                       pla             ;check flags
32f3 : 29c3                     and #$c3        ;mask NV----ZC
32f5 : c507                     cmp adrf
                                trap_ne         ;bad flags
32f7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32f9 : 28                       plp
32fa : 08                       php             ;save carry for next add
32fb : a503                     lda ad1
32fd : f504                     sbc sb2-ad2,x   ;perform subtract
32ff : 08                       php          
3300 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3302 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3304 : 68                       pla             ;check flags
3305 : 29c3                     and #$c3        ;mask NV----ZC
3307 : c507                     cmp adrf
                                trap_ne         ;bad flags
3309 : d0fe            >        bne *         ;failed not equal (non zero)
                        
330b : 28                       plp
                        ; binary ADC / SBC abs,x
330c : 08                       php             ;save carry for subtract
330d : a503                     lda ad1
330f : 7dff01                   adc ada2-ad2,x  ;perform add
3312 : 08                       php          
3313 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3315 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3317 : 68                       pla             ;check flags
3318 : 29c3                     and #$c3        ;mask NV----ZC
331a : c507                     cmp adrf
                                trap_ne         ;bad flags
331c : d0fe            >        bne *         ;failed not equal (non zero)
                        
331e : 28                       plp
331f : 08                       php             ;save carry for next add
3320 : a503                     lda ad1
3322 : fd0002                   sbc sba2-ad2,x  ;perform subtract
3325 : 08                       php          
3326 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3328 : d0fe            >        bne *         ;failed not equal (non zero)
                        
332a : 68                       pla             ;check flags
332b : 29c3                     and #$c3        ;mask NV----ZC
332d : c507                     cmp adrf
                                trap_ne         ;bad flags
332f : d0fe            >        bne *         ;failed not equal (non zero)
                        
3331 : 28                       plp
                        ; binary ADC / SBC abs,y
3332 : 08                       php             ;save carry for subtract
3333 : a503                     lda ad1
3335 : 790401                   adc ada2-$ff,y  ;perform add
3338 : 08                       php          
3339 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
333b : d0fe            >        bne *         ;failed not equal (non zero)
                        
333d : 68                       pla             ;check flags
333e : 29c3                     and #$c3        ;mask NV----ZC
3340 : c507                     cmp adrf
                                trap_ne         ;bad flags
3342 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3344 : 28                       plp
3345 : 08                       php             ;save carry for next add
3346 : a503                     lda ad1
3348 : f90501                   sbc sba2-$ff,y  ;perform subtract
334b : 08                       php          
334c : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
334e : d0fe            >        bne *         ;failed not equal (non zero)
                        
3350 : 68                       pla             ;check flags
3351 : 29c3                     and #$c3        ;mask NV----ZC
3353 : c507                     cmp adrf
                                trap_ne         ;bad flags
3355 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3357 : 28                       plp
                        ; binary ADC / SBC (zp,x)
3358 : 08                       php             ;save carry for subtract
3359 : a503                     lda ad1
335b : 6146                     adc (lo adi2-ad2,x) ;perform add
335d : 08                       php          
335e : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3360 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3362 : 68                       pla             ;check flags
3363 : 29c3                     and #$c3        ;mask NV----ZC
3365 : c507                     cmp adrf
                                trap_ne         ;bad flags
3367 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3369 : 28                       plp
336a : 08                       php             ;save carry for next add
336b : a503                     lda ad1
336d : e148                     sbc (lo sbi2-ad2,x) ;perform subtract
336f : 08                       php          
3370 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3372 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3374 : 68                       pla             ;check flags
3375 : 29c3                     and #$c3        ;mask NV----ZC
3377 : c507                     cmp adrf
                                trap_ne         ;bad flags
3379 : d0fe            >        bne *         ;failed not equal (non zero)
                        
337b : 28                       plp
                        ; binary ADC / SBC (abs),y
337c : 08                       php             ;save carry for subtract
337d : a503                     lda ad1
337f : 714e                     adc (adiy2),y   ;perform add
3381 : 08                       php          
3382 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3384 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3386 : 68                       pla             ;check flags
3387 : 29c3                     and #$c3        ;mask NV----ZC
3389 : c507                     cmp adrf
                                trap_ne         ;bad flags
338b : d0fe            >        bne *         ;failed not equal (non zero)
                        
338d : 28                       plp
338e : 08                       php             ;save carry for next add
338f : a503                     lda ad1
3391 : f150                     sbc (sbiy2),y   ;perform subtract
3393 : 08                       php          
3394 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3396 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3398 : 68                       pla             ;check flags
3399 : 29c3                     and #$c3        ;mask NV----ZC
339b : c507                     cmp adrf
                                trap_ne         ;bad flags
339d : d0fe            >        bne *         ;failed not equal (non zero)
                        
339f : 28                       plp
33a0 : 60                       rts
                        
                        ; target for the jump absolute test
33a1 : 88                       dey
33a2 : 88                       dey
33a3 :                  test_far
33a3 : 08                       php             ;either SP or Y count will fail, if we do not hit
33a4 : 88                       dey
33a5 : 88                       dey
33a6 : 88                       dey
33a7 : 28                       plp
                                trap_cs         ;flags loaded?
33a8 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
33aa : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
33ac : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
33ae : f0fe            >        beq *           ;failed equal (zero)
                        
33b0 : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
33b2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
33b4 : e041                     cpx #'A'
                                trap_ne        
33b6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
33b8 : c04f                     cpy #('R'-3)
                                trap_ne
33ba : d0fe            >        bne *         ;failed not equal (non zero)
                        
33bc : 48                       pha             ;save a,x
33bd : 8a                       txa
33be : 48                       pha
33bf : ba                       tsx
33c0 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
33c2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
33c4 : 68                       pla             ;restore x
33c5 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
33c6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
33c8 : 48              >            pha         ;use stack to load status
33c9 : 28              >            plp
                        
33ca : 68                       pla             ;restore a
33cb : e8                       inx             ;return registers with modifications
33cc : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
33ce : 4cf207                   jmp far_ret
                                
                        ; target for the jump indirect test
33d1 : 00                       align
33d2 : db33             ptr_tst_ind dw test_ind
33d4 : 4708             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
33d6 : 4cd633          >        jmp *           ;failed anyway
                        
33d9 : 88                       dey
33da : 88                       dey
33db :                  test_ind
33db : 08                       php             ;either SP or Y count will fail, if we do not hit
33dc : 88                       dey
33dd : 88                       dey
33de : 88                       dey
33df : 28                       plp
                                trap_cs         ;flags loaded?
33e0 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
33e2 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
33e4 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
33e6 : f0fe            >        beq *           ;failed equal (zero)
                        
33e8 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
33ea : d0fe            >        bne *         ;failed not equal (non zero)
                        
33ec : e04e                     cpx #'N'
                                trap_ne        
33ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
33f0 : c041                     cpy #('D'-3)
                                trap_ne
33f2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
33f4 : 48                       pha             ;save a,x
33f5 : 8a                       txa
33f6 : 48                       pha
33f7 : ba                       tsx
33f8 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
33fa : d0fe            >        bne *         ;failed not equal (non zero)
                        
33fc : 68                       pla             ;restore x
33fd : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
33fe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3400 : 48              >            pha         ;use stack to load status
3401 : 28              >            plp
                        
3402 : 68                       pla             ;restore a
3403 : e8                       inx             ;return registers with modifications
3404 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3406 : 6cd433                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3409 : 4c0934          >        jmp *           ;failed anyway
                        
340c : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
340f : 88                       dey
3410 : 88                       dey
3411 :                  test_jsr
3411 : 08                       php             ;either SP or Y count will fail, if we do not hit
3412 : 88                       dey
3413 : 88                       dey
3414 : 88                       dey
3415 : 28                       plp
                                trap_cs         ;flags loaded?
3416 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3418 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
341a : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
341c : f0fe            >        beq *           ;failed equal (zero)
                        
341e : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
3420 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3422 : e053                     cpx #'S'
                                trap_ne        
3424 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3426 : c04f                     cpy #('R'-3)
                                trap_ne
3428 : d0fe            >        bne *         ;failed not equal (non zero)
                        
342a : 48                       pha             ;save a,x
342b : 8a                       txa
342c : 48                       pha       
342d : ba                       tsx             ;sp -4? (return addr,a,x)
342e : e0fb                     cpx #$fb
                                trap_ne
3430 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3432 : adff01                   lda $1ff        ;propper return on stack
3435 : c908                     cmp #hi(jsr_ret)
                                trap_ne
3437 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3439 : adfe01                   lda $1fe
343c : c97e                     cmp #lo(jsr_ret)
                                trap_ne
343e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
3440 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3442 : 48              >            pha         ;use stack to load status
3443 : 28              >            plp
                        
3444 : 68                       pla             ;pull x,a
3445 : aa                       tax
3446 : 68                       pla
3447 : e8                       inx             ;return registers with modifications
3448 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
344a : 60                       rts
                                trap            ;runover protection
344b : 4c4b34          >        jmp *           ;failed anyway
                        
344e : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
3451 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
3451 : 4c5134          >        jmp *           ;failed anyway
                        
3454 : 4c0004                   jmp start       ;catastrophic error - cannot continue
3457 :                  res_trap
                                trap            ;unexpected RESET
3457 : 4c5734          >        jmp *           ;failed anyway
                        
345a : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
345d : 88                       dey
345e : 88                       dey
345f :                  irq_trap                ;BRK test or unextpected BRK or IRQ
345f : 08                       php             ;either SP or Y count will fail, if we do not hit
3460 : 88                       dey
3461 : 88                       dey
3462 : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
3463 : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
3465 : f042                     beq break2
3467 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
3469 : d0fe            >        bne *         ;failed not equal (non zero)
                        
346b : e052                     cpx #'R'
                                trap_ne        
346d : d0fe            >        bne *         ;failed not equal (non zero)
                        
346f : c048                     cpy #'K'-3
                                trap_ne
3471 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3473 : 8500                     sta irq_a       ;save registers during break test
3475 : 8601                     stx irq_x
3477 : ba                       tsx             ;test break on stack
3478 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
347b : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
347d : d0fe            >        bne *         ;failed not equal (non zero)
                        
347f : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
3480 : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
3482 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3484 : ba                       tsx
3485 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
3487 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3489 : adff01                   lda $1ff        ;propper return on stack
348c : c908                     cmp #hi(brk_ret0)
                                trap_ne
348e : d0fe            >        bne *         ;failed not equal (non zero)
                        
3490 : adfe01                   lda $1fe
3493 : c9b4                     cmp #lo(brk_ret0)
                                trap_ne
3495 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                load_flag $ff
3497 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
3499 : 48                       pha
349a : a601                     ldx irq_x
349c : e8                       inx             ;return registers with modifications
349d : a500                     lda irq_a
349f : 49aa                     eor #$aa
34a1 : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
34a2 : 40                       rti
                                trap            ;runover protection
34a3 : 4ca334          >        jmp *           ;failed anyway
                        
34a6 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
34a9 :                  break2                  ;BRK pass 2        
34a9 : e0ad                     cpx #$ff-'R'
                                trap_ne        
34ab : d0fe            >        bne *         ;failed not equal (non zero)
                        
34ad : c0b1                     cpy #$ff-'K'-3
                                trap_ne
34af : d0fe            >        bne *         ;failed not equal (non zero)
                        
34b1 : 8500                     sta irq_a       ;save registers during break test
34b3 : 8601                     stx irq_x
34b5 : ba                       tsx             ;test break on stack
34b6 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
34b9 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
34bb : d0fe            >        bne *         ;failed not equal (non zero)
                        
34bd : 68                       pla
34be : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
34c0 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
34c2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
34c4 : ba                       tsx
34c5 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
34c7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
34c9 : adff01                   lda $1ff        ;propper return on stack
34cc : c908                     cmp #hi(brk_ret1)
                                trap_ne
34ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
34d0 : adfe01                   lda $1fe
34d3 : c9da                     cmp #lo(brk_ret1)
                                trap_ne
34d5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                load_flag intdis
34d7 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
34d9 : 48                       pha      
34da : a601                     ldx irq_x
34dc : e8                       inx             ;return registers with modifications
34dd : a500                     lda irq_a
34df : 49aa                     eor #$aa
34e1 : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
34e2 : 40                       rti
                                trap            ;runover protection
34e3 : 4ce334          >        jmp *           ;failed anyway
                        
34e6 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
34e9 :                  zp_init
34e9 : 8001             zps_    db  $80,1           ;additional shift pattern to test zero result & flag
34eb : c3824100         zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
34ef : 7f               zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
34f0 : 001f7180         zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
34f4 : 0fff7f80         zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
34f8 : ff0f8f8f         zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
34fc : 1802             ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
34fe : 1902                     dw  abs1+1
3500 : 1a02                     dw  abs1+2
3502 : 1b02                     dw  abs1+3
3504 : 1c02                     dw  abs7f
3506 : 2001             inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
3508 : 0302             indt_   dw  abst            ;indirect pointer to store area in absolute memory
350a : 0402                     dw  abst+1
350c : 0502                     dw  abst+2
350e : 0602                     dw  abst+3
3510 : 0b01             inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
3512 : 5f02             indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
3514 : 6002                     dw  absAN+1
3516 : 6102                     dw  absAN+2
3518 : 6202                     dw  absAN+3
351a : 6302             indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
351c : 6402                     dw  absEO+1
351e : 6502                     dw  absEO+2
3520 : 6602                     dw  absEO+3
3522 : 5b02             indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
3524 : 5c02                     dw  absOR+1
3526 : 5d02                     dw  absOR+2
3528 : 5e02                     dw  absOR+3
                        ;add/subtract indirect pointers
352a : 0302             adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
352c : 0402             sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
352e : 0401             adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
3530 : 0501             sbiy2_  dw  sba2-$ff
3532 :                  zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
3532 :                  data_init
3532 : 2900             ex_and_ and #0              ;execute immediate opcodes
3534 : 60                       rts
3535 : 4900             ex_eor_ eor #0              ;execute immediate opcodes
3537 : 60                       rts
3538 : 0900             ex_ora_ ora #0              ;execute immediate opcodes
353a : 60                       rts
353b : 6900             ex_adc_ adc #0              ;execute immediate opcodes
353d : 60                       rts
353e : e900             ex_sbc_ sbc #0              ;execute immediate opcodes
3540 : 60                       rts
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
3541 : c3824100         abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
3545 : 7f               abs7f_  db  $7f             ;test pattern for compare
                        ;loads
3546 : 80800002         fLDx_   db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
354a :                  rASL_                               ;expected result ASL & ROL -carry
354a : 000286048200     rROL_   db  0,2,$86,$04,$82,0
3550 : 010387058301     rROLc_  db  1,3,$87,$05,$83,1       ;expected result ROL +carry
3556 :                  rLSR_                               ;expected result LSR & ROR -carry
3556 : 400061412000     rROR_   db  $40,0,$61,$41,$20,0
355c : c080e1c1a080     rRORc_  db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
3562 :                  fASL_                               ;expected flags for shifts
3562 : 030081018002     fROL_   db  fzc,0,fnc,fc,fn,fz      ;no carry in
3568 : 010081018000     fROLc_  db  fc,0,fnc,fc,fn,0        ;carry in 
356e :                  fLSR_
356e : 000301000102     fROR_   db  0,fzc,fc,0,fc,fz        ;no carry in
3574 : 808181808180     fRORc_  db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
357a : 7f80ff0001       rINC_   db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
357f : 0080800200       fINC_   db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
3584 : 001f7180         absOR_  db  0,$1f,$71,$80           ;test pattern for OR
3588 : 0fff7f80         absAN_  db  $0f,$ff,$7f,$80         ;test pattern for AND
358c : ff0f8f8f         absEO_  db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
3590 : 00f11f00         absORa_ db  0,$f1,$1f,0             ;test pattern for OR
3594 : f0ffffff         absANa_ db  $f0,$ff,$ff,$ff         ;test pattern for AND
3598 : fff0f00f         absEOa_ db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
359c : 00ff7f80         absrlo_ db  0,$ff,$7f,$80
35a0 : 02800080         absflo_ db  fz,fn,0,fn
35a4 :                  data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
35a4 :                  vec_init
35a4 : 5134                     dw  nmi_trap
35a6 : 5734                     dw  res_trap
35a8 : 5f34                     dw  irq_trap
fffa =                  vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
                                org $fffa       ;vectors
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0400 through $35a9.
Total size 12714 bytes.
Program start address is at $0400 (1024).
