AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
-------------------------------------------------------- func_test_1.a65 ---------------------------------------------------------

6114 lines read, no errors in pass 1.
                        
                        
                        ;as65.exe -l ../func_test_1.a65 -m -h0 -l -w
                        
                        
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2020  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 05-jan-2020
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 written by Frank A. Kingswood
                        ; The assembler as65_142.zip can be obtained from my GitHub repository 
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        ;   05-jan-2020  fixed shifts not testing zero result and flag when last 1-bit
                        ;                is shifted out
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $52 (82) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
0000 =                  zero_page = $0  
                        
                        ;data_segment memory start address, $7B (123) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13.1kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0001 =                  disable_selfmod = 1
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0001 =                  disable_decimal = 1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                        		endm
                        trap_ne macro
                                bne *         ;failed not equal (non zero)
                        		endm
                        trap_cs macro
                                bcs *           ;failed carry set
                        		endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                        		endm
                        trap_mi macro
                                bmi *         ;failed minus (bit 7 set)
                        		endm
                        trap_pl macro
                                bpl *          ;failed plus (bit 7 clear)
                        		endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                        		endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                        		endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;break test interrupt save
0000 : 00               irq_a   ds  1               ;a register
0001 : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0002 :                  zpt                         ;6 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0002 : 00               adfc    ds  1               ;carry flag before op
0003 : 00               ad1     ds  1               ;operand 1 - accumulator
0004 : 00               ad2     ds  1               ;operand 2 - memory / immediate
0005 : 00               adrl    ds  1               ;expected result bits 0-7
0006 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0007 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0008 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0009 :                  zp_bss
0009 : 8001             zps     db  $80,1           ;additional shift pattern to test zero result & flag
000b : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000f : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0010 : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0014 : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0018 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
001c : 1802             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
001e : 1902                     dw  abs1+1
0020 : 1a02                     dw  abs1+2
0022 : 1b02                     dw  abs1+3
0024 : 1c02                     dw  abs7f
0026 : 2001             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0028 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
002a : 0402                     dw  abst+1
002c : 0502                     dw  abst+2
002e : 0602                     dw  abst+3
0030 : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0032 : 5f02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0034 : 6002                     dw  absAN+1
0036 : 6102                     dw  absAN+2
0038 : 6202                     dw  absAN+3
003a : 6302             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
003c : 6402                     dw  absEO+1
003e : 6502                     dw  absEO+2
0040 : 6602                     dw  absEO+3
0042 : 5b02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0044 : 5c02                     dw  absOR+1
0046 : 5d02                     dw  absOR+2
0048 : 5e02                     dw  absOR+3
                        ;add/subtract indirect pointers
004a : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
004c : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
004e : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0050 : 0501             sbiy2   dw  sba2-$ff
0052 :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;6 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 00000000                 ds  4               ;fill remaining bytes
0209 :                  data_bss
                            if load_data_direct = 1
0209 : 2900             ex_andi and #0              ;execute immediate opcodes
020b : 60                       rts
020c : 4900             ex_eori eor #0              ;execute immediate opcodes
020e : 60                       rts
020f : 0900             ex_orai ora #0              ;execute immediate opcodes
0211 : 60                       rts
0212 : 6900             ex_adci adc #0              ;execute immediate opcodes
0214 : 60                       rts
0215 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0217 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
0218 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021c : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021d : 80800002         fLDx    db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
0221 :                  rASL                                ;expected result ASL & ROL -carry
0221 : 000286048200     rROL    db  0,2,$86,$04,$82,0
0227 : 010387058301     rROLc   db  1,3,$87,$05,$83,1       ;expected result ROL +carry
022d :                  rLSR                                ;expected result LSR & ROR -carry
022d : 400061412000     rROR    db  $40,0,$61,$41,$20,0
0233 : c080e1c1a080     rRORc   db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
0239 :                  fASL                                ;expected flags for shifts
0239 : 030081018002     fROL    db  fzc,0,fnc,fc,fn,fz      ;no carry in
023f : 010081018000     fROLc   db  fc,0,fnc,fc,fn,0        ;carry in 
0245 :                  fLSR 
0245 : 000301000102     fROR    db  0,fzc,fc,0,fc,fz        ;no carry in
024b : 808181808180     fRORc   db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
0251 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
0256 : 0080800200       fINC    db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
025b : 001f7180         absOR   db  0,$1f,$71,$80           ;test pattern for OR
025f : 0fff7f80         absAN   db  $0f,$ff,$7f,$80         ;test pattern for AND
0263 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
0267 : 00f11f00         absORa  db  0,$f1,$1f,0             ;test pattern for OR
026b : f0ffffff         absANa  db  $f0,$ff,$ff,$ff         ;test pattern for AND
026f : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
0273 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0277 : 02800080         absflo  db  fz,fn,0,fn
027b :                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
0409 : a205                     ldx #5
040b : 4c3304                   jmp psb_test
040e :                  psb_bwok
040e : a005                     ldy #5
0410 : d008                     bne psb_forw
                                trap        ;branch should be taken
0412 : 4c1204          >        jmp *           ;failed anyway
                        
0415 : 88                       dey         ;forward landing zone
0416 : 88                       dey
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a :                  psb_forw
041a : 88                       dey
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : f017                     beq psb_fwok
                                trap        ;forward offset
0421 : 4c2104          >        jmp *           ;failed anyway
                        
                        
0424 : ca                       dex         ;backward landing zone
0425 : ca                       dex
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 :                  psb_back
0429 : ca                       dex
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : f0de                     beq psb_bwok
                                trap        ;backward offset
0430 : 4c3004          >        jmp *           ;failed anyway
                        
0433 :                  psb_test
0433 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0435 : 4c3504          >        jmp *           ;failed anyway
                        
0438 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0438 : ad0002          >            lda test_case   ;previous test
043b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
043d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
043f : a901            >            lda #test_num   ;*** next tests' number
0441 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
                                ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
                        range_loop
                                dey             ;next relative address
                                tya
                                tax             ;precharge count to end of loop
                                bpl range_fw    ;calculate relative address
                                clc             ;avoid branch self or to relative address of branch
                                adc #2
                                nop             ;offset landing zone - tolerate +/-5 offset to branch
                                nop
                                nop
                                nop
                                nop
                        range_fw
                                nop
                                nop
                                nop
                                nop
                                nop
                                eor #$7f        ;complement except sign
                                sta range_adr   ;load into test target
                                lda #0          ;should set zero flag in status register
                                jmp range_op
                                
                                dex             ; offset landing zone - backward branch too far
                                dex
                                dex
                                dex
                                dex
                                ;relative address target field with branch under test in the middle
                                dex             ;-128 - max backward
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-120
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-110
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-100
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-90
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-80
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-70
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-60
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-50
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-40
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-30
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-20
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-10
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;-3
                        range_op                ;test target with zero flag=0, z=1 if previous dex
                        range_adr   = *+1       ;modifiable relative address
                                beq *+64        ;+64 if called without modification
                                dex             ;+0
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+10
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+20
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+30
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+40
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+50
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+60
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+70
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+80
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+90
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+100
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+110
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex             ;+120
                                dex
                                dex
                                dex
                                dex
                                dex
                                dex
                                nop             ;offset landing zone - forward branch too far
                                nop
                                nop
                                nop
                                nop
                                beq range_ok    ;+127 - max forward
                                trap            ; bad range
                                nop             ;offset landing zone - tolerate +/-5 offset to branch
                                nop
                                nop
                                nop
                                nop
                        range_ok
                                nop
                                nop
                                nop
                                nop
                                nop
                                cpy #0
                                beq range_end   
                                jmp range_loop
                        range_end               ;range test successful
                            endif
                                next_test
0444 : ad0002          >            lda test_case   ;previous test
0447 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0449 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
044b : a902            >            lda #test_num   ;*** next tests' number
044d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
0450 : c001                     cpy #1          ;testing BNE true
0452 : d003                     bne test_bne
                                trap 
0454 : 4c5404          >        jmp *           ;failed anyway
                        
0457 :                  test_bne
0457 : a900                     lda #0 
0459 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
045b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
045d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
045f : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
0461 : c901                     cmp #1
                                trap_eq 
0463 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0465 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0467 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
0469 : aa                       tax 
046a : e000                     cpx #0          ;test compare x immediate
                                trap_ne
046c : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
046e : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
0470 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
0472 : e001                     cpx #1
                                trap_eq 
0474 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0476 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0478 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
047a : a8                       tay 
047b : c000                     cpy #0          ;test compare y immediate
                                trap_ne
047d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                trap_cc
047f : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
0481 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
0483 : c001                     cpy #1
                                trap_eq 
0485 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
0487 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
0489 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                next_test
048b : ad0002          >            lda test_case   ;previous test
048e : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0490 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
0492 : a903            >            lda #test_num   ;*** next tests' number
0494 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
0497 : a2ff                     ldx #$ff        ;initialize stack
0499 : 9a                       txs
049a : a955                     lda #$55
049c : 48                       pha
049d : a9aa                     lda #$aa
049f : 48                       pha
04a0 : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
04a3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
04a5 : ba                       tsx
04a6 : 8a                       txa             ;overwrite accu
04a7 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
04a9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
04ab : 68                       pla
04ac : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
04ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
04b0 : 68                       pla
04b1 : c955                     cmp #$55
                                trap_ne
04b3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
04b5 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
04b8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
04ba : ba                       tsx
04bb : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
04bd : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
04bf : ad0002          >            lda test_case   ;previous test
04c2 : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
04c4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
04c6 : a904            >            lda #test_num   ;*** next tests' number
04c8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
04cb : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
04cd : 48              >            pha         ;use stack to load status
04ce : 28              >            plp
                        
04cf : 101a                     bpl nbr1        ;branches should not be taken
04d1 : 501b                     bvc nbr2
04d3 : 901c                     bcc nbr3
04d5 : d01d                     bne nbr4
04d7 : 3003                     bmi br1         ;branches should be taken
                                trap 
04d9 : 4cd904          >        jmp *           ;failed anyway
                        
04dc : 7003             br1     bvs br2
                                trap 
04de : 4cde04          >        jmp *           ;failed anyway
                        
04e1 : b003             br2     bcs br3
                                trap 
04e3 : 4ce304          >        jmp *           ;failed anyway
                        
04e6 : f00f             br3     beq br4
                                trap 
04e8 : 4ce804          >        jmp *           ;failed anyway
                        
04eb :                  nbr1
                                trap            ;previous bpl taken 
04eb : 4ceb04          >        jmp *           ;failed anyway
                        
04ee :                  nbr2
                                trap            ;previous bvc taken
04ee : 4cee04          >        jmp *           ;failed anyway
                        
04f1 :                  nbr3
                                trap            ;previous bcc taken
04f1 : 4cf104          >        jmp *           ;failed anyway
                        
04f4 :                  nbr4
                                trap            ;previous bne taken
04f4 : 4cf404          >        jmp *           ;failed anyway
                        
04f7 : 08               br4     php
04f8 : ba                       tsx
04f9 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
04fb : d0fe            >        bne *         ;failed not equal (non zero)
                        
04fd : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
04fe : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0500 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0502 : ba                       tsx
0503 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0505 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0507 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
0509 : 48              >            pha         ;use stack to load status
050a : 28              >            plp
                        
050b : 301a                     bmi nbr11       ;branches should not be taken
050d : 701b                     bvs nbr12
050f : b01c                     bcs nbr13
0511 : f01d                     beq nbr14
0513 : 1003                     bpl br11        ;branches should be taken
                                trap 
0515 : 4c1505          >        jmp *           ;failed anyway
                        
0518 : 5003             br11    bvc br12
                                trap 
051a : 4c1a05          >        jmp *           ;failed anyway
                        
051d : 9003             br12    bcc br13
                                trap 
051f : 4c1f05          >        jmp *           ;failed anyway
                        
0522 : d00f             br13    bne br14
                                trap 
0524 : 4c2405          >        jmp *           ;failed anyway
                        
0527 :                  nbr11
                                trap            ;previous bmi taken 
0527 : 4c2705          >        jmp *           ;failed anyway
                        
052a :                  nbr12
                                trap            ;previous bvs taken 
052a : 4c2a05          >        jmp *           ;failed anyway
                        
052d :                  nbr13
                                trap            ;previous bcs taken 
052d : 4c2d05          >        jmp *           ;failed anyway
                        
0530 :                  nbr14
                                trap            ;previous beq taken 
0530 : 4c3005          >        jmp *           ;failed anyway
                        
0533 : 08               br14    php
0534 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0535 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                ;cmp #0
                        		trap_ne
0537 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0539 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
053b : 48              >            pha         ;use stack to load status
053c : 28              >            plp
                        
053d : d002                     bne brzs1
053f : f003                     beq brzs2
0541 :                  brzs1
                                trap            ;branch zero/non zero
0541 : 4c4105          >        jmp *           ;failed anyway
                        
0544 : b002             brzs2   bcs brzs3
0546 : 9003                     bcc brzs4
0548 :                  brzs3
                                trap            ;branch carry/no carry
0548 : 4c4805          >        jmp *           ;failed anyway
                        
054b : 3002             brzs4   bmi brzs5
054d : 1003                     bpl brzs6
054f :                  brzs5
                                trap            ;branch minus/plus
054f : 4c4f05          >        jmp *           ;failed anyway
                        
0552 : 7002             brzs6   bvs brzs7
0554 : 5003                     bvc brzs8
0556 :                  brzs7
                                trap            ;branch overflow/no overflow
0556 : 4c5605          >        jmp *           ;failed anyway
                        
0559 :                  brzs8
                                set_stat carry
                       >            load_flag carry
0559 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
055b : 48              >            pha         ;use stack to load status
055c : 28              >            plp
                        
055d : f002                     beq brcs1
055f : d003                     bne brcs2
0561 :                  brcs1
                                trap            ;branch zero/non zero
0561 : 4c6105          >        jmp *           ;failed anyway
                        
0564 : 9002             brcs2   bcc brcs3
0566 : b003                     bcs brcs4
0568 :                  brcs3
                                trap            ;branch carry/no carry
0568 : 4c6805          >        jmp *           ;failed anyway
                        
056b : 3002             brcs4   bmi brcs5
056d : 1003                     bpl brcs6
056f :                  brcs5
                                trap            ;branch minus/plus
056f : 4c6f05          >        jmp *           ;failed anyway
                        
0572 : 7002             brcs6   bvs brcs7
0574 : 5003                     bvc brcs8
0576 :                  brcs7
                                trap            ;branch overflow/no overflow
0576 : 4c7605          >        jmp *           ;failed anyway
                        
                        
0579 :                  brcs8
                                set_stat minus
                       >            load_flag minus
0579 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
057b : 48              >            pha         ;use stack to load status
057c : 28              >            plp
                        
057d : f002                     beq brmi1
057f : d003                     bne brmi2
0581 :                  brmi1
                                trap            ;branch zero/non zero
0581 : 4c8105          >        jmp *           ;failed anyway
                        
0584 : b002             brmi2   bcs brmi3
0586 : 9003                     bcc brmi4
0588 :                  brmi3
                                trap            ;branch carry/no carry
0588 : 4c8805          >        jmp *           ;failed anyway
                        
058b : 1002             brmi4   bpl brmi5
058d : 3003                     bmi brmi6
058f :                  brmi5
                                trap            ;branch minus/plus
058f : 4c8f05          >        jmp *           ;failed anyway
                        
0592 : 7002             brmi6   bvs brmi7
0594 : 5003                     bvc brmi8
0596 :                  brmi7
                                trap            ;branch overflow/no overflow
0596 : 4c9605          >        jmp *           ;failed anyway
                        
0599 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
0599 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
059b : 48              >            pha         ;use stack to load status
059c : 28              >            plp
                        
059d : f002                     beq brvs1
059f : d003                     bne brvs2
05a1 :                  brvs1
                                trap            ;branch zero/non zero
05a1 : 4ca105          >        jmp *           ;failed anyway
                        
05a4 : b002             brvs2   bcs brvs3
05a6 : 9003                     bcc brvs4
05a8 :                  brvs3
                                trap            ;branch carry/no carry
05a8 : 4ca805          >        jmp *           ;failed anyway
                        
05ab : 3002             brvs4   bmi brvs5
05ad : 1003                     bpl brvs6
05af :                  brvs5
                                trap            ;branch minus/plus
05af : 4caf05          >        jmp *           ;failed anyway
                        
05b2 : 5002             brvs6   bvc brvs7
05b4 : 7003                     bvs brvs8
05b6 :                  brvs7
                                trap            ;branch overflow/no overflow
05b6 : 4cb605          >        jmp *           ;failed anyway
                        
05b9 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
05b9 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
05bb : 48              >            pha         ;use stack to load status
05bc : 28              >            plp
                        
05bd : f002                     beq brzc1
05bf : d003                     bne brzc2
05c1 :                  brzc1
                                trap            ;branch zero/non zero
05c1 : 4cc105          >        jmp *           ;failed anyway
                        
05c4 : 9002             brzc2   bcc brzc3
05c6 : b003                     bcs brzc4
05c8 :                  brzc3
                                trap            ;branch carry/no carry
05c8 : 4cc805          >        jmp *           ;failed anyway
                        
05cb : 1002             brzc4   bpl brzc5
05cd : 3003                     bmi brzc6
05cf :                  brzc5
                                trap            ;branch minus/plus
05cf : 4ccf05          >        jmp *           ;failed anyway
                        
05d2 : 5002             brzc6   bvc brzc7
05d4 : 7003                     bvs brzc8
05d6 :                  brzc7
                                trap            ;branch overflow/no overflow
05d6 : 4cd605          >        jmp *           ;failed anyway
                        
05d9 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
05d9 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
05db : 48              >            pha         ;use stack to load status
05dc : 28              >            plp
                        
05dd : d002                     bne brcc1
05df : f003                     beq brcc2
05e1 :                  brcc1
                                trap            ;branch zero/non zero
05e1 : 4ce105          >        jmp *           ;failed anyway
                        
05e4 : b002             brcc2   bcs brcc3
05e6 : 9003                     bcc brcc4
05e8 :                  brcc3
                                trap            ;branch carry/no carry
05e8 : 4ce805          >        jmp *           ;failed anyway
                        
05eb : 1002             brcc4   bpl brcc5
05ed : 3003                     bmi brcc6
05ef :                  brcc5
                                trap            ;branch minus/plus
05ef : 4cef05          >        jmp *           ;failed anyway
                        
05f2 : 5002             brcc6   bvc brcc7
05f4 : 7003                     bvs brcc8
05f6 :                  brcc7
                                trap            ;branch overflow/no overflow
05f6 : 4cf605          >        jmp *           ;failed anyway
                        
05f9 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
05f9 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
05fb : 48              >            pha         ;use stack to load status
05fc : 28              >            plp
                        
05fd : d002                     bne brpl1
05ff : f003                     beq brpl2
0601 :                  brpl1
                                trap            ;branch zero/non zero
0601 : 4c0106          >        jmp *           ;failed anyway
                        
0604 : 9002             brpl2   bcc brpl3
0606 : b003                     bcs brpl4
0608 :                  brpl3
                                trap            ;branch carry/no carry
0608 : 4c0806          >        jmp *           ;failed anyway
                        
060b : 3002             brpl4   bmi brpl5
060d : 1003                     bpl brpl6
060f :                  brpl5
                                trap            ;branch minus/plus
060f : 4c0f06          >        jmp *           ;failed anyway
                        
0612 : 5002             brpl6   bvc brpl7
0614 : 7003                     bvs brpl8
0616 :                  brpl7
                                trap            ;branch overflow/no overflow
0616 : 4c1606          >        jmp *           ;failed anyway
                        
0619 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0619 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
061b : 48              >            pha         ;use stack to load status
061c : 28              >            plp
                        
061d : d002                     bne brvc1
061f : f003                     beq brvc2
0621 :                  brvc1
                                trap            ;branch zero/non zero
0621 : 4c2106          >        jmp *           ;failed anyway
                        
0624 : 9002             brvc2   bcc brvc3
0626 : b003                     bcs brvc4
0628 :                  brvc3
                                trap            ;branch carry/no carry
0628 : 4c2806          >        jmp *           ;failed anyway
                        
062b : 1002             brvc4   bpl brvc5
062d : 3003                     bmi brvc6
062f :                  brvc5
                                trap            ;branch minus/plus
062f : 4c2f06          >        jmp *           ;failed anyway
                        
0632 : 7002             brvc6   bvs brvc7
0634 : 5003                     bvc brvc8
0636 :                  brvc7
                                trap            ;branch overflow/no overflow
0636 : 4c3606          >        jmp *           ;failed anyway
                        
0639 :                  brvc8
                                next_test
0639 : ad0002          >            lda test_case   ;previous test
063c : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
063e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
0640 : a905            >            lda #test_num   ;*** next tests' number
0642 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0645 : a255                     ldx #$55        ;x & y protected
0647 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
0649 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
064b : 48              >            pha         ;use stack to load status
064c : a901            >            lda #1     ;precharge accu
064e : 28              >            plp
                        
064f : 48                       pha
                                tst_a 1,$ff
0650 : 08              >            php         ;save flags
0651 : c901            >            cmp #1     ;test result
                       >            trap_ne
0653 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0655 : 68              >            pla         ;load status
0656 : 48              >            pha
                       >            cmp_flag $ff
0657 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0659 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
065b : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
065c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
065e : 48              >            pha         ;use stack to load status
065f : a900            >            lda #0     ;precharge accu
0661 : 28              >            plp
                        
0662 : 48                       pha
                                tst_a 0,0
0663 : 08              >            php         ;save flags
0664 : c900            >            cmp #0     ;test result
                       >            trap_ne
0666 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0668 : 68              >            pla         ;load status
0669 : 48              >            pha
                       >            cmp_flag 0
066a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
066c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
066e : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
066f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0671 : 48              >            pha         ;use stack to load status
0672 : a9ff            >            lda #$ff     ;precharge accu
0674 : 28              >            plp
                        
0675 : 48                       pha
                                tst_a $ff,$ff
0676 : 08              >            php         ;save flags
0677 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0679 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
067b : 68              >            pla         ;load status
067c : 48              >            pha
                       >            cmp_flag $ff
067d : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
067f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0681 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
0682 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0684 : 48              >            pha         ;use stack to load status
0685 : a901            >            lda #1     ;precharge accu
0687 : 28              >            plp
                        
0688 : 48                       pha
                                tst_a 1,0
0689 : 08              >            php         ;save flags
068a : c901            >            cmp #1     ;test result
                       >            trap_ne
068c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
068e : 68              >            pla         ;load status
068f : 48              >            pha
                       >            cmp_flag 0
0690 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0692 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0694 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
0695 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0697 : 48              >            pha         ;use stack to load status
0698 : a900            >            lda #0     ;precharge accu
069a : 28              >            plp
                        
069b : 48                       pha
                                tst_a 0,$ff
069c : 08              >            php         ;save flags
069d : c900            >            cmp #0     ;test result
                       >            trap_ne
069f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06a1 : 68              >            pla         ;load status
06a2 : 48              >            pha
                       >            cmp_flag $ff
06a3 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06a5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06a7 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
06a8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
06aa : 48              >            pha         ;use stack to load status
06ab : a9ff            >            lda #$ff     ;precharge accu
06ad : 28              >            plp
                        
06ae : 48                       pha
                                tst_a $ff,0
06af : 08              >            php         ;save flags
06b0 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
06b2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06b4 : 68              >            pla         ;load status
06b5 : 48              >            pha
                       >            cmp_flag 0
06b6 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06b8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06ba : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
06bb : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
06bd : 48              >            pha         ;use stack to load status
06be : a900            >            lda #0     ;precharge accu
06c0 : 28              >            plp
                        
06c1 : 68                       pla
                                tst_a $ff,$ff-zero
06c2 : 08              >            php         ;save flags
06c3 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
06c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06c7 : 68              >            pla         ;load status
06c8 : 48              >            pha
                       >            cmp_flag $ff-zero
06c9 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06cb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06cd : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
06ce : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
06d0 : 48              >            pha         ;use stack to load status
06d1 : a9ff            >            lda #$ff     ;precharge accu
06d3 : 28              >            plp
                        
06d4 : 68                       pla
                                tst_a 0,zero
06d5 : 08              >            php         ;save flags
06d6 : c900            >            cmp #0     ;test result
                       >            trap_ne
06d8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06da : 68              >            pla         ;load status
06db : 48              >            pha
                       >            cmp_flag zero
06dc : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06de : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06e0 : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
06e1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
06e3 : 48              >            pha         ;use stack to load status
06e4 : a9fe            >            lda #$fe     ;precharge accu
06e6 : 28              >            plp
                        
06e7 : 68                       pla
                                tst_a 1,$ff-zero-minus
06e8 : 08              >            php         ;save flags
06e9 : c901            >            cmp #1     ;test result
                       >            trap_ne
06eb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06ed : 68              >            pla         ;load status
06ee : 48              >            pha
                       >            cmp_flag $ff-zero-minus
06ef : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
06f1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
06f3 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
06f4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
06f6 : 48              >            pha         ;use stack to load status
06f7 : a900            >            lda #0     ;precharge accu
06f9 : 28              >            plp
                        
06fa : 68                       pla
                                tst_a $ff,minus
06fb : 08              >            php         ;save flags
06fc : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
06fe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0700 : 68              >            pla         ;load status
0701 : 48              >            pha
                       >            cmp_flag minus
0702 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0704 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0706 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0707 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0709 : 48              >            pha         ;use stack to load status
070a : a9ff            >            lda #$ff     ;precharge accu
070c : 28              >            plp
                        
070d : 68                       pla
                                tst_a 0,$ff-minus
070e : 08              >            php         ;save flags
070f : c900            >            cmp #0     ;test result
                       >            trap_ne
0711 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0713 : 68              >            pla         ;load status
0714 : 48              >            pha
                       >            cmp_flag $ff-minus
0715 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0717 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0719 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
071a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
071c : 48              >            pha         ;use stack to load status
071d : a9fe            >            lda #$fe     ;precharge accu
071f : 28              >            plp
                        
0720 : 68                       pla
                                tst_a 1,0
0721 : 08              >            php         ;save flags
0722 : c901            >            cmp #1     ;test result
                       >            trap_ne
0724 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0726 : 68              >            pla         ;load status
0727 : 48              >            pha
                       >            cmp_flag 0
0728 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
072a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
072c : 28              >            plp         ;restore status
                        
072d : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
072f : d0fe            >        bne *         ;failed not equal (non zero)
                        
0731 : c0aa                     cpy #$aa
                                trap_ne
0733 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
0735 : ad0002          >            lda test_case   ;previous test
0738 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
073a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
073c : a906            >            lda #test_num   ;*** next tests' number
073e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
0741 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0743 : 48              >            pha         ;use stack to load status
0744 : a93c            >            lda #$3c     ;precharge accu
0746 : 28              >            plp
                        
0747 : 49c3                     eor #$c3
                                tst_a $ff,fn
0749 : 08              >            php         ;save flags
074a : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
074c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
074e : 68              >            pla         ;load status
074f : 48              >            pha
                       >            cmp_flag fn
0750 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0752 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0754 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0755 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0757 : 48              >            pha         ;use stack to load status
0758 : a9c3            >            lda #$c3     ;precharge accu
075a : 28              >            plp
                        
075b : 49c3                     eor #$c3
                                tst_a 0,fz
075d : 08              >            php         ;save flags
075e : c900            >            cmp #0     ;test result
                       >            trap_ne
0760 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0762 : 68              >            pla         ;load status
0763 : 48              >            pha
                       >            cmp_flag fz
0764 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0766 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0768 : 28              >            plp         ;restore status
                        
                                next_test
0769 : ad0002          >            lda test_case   ;previous test
076c : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
076e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
0770 : a907            >            lda #test_num   ;*** next tests' number
0772 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
0775 : a224                     ldx #$24
0777 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
0779 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
077b : 48              >            pha         ;use stack to load status
077c : a918            >            lda #$18     ;precharge accu
077e : 28              >            plp
                        
077f : ea                       nop
                                tst_a $18,0
0780 : 08              >            php         ;save flags
0781 : c918            >            cmp #$18     ;test result
                       >            trap_ne
0783 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0785 : 68              >            pla         ;load status
0786 : 48              >            pha
                       >            cmp_flag 0
0787 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0789 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
078b : 28              >            plp         ;restore status
                        
078c : e024                     cpx #$24
                                trap_ne
078e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0790 : c042                     cpy #$42
                                trap_ne
0792 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0794 : a2db                     ldx #$db
0796 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
0798 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
079a : 48              >            pha         ;use stack to load status
079b : a9e7            >            lda #$e7     ;precharge accu
079d : 28              >            plp
                        
079e : ea                       nop
                                tst_a $e7,$ff
079f : 08              >            php         ;save flags
07a0 : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
07a2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
07a4 : 68              >            pla         ;load status
07a5 : 48              >            pha
                       >            cmp_flag $ff
07a6 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07a8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
07aa : 28              >            plp         ;restore status
                        
07ab : e0db                     cpx #$db
                                trap_ne
07ad : d0fe            >        bne *         ;failed not equal (non zero)
                        
07af : c0bd                     cpy #$bd
                                trap_ne
07b1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
07b3 : ad0002          >            lda test_case   ;previous test
07b6 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
07b8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
07ba : a908            >            lda #test_num   ;*** next tests' number
07bc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
07bf : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
07c1 : 48              >            pha         ;use stack to load status
07c2 : 28              >            plp
                        
07c3 : a946                     lda #'F'
07c5 : a241                     ldx #'A'
07c7 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
07c9 : 4c8333                   jmp test_far
07cc : ea                       nop
07cd : ea                       nop
                                trap_ne         ;runover protection
07ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
07d0 : e8                       inx
07d1 : e8                       inx
07d2 :                  far_ret 
                                trap_eq         ;returned flags OK?
07d2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
07d4 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
07d6 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
07d8 : 50fe            >        bvc *           ;failed overflow clear
                        
07da : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
07dc : d0fe            >        bne *         ;failed not equal (non zero)
                        
07de : e042                     cpx #('A'+1)
                                trap_ne
07e0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
07e2 : c04f                     cpy #('R'-3)
                                trap_ne
07e4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
07e6 : ca                       dex
07e7 : c8                       iny
07e8 : c8                       iny
07e9 : c8                       iny
07ea : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
07ec : 4cf507                   jmp test_near
07ef : ea                       nop
07f0 : ea                       nop
                                trap_ne         ;runover protection
07f1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
07f3 : e8                       inx
07f4 : e8                       inx
07f5 :                  test_near
                                trap_eq         ;passed flags OK?
07f5 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
07f7 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_cc
07f9 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
07fb : 50fe            >        bvc *           ;failed overflow clear
                        
07fd : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
07ff : d0fe            >        bne *         ;failed not equal (non zero)
                        
0801 : e041                     cpx #'A'
                                trap_ne
0803 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0805 : c052                     cpy #'R'
                                trap_ne
0807 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
0809 : ad0002          >            lda test_case   ;previous test
080c : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
080e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
0810 : a909            >            lda #test_num   ;*** next tests' number
0812 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0815 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0817 : 48              >            pha         ;use stack to load status
0818 : 28              >            plp
                        
0819 : a949                     lda #'I'
081b : a24e                     ldx #'N'
081d : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
081f : 6cb233                   jmp (ptr_tst_ind)
0822 : ea                       nop
                                trap_ne         ;runover protection
0823 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0825 : 88                       dey
0826 : 88                       dey
0827 :                  ind_ret 
0827 : 08                       php             ;either SP or Y count will fail, if we do not hit
0828 : 88                       dey
0829 : 88                       dey
082a : 88                       dey
082b : 28                       plp
                                trap_eq         ;returned flags OK?
082c : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
082e : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
0830 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0832 : 50fe            >        bvc *           ;failed overflow clear
                        
0834 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0836 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0838 : e04f                     cpx #('N'+1)
                                trap_ne
083a : d0fe            >        bne *         ;failed not equal (non zero)
                        
083c : c03e                     cpy #('D'-6)
                                trap_ne
083e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0840 : ba                       tsx             ;SP check
0841 : e0ff                     cpx #$ff
                                trap_ne
0843 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
0845 : ad0002          >            lda test_case   ;previous test
0848 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
084a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
084c : a90a            >            lda #test_num   ;*** next tests' number
084e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
0851 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0853 : 48              >            pha         ;use stack to load status
0854 : 28              >            plp
                        
0855 : a94a                     lda #'J'
0857 : a253                     ldx #'S'
0859 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
085b : 20f133                   jsr test_jsr
085d =                  jsr_ret = *-1           ;last address of jsr = return address
085e : 08                       php             ;either SP or Y count will fail, if we do not hit
085f : 88                       dey
0860 : 88                       dey
0861 : 88                       dey
0862 : 28                       plp
                                trap_eq         ;returned flags OK?
0863 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0865 : 10fe            >        bpl *          ;failed plus (bit 7 clear)
                        
                                trap_cc
0867 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0869 : 50fe            >        bvc *           ;failed overflow clear
                        
086b : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
086d : d0fe            >        bne *         ;failed not equal (non zero)
                        
086f : e054                     cpx #('S'+1)
                                trap_ne
0871 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0873 : c04c                     cpy #('R'-6)
                                trap_ne
0875 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0877 : ba                       tsx             ;sp?
0878 : e0ff                     cpx #$ff
                                trap_ne
087a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
087c : ad0002          >            lda test_case   ;previous test
087f : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0881 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
0883 : a90b            >            lda #test_num   ;*** next tests' number
0885 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
0888 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
088a : 48                       pha
088b : a942                     lda #'B'
088d : a252                     ldx #'R'
088f : a04b                     ldy #'K'
0891 : 28                       plp             ;N=0, V=0, Z=0, C=0
0892 : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
0893 : 88                       dey             ;should not be executed
0894 :                  brk_ret0                ;address of break return
0894 : 08                       php             ;either SP or Y count will fail, if we do not hit
0895 : 88                       dey
0896 : 88                       dey
0897 : 88                       dey
0898 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
089a : d0fe            >        bne *         ;failed not equal (non zero)
                        
089c : e053                     cpx #'R'+1
                                trap_ne
089e : d0fe            >        bne *         ;failed not equal (non zero)
                        
08a0 : c045                     cpy #'K'-6
                                trap_ne
08a2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08a4 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
08a5 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
08a7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08a9 : ba                       tsx             ;sp?
08aa : e0ff                     cpx #$ff
                                trap_ne
08ac : d0fe            >        bne *         ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
08ae : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
08b0 : 48                       pha
08b1 : a9bd                     lda #$ff-'B'
08b3 : a2ad                     ldx #$ff-'R'
08b5 : a0b4                     ldy #$ff-'K'
08b7 : 28                       plp             ;N=1, V=1, Z=1, C=1
08b8 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
08b9 : 88                       dey             ;should not be executed
08ba :                  brk_ret1                ;address of break return
08ba : 08                       php             ;either SP or Y count will fail, if we do not hit
08bb : 88                       dey
08bc : 88                       dey
08bd : 88                       dey
08be : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
08c0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08c2 : e0ae                     cpx #$ff-'R'+1
                                trap_ne
08c4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08c6 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
08c8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
08ca : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
08cb : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
08cd : d0fe            >        bne *         ;failed not equal (non zero)
                        
08cf : ba                       tsx             ;sp?
08d0 : e0ff                     cpx #$ff
                                trap_ne
08d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                next_test
08d4 : ad0002          >            lda test_case   ;previous test
08d7 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08d9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
08db : a90c            >            lda #test_num   ;*** next tests' number
08dd : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
08e0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
08e2 : 48              >            pha         ;use stack to load status
08e3 : 28              >            plp
                        
08e4 : 18                       clc
                                tst_stat $ff-carry
08e5 : 08              >            php         ;save status
08e6 : 68              >            pla         ;use stack to retrieve status
08e7 : 48              >            pha
                       >            cmp_flag $ff-carry
08e8 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08ea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
08ec : 28              >            plp         ;restore status
                        
08ed : 38                       sec
                                tst_stat $ff
08ee : 08              >            php         ;save status
08ef : 68              >            pla         ;use stack to retrieve status
08f0 : 48              >            pha
                       >            cmp_flag $ff
08f1 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08f3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
08f5 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
08f6 : 58                       cli
                                tst_stat $ff-intdis
08f7 : 08              >            php         ;save status
08f8 : 68              >            pla         ;use stack to retrieve status
08f9 : 48              >            pha
                       >            cmp_flag $ff-intdis
08fa : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08fc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
08fe : 28              >            plp         ;restore status
                        
08ff : 78                       sei
                                tst_stat $ff
0900 : 08              >            php         ;save status
0901 : 68              >            pla         ;use stack to retrieve status
0902 : 48              >            pha
                       >            cmp_flag $ff
0903 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0905 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0907 : 28              >            plp         ;restore status
                        
                            endif
0908 : d8                       cld
                                tst_stat $ff-decmode
0909 : 08              >            php         ;save status
090a : 68              >            pla         ;use stack to retrieve status
090b : 48              >            pha
                       >            cmp_flag $ff-decmode
090c : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
090e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0910 : 28              >            plp         ;restore status
                        
0911 : f8                       sed
                                tst_stat $ff
0912 : 08              >            php         ;save status
0913 : 68              >            pla         ;use stack to retrieve status
0914 : 48              >            pha
                       >            cmp_flag $ff
0915 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0917 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0919 : 28              >            plp         ;restore status
                        
091a : b8                       clv
                                tst_stat $ff-overfl
091b : 08              >            php         ;save status
091c : 68              >            pla         ;use stack to retrieve status
091d : 48              >            pha
                       >            cmp_flag $ff-overfl
091e : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0920 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0922 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0923 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0925 : 48              >            pha         ;use stack to load status
0926 : 28              >            plp
                        
                                tst_stat 0
0927 : 08              >            php         ;save status
0928 : 68              >            pla         ;use stack to retrieve status
0929 : 48              >            pha
                       >            cmp_flag 0
092a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
092c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
092e : 28              >            plp         ;restore status
                        
092f : 38                       sec
                                tst_stat carry
0930 : 08              >            php         ;save status
0931 : 68              >            pla         ;use stack to retrieve status
0932 : 48              >            pha
                       >            cmp_flag carry
0933 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0935 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0937 : 28              >            plp         ;restore status
                        
0938 : 18                       clc
                                tst_stat 0  
0939 : 08              >            php         ;save status
093a : 68              >            pla         ;use stack to retrieve status
093b : 48              >            pha
                       >            cmp_flag 0  
093c : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
093e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0940 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0941 : 78                       sei
                                tst_stat intdis
0942 : 08              >            php         ;save status
0943 : 68              >            pla         ;use stack to retrieve status
0944 : 48              >            pha
                       >            cmp_flag intdis
0945 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0947 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0949 : 28              >            plp         ;restore status
                        
094a : 58                       cli
                                tst_stat 0
094b : 08              >            php         ;save status
094c : 68              >            pla         ;use stack to retrieve status
094d : 48              >            pha
                       >            cmp_flag 0
094e : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0950 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0952 : 28              >            plp         ;restore status
                        
                            endif  
0953 : f8                       sed
                                tst_stat decmode
0954 : 08              >            php         ;save status
0955 : 68              >            pla         ;use stack to retrieve status
0956 : 48              >            pha
                       >            cmp_flag decmode
0957 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0959 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
095b : 28              >            plp         ;restore status
                        
095c : d8                       cld
                                tst_stat 0  
095d : 08              >            php         ;save status
095e : 68              >            pla         ;use stack to retrieve status
095f : 48              >            pha
                       >            cmp_flag 0  
0960 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0962 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0964 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0965 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0967 : 48              >            pha         ;use stack to load status
0968 : 28              >            plp
                        
                                tst_stat overfl
0969 : 08              >            php         ;save status
096a : 68              >            pla         ;use stack to retrieve status
096b : 48              >            pha
                       >            cmp_flag overfl
096c : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
096e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0970 : 28              >            plp         ;restore status
                        
0971 : b8                       clv
                                tst_stat 0
0972 : 08              >            php         ;save status
0973 : 68              >            pla         ;use stack to retrieve status
0974 : 48              >            pha
                       >            cmp_flag 0
0975 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0977 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0979 : 28              >            plp         ;restore status
                        
                                next_test
097a : ad0002          >            lda test_case   ;previous test
097d : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
097f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0981 : a90d            >            lda #test_num   ;*** next tests' number
0983 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0986 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0988 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
098a : 48              >            pha         ;use stack to load status
098b : 28              >            plp
                        
098c : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
098d : 08              >            php         ;save flags
098e : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0990 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0992 : 68              >            pla         ;load status
0993 : 48              >            pha
                       >            cmp_flag $ff-zero
0994 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0996 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0998 : 28              >            plp         ;restore status
                        
0999 : e8                       inx             ;00
                                tst_x 0,$ff-minus
099a : 08              >            php         ;save flags
099b : e000            >            cpx #0     ;test result
                       >            trap_ne
099d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
099f : 68              >            pla         ;load status
09a0 : 48              >            pha
                       >            cmp_flag $ff-minus
09a1 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09a5 : 28              >            plp         ;restore status
                        
09a6 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
09a7 : 08              >            php         ;save flags
09a8 : e001            >            cpx #1     ;test result
                       >            trap_ne
09aa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09ac : 68              >            pla         ;load status
09ad : 48              >            pha
                       >            cmp_flag $ff-minus-zero
09ae : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09b0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09b2 : 28              >            plp         ;restore status
                        
09b3 : ca                       dex             ;00
                                tst_x 0,$ff-minus
09b4 : 08              >            php         ;save flags
09b5 : e000            >            cpx #0     ;test result
                       >            trap_ne
09b7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09b9 : 68              >            pla         ;load status
09ba : 48              >            pha
                       >            cmp_flag $ff-minus
09bb : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09bd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09bf : 28              >            plp         ;restore status
                        
09c0 : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
09c1 : 08              >            php         ;save flags
09c2 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
09c4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09c6 : 68              >            pla         ;load status
09c7 : 48              >            pha
                       >            cmp_flag $ff-zero
09c8 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09ca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09cc : 28              >            plp         ;restore status
                        
09cd : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
09ce : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
09d0 : 48              >            pha         ;use stack to load status
09d1 : 28              >            plp
                        
09d2 : e8                       inx             ;ff
                                tst_x $ff,minus
09d3 : 08              >            php         ;save flags
09d4 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
09d6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09d8 : 68              >            pla         ;load status
09d9 : 48              >            pha
                       >            cmp_flag minus
09da : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09dc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09de : 28              >            plp         ;restore status
                        
09df : e8                       inx             ;00
                                tst_x 0,zero
09e0 : 08              >            php         ;save flags
09e1 : e000            >            cpx #0     ;test result
                       >            trap_ne
09e3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09e5 : 68              >            pla         ;load status
09e6 : 48              >            pha
                       >            cmp_flag zero
09e7 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09e9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09eb : 28              >            plp         ;restore status
                        
09ec : e8                       inx             ;01
                                tst_x 1,0
09ed : 08              >            php         ;save flags
09ee : e001            >            cpx #1     ;test result
                       >            trap_ne
09f0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09f2 : 68              >            pla         ;load status
09f3 : 48              >            pha
                       >            cmp_flag 0
09f4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
09f6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09f8 : 28              >            plp         ;restore status
                        
09f9 : ca                       dex             ;00
                                tst_x 0,zero
09fa : 08              >            php         ;save flags
09fb : e000            >            cpx #0     ;test result
                       >            trap_ne
09fd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
09ff : 68              >            pla         ;load status
0a00 : 48              >            pha
                       >            cmp_flag zero
0a01 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a03 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a05 : 28              >            plp         ;restore status
                        
0a06 : ca                       dex             ;ff
                                tst_x $ff,minus
0a07 : 08              >            php         ;save flags
0a08 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0a0a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a0c : 68              >            pla         ;load status
0a0d : 48              >            pha
                       >            cmp_flag minus
0a0e : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a10 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a12 : 28              >            plp         ;restore status
                        
                        
0a13 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0a15 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a17 : 48              >            pha         ;use stack to load status
0a18 : 28              >            plp
                        
0a19 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0a1a : 08              >            php         ;save flags
0a1b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0a1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a1f : 68              >            pla         ;load status
0a20 : 48              >            pha
                       >            cmp_flag $ff-zero
0a21 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a23 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a25 : 28              >            plp         ;restore status
                        
0a26 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0a27 : 08              >            php         ;save flags
0a28 : c000            >            cpy #0     ;test result
                       >            trap_ne
0a2a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a2c : 68              >            pla         ;load status
0a2d : 48              >            pha
                       >            cmp_flag $ff-minus
0a2e : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a30 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a32 : 28              >            plp         ;restore status
                        
0a33 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0a34 : 08              >            php         ;save flags
0a35 : c001            >            cpy #1     ;test result
                       >            trap_ne
0a37 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a39 : 68              >            pla         ;load status
0a3a : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0a3b : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a3f : 28              >            plp         ;restore status
                        
0a40 : 88                       dey             ;00
                                tst_y 0,$ff-minus
0a41 : 08              >            php         ;save flags
0a42 : c000            >            cpy #0     ;test result
                       >            trap_ne
0a44 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a46 : 68              >            pla         ;load status
0a47 : 48              >            pha
                       >            cmp_flag $ff-minus
0a48 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a4a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a4c : 28              >            plp         ;restore status
                        
0a4d : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0a4e : 08              >            php         ;save flags
0a4f : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0a51 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a53 : 68              >            pla         ;load status
0a54 : 48              >            pha
                       >            cmp_flag $ff-zero
0a55 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a57 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a59 : 28              >            plp         ;restore status
                        
0a5a : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0a5b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a5d : 48              >            pha         ;use stack to load status
0a5e : 28              >            plp
                        
0a5f : c8                       iny             ;ff
                                tst_y $ff,0+minus
0a60 : 08              >            php         ;save flags
0a61 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0a63 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a65 : 68              >            pla         ;load status
0a66 : 48              >            pha
                       >            cmp_flag 0+minus
0a67 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a6b : 28              >            plp         ;restore status
                        
0a6c : c8                       iny             ;00
                                tst_y 0,zero
0a6d : 08              >            php         ;save flags
0a6e : c000            >            cpy #0     ;test result
                       >            trap_ne
0a70 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a72 : 68              >            pla         ;load status
0a73 : 48              >            pha
                       >            cmp_flag zero
0a74 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a76 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a78 : 28              >            plp         ;restore status
                        
0a79 : c8                       iny             ;01
                                tst_y 1,0
0a7a : 08              >            php         ;save flags
0a7b : c001            >            cpy #1     ;test result
                       >            trap_ne
0a7d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a7f : 68              >            pla         ;load status
0a80 : 48              >            pha
                       >            cmp_flag 0
0a81 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a83 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a85 : 28              >            plp         ;restore status
                        
0a86 : 88                       dey             ;00
                                tst_y 0,zero
0a87 : 08              >            php         ;save flags
0a88 : c000            >            cpy #0     ;test result
                       >            trap_ne
0a8a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a8c : 68              >            pla         ;load status
0a8d : 48              >            pha
                       >            cmp_flag zero
0a8e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a90 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a92 : 28              >            plp         ;restore status
                        
0a93 : 88                       dey             ;ff
                                tst_y $ff,minus
0a94 : 08              >            php         ;save flags
0a95 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0a97 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a99 : 68              >            pla         ;load status
0a9a : 48              >            pha
                       >            cmp_flag minus
0a9b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a9d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0a9f : 28              >            plp         ;restore status
                        
                                        
0aa0 : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0aa2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0aa4 : 48              >            pha         ;use stack to load status
0aa5 : 28              >            plp
                        
0aa6 : 8a                       txa
                                tst_a $ff,$ff-zero
0aa7 : 08              >            php         ;save flags
0aa8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0aaa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0aac : 68              >            pla         ;load status
0aad : 48              >            pha
                       >            cmp_flag $ff-zero
0aae : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ab0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ab2 : 28              >            plp         ;restore status
                        
0ab3 : 08                       php
0ab4 : e8                       inx             ;00
0ab5 : 28                       plp
0ab6 : 8a                       txa
                                tst_a 0,$ff-minus
0ab7 : 08              >            php         ;save flags
0ab8 : c900            >            cmp #0     ;test result
                       >            trap_ne
0aba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0abc : 68              >            pla         ;load status
0abd : 48              >            pha
                       >            cmp_flag $ff-minus
0abe : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ac0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ac2 : 28              >            plp         ;restore status
                        
0ac3 : 08                       php
0ac4 : e8                       inx             ;01
0ac5 : 28                       plp
0ac6 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0ac7 : 08              >            php         ;save flags
0ac8 : c901            >            cmp #1     ;test result
                       >            trap_ne
0aca : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0acc : 68              >            pla         ;load status
0acd : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0ace : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ad0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ad2 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0ad3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ad5 : 48              >            pha         ;use stack to load status
0ad6 : 28              >            plp
                        
0ad7 : 8a                       txa
                                tst_a 1,0
0ad8 : 08              >            php         ;save flags
0ad9 : c901            >            cmp #1     ;test result
                       >            trap_ne
0adb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0add : 68              >            pla         ;load status
0ade : 48              >            pha
                       >            cmp_flag 0
0adf : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ae1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0ae3 : 28              >            plp         ;restore status
                        
0ae4 : 08                       php
0ae5 : ca                       dex             ;00
0ae6 : 28                       plp
0ae7 : 8a                       txa
                                tst_a 0,zero
0ae8 : 08              >            php         ;save flags
0ae9 : c900            >            cmp #0     ;test result
                       >            trap_ne
0aeb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0aed : 68              >            pla         ;load status
0aee : 48              >            pha
                       >            cmp_flag zero
0aef : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0af1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0af3 : 28              >            plp         ;restore status
                        
0af4 : 08                       php
0af5 : ca                       dex             ;ff
0af6 : 28                       plp
0af7 : 8a                       txa
                                tst_a $ff,minus
0af8 : 08              >            php         ;save flags
0af9 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0afb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0afd : 68              >            pla         ;load status
0afe : 48              >            pha
                       >            cmp_flag minus
0aff : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b01 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b03 : 28              >            plp         ;restore status
                        
                                                
0b04 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0b06 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b08 : 48              >            pha         ;use stack to load status
0b09 : 28              >            plp
                        
0b0a : 98                       tya
                                tst_a $ff,$ff-zero
0b0b : 08              >            php         ;save flags
0b0c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0b0e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b10 : 68              >            pla         ;load status
0b11 : 48              >            pha
                       >            cmp_flag $ff-zero
0b12 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b14 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b16 : 28              >            plp         ;restore status
                        
0b17 : 08                       php
0b18 : c8                       iny             ;00
0b19 : 28                       plp
0b1a : 98                       tya
                                tst_a 0,$ff-minus
0b1b : 08              >            php         ;save flags
0b1c : c900            >            cmp #0     ;test result
                       >            trap_ne
0b1e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b20 : 68              >            pla         ;load status
0b21 : 48              >            pha
                       >            cmp_flag $ff-minus
0b22 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b24 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b26 : 28              >            plp         ;restore status
                        
0b27 : 08                       php
0b28 : c8                       iny             ;01
0b29 : 28                       plp
0b2a : 98                       tya
                                tst_a 1,$ff-minus-zero
0b2b : 08              >            php         ;save flags
0b2c : c901            >            cmp #1     ;test result
                       >            trap_ne
0b2e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b30 : 68              >            pla         ;load status
0b31 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b32 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b34 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b36 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0b37 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b39 : 48              >            pha         ;use stack to load status
0b3a : 28              >            plp
                        
0b3b : 98                       tya
                                tst_a 1,0
0b3c : 08              >            php         ;save flags
0b3d : c901            >            cmp #1     ;test result
                       >            trap_ne
0b3f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b41 : 68              >            pla         ;load status
0b42 : 48              >            pha
                       >            cmp_flag 0
0b43 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b45 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b47 : 28              >            plp         ;restore status
                        
0b48 : 08                       php
0b49 : 88                       dey             ;00
0b4a : 28                       plp
0b4b : 98                       tya
                                tst_a 0,zero
0b4c : 08              >            php         ;save flags
0b4d : c900            >            cmp #0     ;test result
                       >            trap_ne
0b4f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b51 : 68              >            pla         ;load status
0b52 : 48              >            pha
                       >            cmp_flag zero
0b53 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b55 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b57 : 28              >            plp         ;restore status
                        
0b58 : 08                       php
0b59 : 88                       dey             ;ff
0b5a : 28                       plp
0b5b : 98                       tya
                                tst_a $ff,minus
0b5c : 08              >            php         ;save flags
0b5d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0b5f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b61 : 68              >            pla         ;load status
0b62 : 48              >            pha
                       >            cmp_flag minus
0b63 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b65 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b67 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0b68 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0b6a : 48                       pha
0b6b : a2ff                     ldx #$ff        ;ff
0b6d : 8a                       txa
0b6e : 28                       plp             
0b6f : a8                       tay
                                tst_y $ff,$ff-zero
0b70 : 08              >            php         ;save flags
0b71 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b73 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b75 : 68              >            pla         ;load status
0b76 : 48              >            pha
                       >            cmp_flag $ff-zero
0b77 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b79 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b7b : 28              >            plp         ;restore status
                        
0b7c : 08                       php
0b7d : e8                       inx             ;00
0b7e : 8a                       txa
0b7f : 28                       plp
0b80 : a8                       tay
                                tst_y 0,$ff-minus
0b81 : 08              >            php         ;save flags
0b82 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b84 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b86 : 68              >            pla         ;load status
0b87 : 48              >            pha
                       >            cmp_flag $ff-minus
0b88 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b8a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b8c : 28              >            plp         ;restore status
                        
0b8d : 08                       php
0b8e : e8                       inx             ;01
0b8f : 8a                       txa
0b90 : 28                       plp
0b91 : a8                       tay
                                tst_y 1,$ff-minus-zero
0b92 : 08              >            php         ;save flags
0b93 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b95 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b97 : 68              >            pla         ;load status
0b98 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b99 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b9b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0b9d : 28              >            plp         ;restore status
                        
                                load_flag 0
0b9e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0ba0 : 48                       pha
0ba1 : a900                     lda #0
0ba3 : 8a                       txa
0ba4 : 28                       plp
0ba5 : a8                       tay
                                tst_y 1,0
0ba6 : 08              >            php         ;save flags
0ba7 : c001            >            cpy #1     ;test result
                       >            trap_ne
0ba9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bab : 68              >            pla         ;load status
0bac : 48              >            pha
                       >            cmp_flag 0
0bad : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0baf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bb1 : 28              >            plp         ;restore status
                        
0bb2 : 08                       php
0bb3 : ca                       dex             ;00
0bb4 : 8a                       txa
0bb5 : 28                       plp
0bb6 : a8                       tay
                                tst_y 0,zero
0bb7 : 08              >            php         ;save flags
0bb8 : c000            >            cpy #0     ;test result
                       >            trap_ne
0bba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bbc : 68              >            pla         ;load status
0bbd : 48              >            pha
                       >            cmp_flag zero
0bbe : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bc0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bc2 : 28              >            plp         ;restore status
                        
0bc3 : 08                       php
0bc4 : ca                       dex             ;ff
0bc5 : 8a                       txa
0bc6 : 28                       plp
0bc7 : a8                       tay
                                tst_y $ff,minus
0bc8 : 08              >            php         ;save flags
0bc9 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bcb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bcd : 68              >            pla         ;load status
0bce : 48              >            pha
                       >            cmp_flag minus
0bcf : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bd1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bd3 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0bd4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0bd6 : 48                       pha
0bd7 : a0ff                     ldy #$ff        ;ff
0bd9 : 98                       tya
0bda : 28                       plp
0bdb : aa                       tax
                                tst_x $ff,$ff-zero
0bdc : 08              >            php         ;save flags
0bdd : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0bdf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0be1 : 68              >            pla         ;load status
0be2 : 48              >            pha
                       >            cmp_flag $ff-zero
0be3 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0be5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0be7 : 28              >            plp         ;restore status
                        
0be8 : 08                       php
0be9 : c8                       iny             ;00
0bea : 98                       tya
0beb : 28                       plp
0bec : aa                       tax
                                tst_x 0,$ff-minus
0bed : 08              >            php         ;save flags
0bee : e000            >            cpx #0     ;test result
                       >            trap_ne
0bf0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bf2 : 68              >            pla         ;load status
0bf3 : 48              >            pha
                       >            cmp_flag $ff-minus
0bf4 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bf6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0bf8 : 28              >            plp         ;restore status
                        
0bf9 : 08                       php
0bfa : c8                       iny             ;01
0bfb : 98                       tya
0bfc : 28                       plp
0bfd : aa                       tax
                                tst_x 1,$ff-minus-zero
0bfe : 08              >            php         ;save flags
0bff : e001            >            cpx #1     ;test result
                       >            trap_ne
0c01 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c03 : 68              >            pla         ;load status
0c04 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c05 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c07 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c09 : 28              >            plp         ;restore status
                        
                                load_flag 0
0c0a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0c0c : 48                       pha
0c0d : a900                     lda #0          ;preset status
0c0f : 98                       tya
0c10 : 28                       plp
0c11 : aa                       tax
                                tst_x 1,0
0c12 : 08              >            php         ;save flags
0c13 : e001            >            cpx #1     ;test result
                       >            trap_ne
0c15 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c17 : 68              >            pla         ;load status
0c18 : 48              >            pha
                       >            cmp_flag 0
0c19 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c1b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c1d : 28              >            plp         ;restore status
                        
0c1e : 08                       php
0c1f : 88                       dey             ;00
0c20 : 98                       tya
0c21 : 28                       plp
0c22 : aa                       tax
                                tst_x 0,zero
0c23 : 08              >            php         ;save flags
0c24 : e000            >            cpx #0     ;test result
                       >            trap_ne
0c26 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c28 : 68              >            pla         ;load status
0c29 : 48              >            pha
                       >            cmp_flag zero
0c2a : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c2c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c2e : 28              >            plp         ;restore status
                        
0c2f : 08                       php
0c30 : 88                       dey             ;ff
0c31 : 98                       tya
0c32 : 28                       plp
0c33 : aa                       tax
                                tst_x $ff,minus
0c34 : 08              >            php         ;save flags
0c35 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0c37 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c39 : 68              >            pla         ;load status
0c3a : 48              >            pha
                       >            cmp_flag minus
0c3b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0c3f : 28              >            plp         ;restore status
                        
                                next_test
0c40 : ad0002          >            lda test_case   ;previous test
0c43 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0c45 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0c47 : a90e            >            lda #test_num   ;*** next tests' number
0c49 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0c4c : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0c4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c50 : 48              >            pha         ;use stack to load status
0c51 : 28              >            plp
                        
0c52 : 9a                       txs
0c53 : 08                       php
0c54 : ad0101                   lda $101
                                cmp_flag $ff
0c57 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0c59 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0c5b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c5d : 48              >            pha         ;use stack to load status
0c5e : 28              >            plp
                        
0c5f : 9a                       txs
0c60 : 08                       php
0c61 : ad0101                   lda $101
                                cmp_flag 0
0c64 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0c66 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0c68 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0c69 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c6b : 48              >            pha         ;use stack to load status
0c6c : 28              >            plp
                        
0c6d : 9a                       txs
0c6e : 08                       php
0c6f : ad0001                   lda $100
                                cmp_flag $ff
0c72 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0c74 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0c76 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c78 : 48              >            pha         ;use stack to load status
0c79 : 28              >            plp
                        
0c7a : 9a                       txs
0c7b : 08                       php
0c7c : ad0001                   lda $100
                                cmp_flag 0
0c7f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0c81 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0c83 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0c84 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c86 : 48              >            pha         ;use stack to load status
0c87 : 28              >            plp
                        
0c88 : 9a                       txs
0c89 : 08                       php
0c8a : adff01                   lda $1ff
                                cmp_flag $ff
0c8d : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0c8f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0c91 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c93 : 48              >            pha         ;use stack to load status
0c94 : 28              >            plp
                        
0c95 : 9a                       txs
0c96 : 08                       php
0c97 : adff01                   lda $1ff
                                cmp_flag 0
0c9a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
0c9c : a201                     ldx #1
0c9e : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0c9f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ca1 : 48              >            pha         ;use stack to load status
0ca2 : 28              >            plp
                        
0ca3 : ba                       tsx             ;clears Z, N
0ca4 : 08                       php             ;sp=00
0ca5 : e001                     cpx #1
                                trap_ne
0ca7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ca9 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0cac : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0cae : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0cb0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cb2 : 48              >            pha         ;use stack to load status
0cb3 : 28              >            plp
                        
0cb4 : ba                       tsx             ;clears N, sets Z
0cb5 : 08                       php             ;sp=ff
0cb6 : e000                     cpx #0
                                trap_ne
0cb8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0cba : ad0001                   lda $100
                                cmp_flag $ff-minus
0cbd : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0cbf : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0cc1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cc3 : 48              >            pha         ;use stack to load status
0cc4 : 28              >            plp
                        
0cc5 : ba                       tsx             ;clears N, sets Z
0cc6 : 08                       php             ;sp=fe
0cc7 : e0ff                     cpx #$ff
                                trap_ne
0cc9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ccb : adff01                   lda $1ff
                                cmp_flag $ff-zero
0cce : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0cd0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
0cd2 : a201                     ldx #1
0cd4 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0cd5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0cd7 : 48              >            pha         ;use stack to load status
0cd8 : 28              >            plp
                        
0cd9 : ba                       tsx             ;clears Z, N
0cda : 08                       php             ;sp=00
0cdb : e001                     cpx #1
                                trap_ne
0cdd : d0fe            >        bne *         ;failed not equal (non zero)
                        
0cdf : ad0101                   lda $101
                                cmp_flag 0
0ce2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0ce4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0ce6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ce8 : 48              >            pha         ;use stack to load status
0ce9 : 28              >            plp
                        
0cea : ba                       tsx             ;clears N, sets Z
0ceb : 08                       php             ;sp=ff
0cec : e000                     cpx #0
                                trap_ne
0cee : d0fe            >        bne *         ;failed not equal (non zero)
                        
0cf0 : ad0001                   lda $100
                                cmp_flag zero
0cf3 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0cf5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0cf7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0cf9 : 48              >            pha         ;use stack to load status
0cfa : 28              >            plp
                        
0cfb : ba                       tsx             ;clears N, sets Z
0cfc : 08                       php             ;sp=fe
0cfd : e0ff                     cpx #$ff
                                trap_ne
0cff : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d01 : adff01                   lda $1ff
                                cmp_flag minus
0d04 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0d06 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d08 : 68                       pla             ;sp=ff
                                next_test
0d09 : ad0002          >            lda test_case   ;previous test
0d0c : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d0e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0d10 : a90f            >            lda #test_num   ;*** next tests' number
0d12 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0d15 : a003                     ldy #3
0d17 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0d17 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d19 : 48              >            pha         ;use stack to load status
0d1a : 28              >            plp
                        
0d1b : b60b                     ldx zp1,y
0d1d : 08                       php         ;test stores do not alter flags
0d1e : 8a                       txa
0d1f : 49c3                     eor #$c3
0d21 : 28                       plp
0d22 : 990302                   sta abst,y
0d25 : 08                       php         ;flags after load/store sequence
0d26 : 49c3                     eor #$c3
0d28 : d91802                   cmp abs1,y  ;test result
                                trap_ne
0d2b : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d2d : 68                       pla         ;load status
                                eor_flag 0
0d2e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0d30 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0d33 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d35 : 88                       dey
0d36 : 10df                     bpl tldx                  
                        
0d38 : a003                     ldy #3
0d3a :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0d3a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d3c : 48              >            pha         ;use stack to load status
0d3d : 28              >            plp
                        
0d3e : b60b                     ldx zp1,y
0d40 : 08                       php         ;test stores do not alter flags
0d41 : 8a                       txa
0d42 : 49c3                     eor #$c3
0d44 : 28                       plp
0d45 : 990302                   sta abst,y
0d48 : 08                       php         ;flags after load/store sequence
0d49 : 49c3                     eor #$c3
0d4b : d91802                   cmp abs1,y  ;test result
                                trap_ne
0d4e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d50 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0d51 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0d53 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0d56 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d58 : 88                       dey
0d59 : 10df                     bpl tldx1                  
                        
0d5b : a003                     ldy #3
0d5d :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0d5d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d5f : 48              >            pha         ;use stack to load status
0d60 : 28              >            plp
                        
0d61 : be1802                   ldx abs1,y
0d64 : 08                       php         ;test stores do not alter flags
0d65 : 8a                       txa
0d66 : 49c3                     eor #$c3
0d68 : aa                       tax
0d69 : 28                       plp
0d6a : 9602                     stx zpt,y
0d6c : 08                       php         ;flags after load/store sequence
0d6d : 49c3                     eor #$c3
0d6f : d90b00                   cmp zp1,y   ;test result
                                trap_ne
0d72 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d74 : 68                       pla         ;load status
                                eor_flag 0
0d75 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0d77 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0d7a : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d7c : 88                       dey
0d7d : 10de                     bpl tldx2                  
                        
0d7f : a003                     ldy #3
0d81 :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0d81 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d83 : 48              >            pha         ;use stack to load status
0d84 : 28              >            plp
                        
0d85 : be1802                   ldx abs1,y
0d88 : 08                       php         ;test stores do not alter flags
0d89 : 8a                       txa
0d8a : 49c3                     eor #$c3
0d8c : aa                       tax
0d8d : 28                       plp
0d8e : 9602                     stx zpt,y
0d90 : 08                       php         ;flags after load/store sequence
0d91 : 49c3                     eor #$c3
0d93 : d90b00                   cmp zp1,y   ;test result
                                trap_ne
0d96 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0d98 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0d99 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0d9b : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0d9e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0da0 : 88                       dey
0da1 : 10de                     bpl tldx3
                                
0da3 : a003                     ldy #3      ;testing store result
0da5 : a200                     ldx #0
0da7 : b90200           tstx    lda zpt,y
0daa : 49c3                     eor #$c3
0dac : d90b00                   cmp zp1,y
                                trap_ne     ;store to zp data
0daf : d0fe            >        bne *         ;failed not equal (non zero)
                        
0db1 : 9602                     stx zpt,y   ;clear                
0db3 : b90302                   lda abst,y
0db6 : 49c3                     eor #$c3
0db8 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
0dbb : d0fe            >        bne *         ;failed not equal (non zero)
                        
0dbd : 8a                       txa
0dbe : 990302                   sta abst,y  ;clear                
0dc1 : 88                       dey
0dc2 : 10e3                     bpl tstx
                                next_test
0dc4 : ad0002          >            lda test_case   ;previous test
0dc7 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0dc9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0dcb : a910            >            lda #test_num   ;*** next tests' number
0dcd : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0dd0 : a0fd                     ldy #3+$fa
0dd2 : b611             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0dd4 : 8a                       txa
0dd5 : 990901                   sta abst-$fa,y      ;no STX abs,y!
0dd8 : 88                       dey
0dd9 : c0fa                     cpy #$fa
0ddb : b0f5                     bcs tldx4                  
0ddd : a0fd                     ldy #3+$fa
0ddf : be1e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0de2 : 9608                     stx zpt-$fa&$ff,y
0de4 : 88                       dey
0de5 : c0fa                     cpy #$fa
0de7 : b0f6                     bcs tldx5                  
0de9 : a003                     ldy #3      ;testing wraparound result
0deb : a200                     ldx #0
0ded : b90200           tstx1   lda zpt,y
0df0 : d90b00                   cmp zp1,y
                                trap_ne     ;store to zp data
0df3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0df5 : 9602                     stx zpt,y   ;clear                
0df7 : b90302                   lda abst,y
0dfa : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
0dfd : d0fe            >        bne *         ;failed not equal (non zero)
                        
0dff : 8a                       txa
0e00 : 990302                   sta abst,y  ;clear                
0e03 : 88                       dey
0e04 : 10e7                     bpl tstx1
                                next_test
0e06 : ad0002          >            lda test_case   ;previous test
0e09 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e0b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0e0d : a911            >            lda #test_num   ;*** next tests' number
0e0f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0e12 : a203                     ldx #3
0e14 :                  tldy    
                                set_stat 0
                       >            load_flag 0
0e14 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e16 : 48              >            pha         ;use stack to load status
0e17 : 28              >            plp
                        
0e18 : b40b                     ldy zp1,x
0e1a : 08                       php         ;test stores do not alter flags
0e1b : 98                       tya
0e1c : 49c3                     eor #$c3
0e1e : 28                       plp
0e1f : 9d0302                   sta abst,x
0e22 : 08                       php         ;flags after load/store sequence
0e23 : 49c3                     eor #$c3
0e25 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
0e28 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e2a : 68                       pla         ;load status
                                eor_flag 0
0e2b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e2d : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0e30 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e32 : ca                       dex
0e33 : 10df                     bpl tldy                  
                        
0e35 : a203                     ldx #3
0e37 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0e37 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e39 : 48              >            pha         ;use stack to load status
0e3a : 28              >            plp
                        
0e3b : b40b                     ldy zp1,x
0e3d : 08                       php         ;test stores do not alter flags
0e3e : 98                       tya
0e3f : 49c3                     eor #$c3
0e41 : 28                       plp
0e42 : 9d0302                   sta abst,x
0e45 : 08                       php         ;flags after load/store sequence
0e46 : 49c3                     eor #$c3
0e48 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
0e4b : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e4d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e4e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e50 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0e53 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e55 : ca                       dex
0e56 : 10df                     bpl tldy1                  
                        
0e58 : a203                     ldx #3
0e5a :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0e5a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e5c : 48              >            pha         ;use stack to load status
0e5d : 28              >            plp
                        
0e5e : bc1802                   ldy abs1,x
0e61 : 08                       php         ;test stores do not alter flags
0e62 : 98                       tya
0e63 : 49c3                     eor #$c3
0e65 : a8                       tay
0e66 : 28                       plp
0e67 : 9402                     sty zpt,x
0e69 : 08                       php         ;flags after load/store sequence
0e6a : 49c3                     eor #$c3
0e6c : d50b                     cmp zp1,x   ;test result
                                trap_ne
0e6e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e70 : 68                       pla         ;load status
                                eor_flag 0
0e71 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e73 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0e76 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e78 : ca                       dex
0e79 : 10df                     bpl tldy2                  
                        
0e7b : a203                     ldx #3
0e7d :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0e7d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e7f : 48              >            pha         ;use stack to load status
0e80 : 28              >            plp
                        
0e81 : bc1802                   ldy abs1,x
0e84 : 08                       php         ;test stores do not alter flags
0e85 : 98                       tya
0e86 : 49c3                     eor #$c3
0e88 : a8                       tay
0e89 : 28                       plp
0e8a : 9402                     sty zpt,x
0e8c : 08                       php         ;flags after load/store sequence
0e8d : 49c3                     eor #$c3
0e8f : d50b                     cmp zp1,x   ;test result
                                trap_ne
0e91 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e93 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e94 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0e96 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0e99 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0e9b : ca                       dex
0e9c : 10df                     bpl tldy3
                        
0e9e : a203                     ldx #3      ;testing store result
0ea0 : a000                     ldy #0
0ea2 : b502             tsty    lda zpt,x
0ea4 : 49c3                     eor #$c3
0ea6 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0ea8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0eaa : 9402                     sty zpt,x   ;clear                
0eac : bd0302                   lda abst,x
0eaf : 49c3                     eor #$c3
0eb1 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0eb4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0eb6 : 8a                       txa
0eb7 : 9d0302                   sta abst,x  ;clear                
0eba : ca                       dex
0ebb : 10e5                     bpl tsty
                                next_test
0ebd : ad0002          >            lda test_case   ;previous test
0ec0 : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ec2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
0ec4 : a912            >            lda #test_num   ;*** next tests' number
0ec6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
0ec9 : a2fd                     ldx #3+$fa
0ecb : b411             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
0ecd : 98                       tya
0ece : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
0ed1 : ca                       dex
0ed2 : e0fa                     cpx #$fa
0ed4 : b0f5                     bcs tldy4                  
0ed6 : a2fd                     ldx #3+$fa
0ed8 : bc1e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
0edb : 9408                     sty zpt-$fa&$ff,x
0edd : ca                       dex
0ede : e0fa                     cpx #$fa
0ee0 : b0f6                     bcs tldy5                  
0ee2 : a203                     ldx #3      ;testing wraparound result
0ee4 : a000                     ldy #0
0ee6 : b502             tsty1   lda zpt,x
0ee8 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0eea : d0fe            >        bne *         ;failed not equal (non zero)
                        
0eec : 9402                     sty zpt,x   ;clear                
0eee : bd0302                   lda abst,x
0ef1 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0ef4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ef6 : 8a                       txa
0ef7 : 9d0302                   sta abst,x  ;clear                
0efa : ca                       dex
0efb : 10e9                     bpl tsty1
                                next_test
0efd : ad0002          >            lda test_case   ;previous test
0f00 : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f02 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
0f04 : a913            >            lda #test_num   ;*** next tests' number
0f06 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
0f09 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
0f0b : 48              >            pha         ;use stack to load status
0f0c : 28              >            plp
                        
0f0d : a60b                     ldx zp1
0f0f : 08                       php         ;test stores do not alter flags
0f10 : 8a                       txa
0f11 : 49c3                     eor #$c3
0f13 : aa                       tax
0f14 : 28                       plp
0f15 : 8e0302                   stx abst
0f18 : 08                       php         ;flags after load/store sequence
0f19 : 49c3                     eor #$c3
0f1b : aa                       tax
0f1c : e0c3                     cpx #$c3    ;test result
                                trap_ne
0f1e : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f20 : 68                       pla         ;load status
                                eor_flag 0
0f21 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f23 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
0f26 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0f28 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f2a : 48              >            pha         ;use stack to load status
0f2b : 28              >            plp
                        
0f2c : a60c                     ldx zp1+1
0f2e : 08                       php         ;test stores do not alter flags
0f2f : 8a                       txa
0f30 : 49c3                     eor #$c3
0f32 : aa                       tax
0f33 : 28                       plp
0f34 : 8e0402                   stx abst+1
0f37 : 08                       php         ;flags after load/store sequence
0f38 : 49c3                     eor #$c3
0f3a : aa                       tax
0f3b : e082                     cpx #$82    ;test result
                                trap_ne
0f3d : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f3f : 68                       pla         ;load status
                                eor_flag 0
0f40 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f42 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
0f45 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0f47 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f49 : 48              >            pha         ;use stack to load status
0f4a : 28              >            plp
                        
0f4b : a60d                     ldx zp1+2
0f4d : 08                       php         ;test stores do not alter flags
0f4e : 8a                       txa
0f4f : 49c3                     eor #$c3
0f51 : aa                       tax
0f52 : 28                       plp
0f53 : 8e0502                   stx abst+2
0f56 : 08                       php         ;flags after load/store sequence
0f57 : 49c3                     eor #$c3
0f59 : aa                       tax
0f5a : e041                     cpx #$41    ;test result
                                trap_ne
0f5c : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f5e : 68                       pla         ;load status
                                eor_flag 0
0f5f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f61 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
0f64 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0f66 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f68 : 48              >            pha         ;use stack to load status
0f69 : 28              >            plp
                        
0f6a : a60e                     ldx zp1+3
0f6c : 08                       php         ;test stores do not alter flags
0f6d : 8a                       txa
0f6e : 49c3                     eor #$c3
0f70 : aa                       tax
0f71 : 28                       plp
0f72 : 8e0602                   stx abst+3
0f75 : 08                       php         ;flags after load/store sequence
0f76 : 49c3                     eor #$c3
0f78 : aa                       tax
0f79 : e000                     cpx #0      ;test result
                                trap_ne
0f7b : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f7d : 68                       pla         ;load status
                                eor_flag 0
0f7e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f80 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
0f83 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
0f85 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f87 : 48              >            pha         ;use stack to load status
0f88 : 28              >            plp
                        
0f89 : a60b                     ldx zp1  
0f8b : 08                       php         ;test stores do not alter flags
0f8c : 8a                       txa
0f8d : 49c3                     eor #$c3
0f8f : aa                       tax
0f90 : 28                       plp
0f91 : 8e0302                   stx abst  
0f94 : 08                       php         ;flags after load/store sequence
0f95 : 49c3                     eor #$c3
0f97 : aa                       tax
0f98 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
0f9a : d0fe            >        bne *         ;failed not equal (non zero)
                        
0f9c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f9d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f9f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
0fa2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0fa4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fa6 : 48              >            pha         ;use stack to load status
0fa7 : 28              >            plp
                        
0fa8 : a60c                     ldx zp1+1
0faa : 08                       php         ;test stores do not alter flags
0fab : 8a                       txa
0fac : 49c3                     eor #$c3
0fae : aa                       tax
0faf : 28                       plp
0fb0 : 8e0402                   stx abst+1
0fb3 : 08                       php         ;flags after load/store sequence
0fb4 : 49c3                     eor #$c3
0fb6 : aa                       tax
0fb7 : e082                     cpx #$82    ;test result
                                trap_ne
0fb9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0fbb : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fbc : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0fbe : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
0fc1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0fc3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fc5 : 48              >            pha         ;use stack to load status
0fc6 : 28              >            plp
                        
0fc7 : a60d                     ldx zp1+2
0fc9 : 08                       php         ;test stores do not alter flags
0fca : 8a                       txa
0fcb : 49c3                     eor #$c3
0fcd : aa                       tax
0fce : 28                       plp
0fcf : 8e0502                   stx abst+2
0fd2 : 08                       php         ;flags after load/store sequence
0fd3 : 49c3                     eor #$c3
0fd5 : aa                       tax
0fd6 : e041                     cpx #$41    ;test result
                                trap_ne     ;
0fd8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0fda : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fdb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0fdd : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
0fe0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0fe2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fe4 : 48              >            pha         ;use stack to load status
0fe5 : 28              >            plp
                        
0fe6 : a60e                     ldx zp1+3
0fe8 : 08                       php         ;test stores do not alter flags
0fe9 : 8a                       txa
0fea : 49c3                     eor #$c3
0fec : aa                       tax
0fed : 28                       plp
0fee : 8e0602                   stx abst+3
0ff1 : 08                       php         ;flags after load/store sequence
0ff2 : 49c3                     eor #$c3
0ff4 : aa                       tax
0ff5 : e000                     cpx #0      ;test result
                                trap_ne
0ff7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
0ff9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0ffa : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0ffc : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
0fff : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
1001 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1003 : 48              >            pha         ;use stack to load status
1004 : 28              >            plp
                        
1005 : ae1802                   ldx abs1  
1008 : 08                       php         ;test stores do not alter flags
1009 : 8a                       txa
100a : 49c3                     eor #$c3
100c : aa                       tax
100d : 28                       plp
100e : 8602                     stx zpt  
1010 : 08                       php         ;flags after load/store sequence
1011 : 49c3                     eor #$c3
1013 : c50b                     cmp zp1     ;test result
                                trap_ne
1015 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1017 : 68                       pla         ;load status
                                eor_flag 0
1018 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
101a : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
101d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
101f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1021 : 48              >            pha         ;use stack to load status
1022 : 28              >            plp
                        
1023 : ae1902                   ldx abs1+1
1026 : 08                       php         ;test stores do not alter flags
1027 : 8a                       txa
1028 : 49c3                     eor #$c3
102a : aa                       tax
102b : 28                       plp
102c : 8603                     stx zpt+1
102e : 08                       php         ;flags after load/store sequence
102f : 49c3                     eor #$c3
1031 : c50c                     cmp zp1+1   ;test result
                                trap_ne
1033 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1035 : 68                       pla         ;load status
                                eor_flag 0
1036 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1038 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
103b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
103d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
103f : 48              >            pha         ;use stack to load status
1040 : 28              >            plp
                        
1041 : ae1a02                   ldx abs1+2
1044 : 08                       php         ;test stores do not alter flags
1045 : 8a                       txa
1046 : 49c3                     eor #$c3
1048 : aa                       tax
1049 : 28                       plp
104a : 8604                     stx zpt+2
104c : 08                       php         ;flags after load/store sequence
104d : 49c3                     eor #$c3
104f : c50d                     cmp zp1+2   ;test result
                                trap_ne
1051 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1053 : 68                       pla         ;load status
                                eor_flag 0
1054 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1056 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1059 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
105b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
105d : 48              >            pha         ;use stack to load status
105e : 28              >            plp
                        
105f : ae1b02                   ldx abs1+3
1062 : 08                       php         ;test stores do not alter flags
1063 : 8a                       txa
1064 : 49c3                     eor #$c3
1066 : aa                       tax
1067 : 28                       plp
1068 : 8605                     stx zpt+3
106a : 08                       php         ;flags after load/store sequence
106b : 49c3                     eor #$c3
106d : c50e                     cmp zp1+3   ;test result
                                trap_ne
106f : d0fe            >        bne *         ;failed not equal (non zero)
                        
1071 : 68                       pla         ;load status
                                eor_flag 0
1072 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1074 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1077 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1079 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
107b : 48              >            pha         ;use stack to load status
107c : 28              >            plp
                        
107d : ae1802                   ldx abs1  
1080 : 08                       php         ;test stores do not alter flags
1081 : 8a                       txa
1082 : 49c3                     eor #$c3
1084 : aa                       tax
1085 : 28                       plp
1086 : 8602                     stx zpt  
1088 : 08                       php         ;flags after load/store sequence
1089 : 49c3                     eor #$c3
108b : aa                       tax
108c : e40b                     cpx zp1     ;test result
                                trap_ne
108e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1090 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1091 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1093 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1096 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1098 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
109a : 48              >            pha         ;use stack to load status
109b : 28              >            plp
                        
109c : ae1902                   ldx abs1+1
109f : 08                       php         ;test stores do not alter flags
10a0 : 8a                       txa
10a1 : 49c3                     eor #$c3
10a3 : aa                       tax
10a4 : 28                       plp
10a5 : 8603                     stx zpt+1
10a7 : 08                       php         ;flags after load/store sequence
10a8 : 49c3                     eor #$c3
10aa : aa                       tax
10ab : e40c                     cpx zp1+1   ;test result
                                trap_ne
10ad : d0fe            >        bne *         ;failed not equal (non zero)
                        
10af : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10b0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10b2 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
10b5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10b7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10b9 : 48              >            pha         ;use stack to load status
10ba : 28              >            plp
                        
10bb : ae1a02                   ldx abs1+2
10be : 08                       php         ;test stores do not alter flags
10bf : 8a                       txa
10c0 : 49c3                     eor #$c3
10c2 : aa                       tax
10c3 : 28                       plp
10c4 : 8604                     stx zpt+2
10c6 : 08                       php         ;flags after load/store sequence
10c7 : 49c3                     eor #$c3
10c9 : aa                       tax
10ca : e40d                     cpx zp1+2   ;test result
                                trap_ne
10cc : d0fe            >        bne *         ;failed not equal (non zero)
                        
10ce : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10cf : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10d1 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
10d4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10d6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10d8 : 48              >            pha         ;use stack to load status
10d9 : 28              >            plp
                        
10da : ae1b02                   ldx abs1+3
10dd : 08                       php         ;test stores do not alter flags
10de : 8a                       txa
10df : 49c3                     eor #$c3
10e1 : aa                       tax
10e2 : 28                       plp
10e3 : 8605                     stx zpt+3
10e5 : 08                       php         ;flags after load/store sequence
10e6 : 49c3                     eor #$c3
10e8 : aa                       tax
10e9 : e40e                     cpx zp1+3   ;test result
                                trap_ne
10eb : d0fe            >        bne *         ;failed not equal (non zero)
                        
10ed : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10ee : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10f0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
10f3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
10f5 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
10f7 : 48              >            pha         ;use stack to load status
10f8 : 28              >            plp
                        
10f9 : a2c3                     ldx #$c3
10fb : 08                       php
10fc : ec1802                   cpx abs1    ;test result
                                trap_ne
10ff : d0fe            >        bne *         ;failed not equal (non zero)
                        
1101 : 68                       pla         ;load status
                                eor_flag 0
1102 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1104 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1107 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1109 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
110b : 48              >            pha         ;use stack to load status
110c : 28              >            plp
                        
110d : a282                     ldx #$82
110f : 08                       php
1110 : ec1902                   cpx abs1+1  ;test result
                                trap_ne
1113 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1115 : 68                       pla         ;load status
                                eor_flag 0
1116 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1118 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
111b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
111d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
111f : 48              >            pha         ;use stack to load status
1120 : 28              >            plp
                        
1121 : a241                     ldx #$41
1123 : 08                       php
1124 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
1127 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1129 : 68                       pla         ;load status
                                eor_flag 0
112a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
112c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
112f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1131 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1133 : 48              >            pha         ;use stack to load status
1134 : 28              >            plp
                        
1135 : a200                     ldx #0
1137 : 08                       php
1138 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
113b : d0fe            >        bne *         ;failed not equal (non zero)
                        
113d : 68                       pla         ;load status
                                eor_flag 0
113e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1140 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1143 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1145 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1147 : 48              >            pha         ;use stack to load status
1148 : 28              >            plp
                        
1149 : a2c3                     ldx #$c3  
114b : 08                       php
114c : ec1802                   cpx abs1    ;test result
                                trap_ne
114f : d0fe            >        bne *         ;failed not equal (non zero)
                        
1151 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1152 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1154 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1157 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1159 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
115b : 48              >            pha         ;use stack to load status
115c : 28              >            plp
                        
115d : a282                     ldx #$82
115f : 08                       php
1160 : ec1902                   cpx abs1+1  ;test result
                                trap_ne
1163 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1165 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1166 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1168 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
116b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
116d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
116f : 48              >            pha         ;use stack to load status
1170 : 28              >            plp
                        
1171 : a241                     ldx #$41
1173 : 08                       php
1174 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
1177 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1179 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
117a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
117c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
117f : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1181 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1183 : 48              >            pha         ;use stack to load status
1184 : 28              >            plp
                        
1185 : a200                     ldx #0
1187 : 08                       php
1188 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
118b : d0fe            >        bne *         ;failed not equal (non zero)
                        
118d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
118e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1190 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1193 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
1195 : a200                     ldx #0
1197 : a502                     lda zpt  
1199 : 49c3                     eor #$c3
119b : c50b                     cmp zp1  
                                trap_ne     ;store to zp data
119d : d0fe            >        bne *         ;failed not equal (non zero)
                        
119f : 8602                     stx zpt     ;clear                
11a1 : ad0302                   lda abst  
11a4 : 49c3                     eor #$c3
11a6 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
11a9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11ab : 8e0302                   stx abst    ;clear                
11ae : a503                     lda zpt+1
11b0 : 49c3                     eor #$c3
11b2 : c50c                     cmp zp1+1
                                trap_ne     ;store to zp data
11b4 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11b6 : 8603                     stx zpt+1   ;clear                
11b8 : ad0402                   lda abst+1
11bb : 49c3                     eor #$c3
11bd : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
11c0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11c2 : 8e0402                   stx abst+1  ;clear                
11c5 : a504                     lda zpt+2
11c7 : 49c3                     eor #$c3
11c9 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp data
11cb : d0fe            >        bne *         ;failed not equal (non zero)
                        
11cd : 8604                     stx zpt+2   ;clear                
11cf : ad0502                   lda abst+2
11d2 : 49c3                     eor #$c3
11d4 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
11d7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11d9 : 8e0502                   stx abst+2  ;clear                
11dc : a505                     lda zpt+3
11de : 49c3                     eor #$c3
11e0 : c50e                     cmp zp1+3
                                trap_ne     ;store to zp data
11e2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
11e4 : 8605                     stx zpt+3   ;clear                
11e6 : ad0602                   lda abst+3
11e9 : 49c3                     eor #$c3
11eb : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
11ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
11f0 : 8e0602                   stx abst+3  ;clear                
                                next_test
11f3 : ad0002          >            lda test_case   ;previous test
11f6 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
11f8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
11fa : a914            >            lda #test_num   ;*** next tests' number
11fc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
11ff : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1201 : 48              >            pha         ;use stack to load status
1202 : 28              >            plp
                        
1203 : a40b                     ldy zp1  
1205 : 08                       php         ;test stores do not alter flags
1206 : 98                       tya
1207 : 49c3                     eor #$c3
1209 : a8                       tay
120a : 28                       plp
120b : 8c0302                   sty abst  
120e : 08                       php         ;flags after load/store sequence
120f : 49c3                     eor #$c3
1211 : a8                       tay
1212 : c0c3                     cpy #$c3    ;test result
                                trap_ne
1214 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1216 : 68                       pla         ;load status
                                eor_flag 0
1217 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1219 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
121c : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
121e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1220 : 48              >            pha         ;use stack to load status
1221 : 28              >            plp
                        
1222 : a40c                     ldy zp1+1
1224 : 08                       php         ;test stores do not alter flags
1225 : 98                       tya
1226 : 49c3                     eor #$c3
1228 : a8                       tay
1229 : 28                       plp
122a : 8c0402                   sty abst+1
122d : 08                       php         ;flags after load/store sequence
122e : 49c3                     eor #$c3
1230 : a8                       tay
1231 : c082                     cpy #$82    ;test result
                                trap_ne
1233 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1235 : 68                       pla         ;load status
                                eor_flag 0
1236 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1238 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
123b : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
123d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
123f : 48              >            pha         ;use stack to load status
1240 : 28              >            plp
                        
1241 : a40d                     ldy zp1+2
1243 : 08                       php         ;test stores do not alter flags
1244 : 98                       tya
1245 : 49c3                     eor #$c3
1247 : a8                       tay
1248 : 28                       plp
1249 : 8c0502                   sty abst+2
124c : 08                       php         ;flags after load/store sequence
124d : 49c3                     eor #$c3
124f : a8                       tay
1250 : c041                     cpy #$41    ;test result
                                trap_ne
1252 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1254 : 68                       pla         ;load status
                                eor_flag 0
1255 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1257 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
125a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
125c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
125e : 48              >            pha         ;use stack to load status
125f : 28              >            plp
                        
1260 : a40e                     ldy zp1+3
1262 : 08                       php         ;test stores do not alter flags
1263 : 98                       tya
1264 : 49c3                     eor #$c3
1266 : a8                       tay
1267 : 28                       plp
1268 : 8c0602                   sty abst+3
126b : 08                       php         ;flags after load/store sequence
126c : 49c3                     eor #$c3
126e : a8                       tay
126f : c000                     cpy #0      ;test result
                                trap_ne
1271 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1273 : 68                       pla         ;load status
                                eor_flag 0
1274 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1276 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1279 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
127b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
127d : 48              >            pha         ;use stack to load status
127e : 28              >            plp
                        
127f : a40b                     ldy zp1  
1281 : 08                       php         ;test stores do not alter flags
1282 : 98                       tya
1283 : 49c3                     eor #$c3
1285 : a8                       tay
1286 : 28                       plp
1287 : 8c0302                   sty abst  
128a : 08                       php         ;flags after load/store sequence
128b : 49c3                     eor #$c3
128d : a8                       tay
128e : c0c3                     cpy #$c3    ;test result
                                trap_ne
1290 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1292 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1293 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1295 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1298 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
129a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
129c : 48              >            pha         ;use stack to load status
129d : 28              >            plp
                        
129e : a40c                     ldy zp1+1
12a0 : 08                       php         ;test stores do not alter flags
12a1 : 98                       tya
12a2 : 49c3                     eor #$c3
12a4 : a8                       tay
12a5 : 28                       plp
12a6 : 8c0402                   sty abst+1
12a9 : 08                       php         ;flags after load/store sequence
12aa : 49c3                     eor #$c3
12ac : a8                       tay
12ad : c082                     cpy #$82   ;test result
                                trap_ne
12af : d0fe            >        bne *         ;failed not equal (non zero)
                        
12b1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12b2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12b4 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
12b7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12b9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12bb : 48              >            pha         ;use stack to load status
12bc : 28              >            plp
                        
12bd : a40d                     ldy zp1+2
12bf : 08                       php         ;test stores do not alter flags
12c0 : 98                       tya
12c1 : 49c3                     eor #$c3
12c3 : a8                       tay
12c4 : 28                       plp
12c5 : 8c0502                   sty abst+2
12c8 : 08                       php         ;flags after load/store sequence
12c9 : 49c3                     eor #$c3
12cb : a8                       tay
12cc : c041                     cpy #$41    ;test result
                                trap_ne
12ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
12d0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12d1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12d3 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
12d6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12d8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12da : 48              >            pha         ;use stack to load status
12db : 28              >            plp
                        
12dc : a40e                     ldy zp1+3
12de : 08                       php         ;test stores do not alter flags
12df : 98                       tya
12e0 : 49c3                     eor #$c3
12e2 : a8                       tay
12e3 : 28                       plp
12e4 : 8c0602                   sty abst+3
12e7 : 08                       php         ;flags after load/store sequence
12e8 : 49c3                     eor #$c3
12ea : a8                       tay
12eb : c000                     cpy #0      ;test result
                                trap_ne
12ed : d0fe            >        bne *         ;failed not equal (non zero)
                        
12ef : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12f0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12f2 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
12f5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
12f7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
12f9 : 48              >            pha         ;use stack to load status
12fa : 28              >            plp
                        
12fb : ac1802                   ldy abs1  
12fe : 08                       php         ;test stores do not alter flags
12ff : 98                       tya
1300 : 49c3                     eor #$c3
1302 : a8                       tay
1303 : 28                       plp
1304 : 8402                     sty zpt  
1306 : 08                       php         ;flags after load/store sequence
1307 : 49c3                     eor #$c3
1309 : a8                       tay
130a : c40b                     cpy zp1     ;test result
                                trap_ne
130c : d0fe            >        bne *         ;failed not equal (non zero)
                        
130e : 68                       pla         ;load status
                                eor_flag 0
130f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1311 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1314 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1316 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1318 : 48              >            pha         ;use stack to load status
1319 : 28              >            plp
                        
131a : ac1902                   ldy abs1+1
131d : 08                       php         ;test stores do not alter flags
131e : 98                       tya
131f : 49c3                     eor #$c3
1321 : a8                       tay
1322 : 28                       plp
1323 : 8403                     sty zpt+1
1325 : 08                       php         ;flags after load/store sequence
1326 : 49c3                     eor #$c3
1328 : a8                       tay
1329 : c40c                     cpy zp1+1   ;test result
                                trap_ne
132b : d0fe            >        bne *         ;failed not equal (non zero)
                        
132d : 68                       pla         ;load status
                                eor_flag 0
132e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1330 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1333 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1335 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1337 : 48              >            pha         ;use stack to load status
1338 : 28              >            plp
                        
1339 : ac1a02                   ldy abs1+2
133c : 08                       php         ;test stores do not alter flags
133d : 98                       tya
133e : 49c3                     eor #$c3
1340 : a8                       tay
1341 : 28                       plp
1342 : 8404                     sty zpt+2
1344 : 08                       php         ;flags after load/store sequence
1345 : 49c3                     eor #$c3
1347 : a8                       tay
1348 : c40d                     cpy zp1+2   ;test result
                                trap_ne
134a : d0fe            >        bne *         ;failed not equal (non zero)
                        
134c : 68                       pla         ;load status
                                eor_flag 0
134d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
134f : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1352 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1354 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1356 : 48              >            pha         ;use stack to load status
1357 : 28              >            plp
                        
1358 : ac1b02                   ldy abs1+3
135b : 08                       php         ;test stores do not alter flags
135c : 98                       tya
135d : 49c3                     eor #$c3
135f : a8                       tay
1360 : 28                       plp
1361 : 8405                     sty zpt+3
1363 : 08                       php         ;flags after load/store sequence
1364 : 49c3                     eor #$c3
1366 : a8                       tay
1367 : c40e                     cpy zp1+3   ;test result
                                trap_ne
1369 : d0fe            >        bne *         ;failed not equal (non zero)
                        
136b : 68                       pla         ;load status
                                eor_flag 0
136c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
136e : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1371 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1373 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1375 : 48              >            pha         ;use stack to load status
1376 : 28              >            plp
                        
1377 : ac1802                   ldy abs1  
137a : 08                       php         ;test stores do not alter flags
137b : 98                       tya
137c : 49c3                     eor #$c3
137e : a8                       tay
137f : 28                       plp
1380 : 8402                     sty zpt  
1382 : 08                       php         ;flags after load/store sequence
1383 : 49c3                     eor #$c3
1385 : a8                       tay
1386 : c50b                     cmp zp1     ;test result
                                trap_ne
1388 : d0fe            >        bne *         ;failed not equal (non zero)
                        
138a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
138b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
138d : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1390 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1392 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1394 : 48              >            pha         ;use stack to load status
1395 : 28              >            plp
                        
1396 : ac1902                   ldy abs1+1
1399 : 08                       php         ;test stores do not alter flags
139a : 98                       tya
139b : 49c3                     eor #$c3
139d : a8                       tay
139e : 28                       plp
139f : 8403                     sty zpt+1
13a1 : 08                       php         ;flags after load/store sequence
13a2 : 49c3                     eor #$c3
13a4 : a8                       tay
13a5 : c50c                     cmp zp1+1   ;test result
                                trap_ne
13a7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
13a9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13aa : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13ac : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
13af : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13b1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13b3 : 48              >            pha         ;use stack to load status
13b4 : 28              >            plp
                        
13b5 : ac1a02                   ldy abs1+2
13b8 : 08                       php         ;test stores do not alter flags
13b9 : 98                       tya
13ba : 49c3                     eor #$c3
13bc : a8                       tay
13bd : 28                       plp
13be : 8404                     sty zpt+2
13c0 : 08                       php         ;flags after load/store sequence
13c1 : 49c3                     eor #$c3
13c3 : a8                       tay
13c4 : c50d                     cmp zp1+2   ;test result
                                trap_ne
13c6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
13c8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13c9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13cb : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
13ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13d0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13d2 : 48              >            pha         ;use stack to load status
13d3 : 28              >            plp
                        
13d4 : ac1b02                   ldy abs1+3
13d7 : 08                       php         ;test stores do not alter flags
13d8 : 98                       tya
13d9 : 49c3                     eor #$c3
13db : a8                       tay
13dc : 28                       plp
13dd : 8405                     sty zpt+3
13df : 08                       php         ;flags after load/store sequence
13e0 : 49c3                     eor #$c3
13e2 : a8                       tay
13e3 : c50e                     cmp zp1+3   ;test result
                                trap_ne
13e5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
13e7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13e8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13ea : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
13ed : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
13ef : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
13f1 : 48              >            pha         ;use stack to load status
13f2 : 28              >            plp
                        
13f3 : a0c3                     ldy #$c3  
13f5 : 08                       php
13f6 : cc1802                   cpy abs1    ;test result
                                trap_ne
13f9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
13fb : 68                       pla         ;load status
                                eor_flag 0
13fc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13fe : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1401 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1403 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1405 : 48              >            pha         ;use stack to load status
1406 : 28              >            plp
                        
1407 : a082                     ldy #$82
1409 : 08                       php
140a : cc1902                   cpy abs1+1  ;test result
                                trap_ne
140d : d0fe            >        bne *         ;failed not equal (non zero)
                        
140f : 68                       pla         ;load status
                                eor_flag 0
1410 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1412 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1415 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1417 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1419 : 48              >            pha         ;use stack to load status
141a : 28              >            plp
                        
141b : a041                     ldy #$41
141d : 08                       php
141e : cc1a02                   cpy abs1+2  ;test result
                                trap_ne
1421 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1423 : 68                       pla         ;load status
                                eor_flag 0
1424 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1426 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1429 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
142b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
142d : 48              >            pha         ;use stack to load status
142e : 28              >            plp
                        
142f : a000                     ldy #0
1431 : 08                       php
1432 : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
1435 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1437 : 68                       pla         ;load status
                                eor_flag 0
1438 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
143a : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
143d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
143f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1441 : 48              >            pha         ;use stack to load status
1442 : 28              >            plp
                        
1443 : a0c3                     ldy #$c3  
1445 : 08                       php
1446 : cc1802                   cpy abs1    ;test result
                                trap_ne
1449 : d0fe            >        bne *         ;failed not equal (non zero)
                        
144b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
144c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
144e : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1451 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1453 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1455 : 48              >            pha         ;use stack to load status
1456 : 28              >            plp
                        
1457 : a082                     ldy #$82
1459 : 08                       php
145a : cc1902                   cpy abs1+1  ;test result
                                trap_ne
145d : d0fe            >        bne *         ;failed not equal (non zero)
                        
145f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1460 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1462 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1465 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1467 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1469 : 48              >            pha         ;use stack to load status
146a : 28              >            plp
                        
146b : a041                     ldy #$41
146d : 08                       php
146e : cc1a02                   cpy abs1+2   ;test result
                                trap_ne
1471 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1473 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1474 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1476 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1479 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
147b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
147d : 48              >            pha         ;use stack to load status
147e : 28              >            plp
                        
147f : a000                     ldy #0
1481 : 08                       php
1482 : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
1485 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1487 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1488 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
148a : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
148d : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                
148f : a000                     ldy #0
1491 : a502                     lda zpt  
1493 : 49c3                     eor #$c3
1495 : c50b                     cmp zp1  
                                trap_ne     ;store to zp   data
1497 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1499 : 8402                     sty zpt     ;clear                
149b : ad0302                   lda abst  
149e : 49c3                     eor #$c3
14a0 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs   data
14a3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14a5 : 8c0302                   sty abst    ;clear                
14a8 : a503                     lda zpt+1
14aa : 49c3                     eor #$c3
14ac : c50c                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
14ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
14b0 : 8403                     sty zpt+1   ;clear                
14b2 : ad0402                   lda abst+1
14b5 : 49c3                     eor #$c3
14b7 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
14ba : d0fe            >        bne *         ;failed not equal (non zero)
                        
14bc : 8c0402                   sty abst+1  ;clear                
14bf : a504                     lda zpt+2
14c1 : 49c3                     eor #$c3
14c3 : c50d                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
14c5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14c7 : 8404                     sty zpt+2   ;clear                
14c9 : ad0502                   lda abst+2
14cc : 49c3                     eor #$c3
14ce : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
14d1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14d3 : 8c0502                   sty abst+2  ;clear                
14d6 : a505                     lda zpt+3
14d8 : 49c3                     eor #$c3
14da : c50e                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
14dc : d0fe            >        bne *         ;failed not equal (non zero)
                        
14de : 8405                     sty zpt+3   ;clear                
14e0 : ad0602                   lda abst+3
14e3 : 49c3                     eor #$c3
14e5 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
14e8 : d0fe            >        bne *         ;failed not equal (non zero)
                        
14ea : 8c0602                   sty abst+3  ;clear                
                                next_test
14ed : ad0002          >            lda test_case   ;previous test
14f0 : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
14f2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
14f4 : a915            >            lda #test_num   ;*** next tests' number
14f6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
14f9 : a203                     ldx #3
14fb :                  tldax    
                                set_stat 0
                       >            load_flag 0
14fb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14fd : 48              >            pha         ;use stack to load status
14fe : 28              >            plp
                        
14ff : b50b                     lda zp1,x
1501 : 08                       php         ;test stores do not alter flags
1502 : 49c3                     eor #$c3
1504 : 28                       plp
1505 : 9d0302                   sta abst,x
1508 : 08                       php         ;flags after load/store sequence
1509 : 49c3                     eor #$c3
150b : dd1802                   cmp abs1,x  ;test result
                                trap_ne
150e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1510 : 68                       pla         ;load status
                                eor_flag 0
1511 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1513 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1516 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1518 : ca                       dex
1519 : 10e0                     bpl tldax                  
                        
151b : a203                     ldx #3
151d :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
151d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
151f : 48              >            pha         ;use stack to load status
1520 : 28              >            plp
                        
1521 : b50b                     lda zp1,x
1523 : 08                       php         ;test stores do not alter flags
1524 : 49c3                     eor #$c3
1526 : 28                       plp
1527 : 9d0302                   sta abst,x
152a : 08                       php         ;flags after load/store sequence
152b : 49c3                     eor #$c3
152d : dd1802                   cmp abs1,x   ;test result
                                trap_ne
1530 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1532 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1533 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1535 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1538 : d0fe            >        bne *         ;failed not equal (non zero)
                        
153a : ca                       dex
153b : 10e0                     bpl tldax1                  
                        
153d : a203                     ldx #3
153f :                  tldax2   
                                set_stat 0
                       >            load_flag 0
153f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1541 : 48              >            pha         ;use stack to load status
1542 : 28              >            plp
                        
1543 : bd1802                   lda abs1,x
1546 : 08                       php         ;test stores do not alter flags
1547 : 49c3                     eor #$c3
1549 : 28                       plp
154a : 9502                     sta zpt,x
154c : 08                       php         ;flags after load/store sequence
154d : 49c3                     eor #$c3
154f : d50b                     cmp zp1,x   ;test result
                                trap_ne
1551 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1553 : 68                       pla         ;load status
                                eor_flag 0
1554 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1556 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1559 : d0fe            >        bne *         ;failed not equal (non zero)
                        
155b : ca                       dex
155c : 10e1                     bpl tldax2                  
                        
155e : a203                     ldx #3
1560 :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
1560 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1562 : 48              >            pha         ;use stack to load status
1563 : 28              >            plp
                        
1564 : bd1802                   lda abs1,x
1567 : 08                       php         ;test stores do not alter flags
1568 : 49c3                     eor #$c3
156a : 28                       plp
156b : 9502                     sta zpt,x
156d : 08                       php         ;flags after load/store sequence
156e : 49c3                     eor #$c3
1570 : d50b                     cmp zp1,x   ;test result
                                trap_ne
1572 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1574 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1575 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1577 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
157a : d0fe            >        bne *         ;failed not equal (non zero)
                        
157c : ca                       dex
157d : 10e1                     bpl tldax3
                        
157f : a203                     ldx #3      ;testing store result
1581 : a000                     ldy #0
1583 : b502             tstax   lda zpt,x
1585 : 49c3                     eor #$c3
1587 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1589 : d0fe            >        bne *         ;failed not equal (non zero)
                        
158b : 9402                     sty zpt,x   ;clear                
158d : bd0302                   lda abst,x
1590 : 49c3                     eor #$c3
1592 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1595 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1597 : 8a                       txa
1598 : 9d0302                   sta abst,x  ;clear                
159b : ca                       dex
159c : 10e5                     bpl tstax
                                next_test
159e : ad0002          >            lda test_case   ;previous test
15a1 : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
15a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
15a5 : a916            >            lda #test_num   ;*** next tests' number
15a7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
15aa : a003                     ldy #3
15ac :                  tlday    
                                set_stat 0
                       >            load_flag 0
15ac : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
15ae : 48              >            pha         ;use stack to load status
15af : 28              >            plp
                        
15b0 : b11c                     lda (ind1),y
15b2 : 08                       php         ;test stores do not alter flags
15b3 : 49c3                     eor #$c3
15b5 : 28                       plp
15b6 : 990302                   sta abst,y
15b9 : 08                       php         ;flags after load/store sequence
15ba : 49c3                     eor #$c3
15bc : d91802                   cmp abs1,y  ;test result
                                trap_ne
15bf : d0fe            >        bne *         ;failed not equal (non zero)
                        
15c1 : 68                       pla         ;load status
                                eor_flag 0
15c2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
15c4 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
15c7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
15c9 : 88                       dey
15ca : 10e0                     bpl tlday                  
                        
15cc : a003                     ldy #3
15ce :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
15ce : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15d0 : 48              >            pha         ;use stack to load status
15d1 : 28              >            plp
                        
15d2 : b11c                     lda (ind1),y
15d4 : 08                       php         ;test stores do not alter flags
15d5 : 49c3                     eor #$c3
15d7 : 28                       plp
15d8 : 990302                   sta abst,y
15db : 08                       php         ;flags after load/store sequence
15dc : 49c3                     eor #$c3
15de : d91802                   cmp abs1,y  ;test result
                                trap_ne
15e1 : d0fe            >        bne *         ;failed not equal (non zero)
                        
15e3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15e4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15e6 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
15e9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
15eb : 88                       dey
15ec : 10e0                     bpl tlday1                  
                        
15ee : a003                     ldy #3      ;testing store result
15f0 : a200                     ldx #0
15f2 : b90302           tstay   lda abst,y
15f5 : 49c3                     eor #$c3
15f7 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
15fa : d0fe            >        bne *         ;failed not equal (non zero)
                        
15fc : 8a                       txa
15fd : 990302                   sta abst,y  ;clear                
1600 : 88                       dey
1601 : 10ef                     bpl tstay
                        
1603 : a003                     ldy #3
1605 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
1605 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1607 : 48              >            pha         ;use stack to load status
1608 : 28              >            plp
                        
1609 : b91802                   lda abs1,y
160c : 08                       php         ;test stores do not alter flags
160d : 49c3                     eor #$c3
160f : 28                       plp
1610 : 9128                     sta (indt),y
1612 : 08                       php         ;flags after load/store sequence
1613 : 49c3                     eor #$c3
1615 : d11c                     cmp (ind1),y    ;test result
                                trap_ne
1617 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1619 : 68                       pla         ;load status
                                eor_flag 0
161a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
161c : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
161f : d0fe            >        bne *         ;failed not equal (non zero)
                        
1621 : 88                       dey
1622 : 10e1                     bpl tlday2                  
                        
1624 : a003                     ldy #3
1626 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1626 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1628 : 48              >            pha         ;use stack to load status
1629 : 28              >            plp
                        
162a : b91802                   lda abs1,y
162d : 08                       php         ;test stores do not alter flags
162e : 49c3                     eor #$c3
1630 : 28                       plp
1631 : 9128                     sta (indt),y
1633 : 08                       php         ;flags after load/store sequence
1634 : 49c3                     eor #$c3
1636 : d11c                     cmp (ind1),y   ;test result
                                trap_ne
1638 : d0fe            >        bne *         ;failed not equal (non zero)
                        
163a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
163b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
163d : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
1640 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1642 : 88                       dey
1643 : 10e1                     bpl tlday3
                                
1645 : a003                     ldy #3      ;testing store result
1647 : a200                     ldx #0
1649 : b90302           tstay1  lda abst,y
164c : 49c3                     eor #$c3
164e : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1651 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1653 : 8a                       txa
1654 : 990302                   sta abst,y  ;clear                
1657 : 88                       dey
1658 : 10ef                     bpl tstay1
                                
165a : a206                     ldx #6
165c : a003                     ldy #3
165e :                  tldax4   
                                set_stat 0
                       >            load_flag 0
165e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1660 : 48              >            pha         ;use stack to load status
1661 : 28              >            plp
                        
1662 : a11c                     lda (ind1,x)
1664 : 08                       php         ;test stores do not alter flags
1665 : 49c3                     eor #$c3
1667 : 28                       plp
1668 : 8128                     sta (indt,x)
166a : 08                       php         ;flags after load/store sequence
166b : 49c3                     eor #$c3
166d : d91802                   cmp abs1,y  ;test result
                                trap_ne
1670 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1672 : 68                       pla         ;load status
                                eor_flag 0
1673 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1675 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
1678 : d0fe            >        bne *         ;failed not equal (non zero)
                        
167a : ca                       dex
167b : ca                       dex
167c : 88                       dey
167d : 10df                     bpl tldax4                  
                        
167f : a206                     ldx #6
1681 : a003                     ldy #3
1683 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
1683 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1685 : 48              >            pha         ;use stack to load status
1686 : 28              >            plp
                        
1687 : a11c                     lda (ind1,x)
1689 : 08                       php         ;test stores do not alter flags
168a : 49c3                     eor #$c3
168c : 28                       plp
168d : 8128                     sta (indt,x)
168f : 08                       php         ;flags after load/store sequence
1690 : 49c3                     eor #$c3
1692 : d91802                   cmp abs1,y  ;test result
                                trap_ne
1695 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1697 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1698 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
169a : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
169d : d0fe            >        bne *         ;failed not equal (non zero)
                        
169f : ca                       dex
16a0 : ca                       dex
16a1 : 88                       dey
16a2 : 10df                     bpl tldax5
                        
16a4 : a003                     ldy #3      ;testing store result
16a6 : a200                     ldx #0
16a8 : b90302           tstay2  lda abst,y
16ab : 49c3                     eor #$c3
16ad : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
16b0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
16b2 : 8a                       txa
16b3 : 990302                   sta abst,y  ;clear                
16b6 : 88                       dey
16b7 : 10ef                     bpl tstay2
                                next_test
16b9 : ad0002          >            lda test_case   ;previous test
16bc : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
16be : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
16c0 : a917            >            lda #test_num   ;*** next tests' number
16c2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
16c5 : a2fd                     ldx #3+$fa
16c7 : b511             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
16c9 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
16cc : ca                       dex
16cd : e0fa                     cpx #$fa
16cf : b0f6                     bcs tldax6                  
16d1 : a2fd                     ldx #3+$fa
16d3 : bd1e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
16d6 : 9508                     sta zpt-$fa&$ff,x
16d8 : ca                       dex
16d9 : e0fa                     cpx #$fa
16db : b0f6                     bcs tldax7
                                                  
16dd : a203                     ldx #3      ;testing wraparound result
16df : a000                     ldy #0
16e1 : b502             tstax1  lda zpt,x
16e3 : d50b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
16e5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
16e7 : 9402                     sty zpt,x   ;clear                
16e9 : bd0302                   lda abst,x
16ec : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
16ef : d0fe            >        bne *         ;failed not equal (non zero)
                        
16f1 : 8a                       txa
16f2 : 9d0302                   sta abst,x  ;clear                
16f5 : ca                       dex
16f6 : 10e9                     bpl tstax1
                        
16f8 : a0fb                     ldy #3+$f8
16fa : a2fe                     ldx #6+$f8
16fc : a124             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
16fe : 990b01                   sta abst-$f8,y
1701 : ca                       dex
1702 : ca                       dex
1703 : 88                       dey
1704 : c0f8                     cpy #$f8
1706 : b0f4                     bcs tlday4
1708 : a003                     ldy #3      ;testing wraparound result
170a : a200                     ldx #0
170c : b90302           tstay4  lda abst,y
170f : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1712 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1714 : 8a                       txa
1715 : 990302                   sta abst,y  ;clear                
1718 : 88                       dey
1719 : 10f1                     bpl tstay4
                                
171b : a0fb                     ldy #3+$f8
171d : b92001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
1720 : 9130                     sta (inwt),y
1722 : 88                       dey
1723 : c0f8                     cpy #$f8
1725 : b0f6                     bcs tlday5                  
1727 : a003                     ldy #3      ;testing wraparound result
1729 : a200                     ldx #0
172b : b90302           tstay5  lda abst,y
172e : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1731 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1733 : 8a                       txa
1734 : 990302                   sta abst,y  ;clear                
1737 : 88                       dey
1738 : 10f1                     bpl tstay5
                        
173a : a0fb                     ldy #3+$f8
173c : a2fe                     ldx #6+$f8
173e : b126             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
1740 : 8130                     sta (indt-$f8&$ff,x)
1742 : ca                       dex
1743 : ca                       dex
1744 : 88                       dey
1745 : c0f8                     cpy #$f8
1747 : b0f5                     bcs tlday6
1749 : a003                     ldy #3      ;testing wraparound result
174b : a200                     ldx #0
174d : b90302           tstay6  lda abst,y
1750 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1753 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1755 : 8a                       txa
1756 : 990302                   sta abst,y  ;clear                
1759 : 88                       dey
175a : 10f1                     bpl tstay6
                                next_test
175c : ad0002          >            lda test_case   ;previous test
175f : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1761 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
1763 : a918            >            lda #test_num   ;*** next tests' number
1765 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1768 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
176a : 48              >            pha         ;use stack to load status
176b : 28              >            plp
                        
176c : a50b                     lda zp1
176e : 08                       php         ;test stores do not alter flags
176f : 49c3                     eor #$c3
1771 : 28                       plp
1772 : 8d0302                   sta abst
1775 : 08                       php         ;flags after load/store sequence
1776 : 49c3                     eor #$c3
1778 : c9c3                     cmp #$c3    ;test result
                                trap_ne
177a : d0fe            >        bne *         ;failed not equal (non zero)
                        
177c : 68                       pla         ;load status
                                eor_flag 0
177d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
177f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1782 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1784 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1786 : 48              >            pha         ;use stack to load status
1787 : 28              >            plp
                        
1788 : a50c                     lda zp1+1
178a : 08                       php         ;test stores do not alter flags
178b : 49c3                     eor #$c3
178d : 28                       plp
178e : 8d0402                   sta abst+1
1791 : 08                       php         ;flags after load/store sequence
1792 : 49c3                     eor #$c3
1794 : c982                     cmp #$82    ;test result
                                trap_ne
1796 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1798 : 68                       pla         ;load status
                                eor_flag 0
1799 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
179b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
179e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
17a0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
17a2 : 48              >            pha         ;use stack to load status
17a3 : 28              >            plp
                        
17a4 : a50d                     lda zp1+2
17a6 : 08                       php         ;test stores do not alter flags
17a7 : 49c3                     eor #$c3
17a9 : 28                       plp
17aa : 8d0502                   sta abst+2
17ad : 08                       php         ;flags after load/store sequence
17ae : 49c3                     eor #$c3
17b0 : c941                     cmp #$41    ;test result
                                trap_ne
17b2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
17b4 : 68                       pla         ;load status
                                eor_flag 0
17b5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
17b7 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
17ba : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
17bc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
17be : 48              >            pha         ;use stack to load status
17bf : 28              >            plp
                        
17c0 : a50e                     lda zp1+3
17c2 : 08                       php         ;test stores do not alter flags
17c3 : 49c3                     eor #$c3
17c5 : 28                       plp
17c6 : 8d0602                   sta abst+3
17c9 : 08                       php         ;flags after load/store sequence
17ca : 49c3                     eor #$c3
17cc : c900                     cmp #0      ;test result
                                trap_ne
17ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
17d0 : 68                       pla         ;load status
                                eor_flag 0
17d1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
17d3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
17d6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
17d8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
17da : 48              >            pha         ;use stack to load status
17db : 28              >            plp
                        
17dc : a50b                     lda zp1  
17de : 08                       php         ;test stores do not alter flags
17df : 49c3                     eor #$c3
17e1 : 28                       plp
17e2 : 8d0302                   sta abst  
17e5 : 08                       php         ;flags after load/store sequence
17e6 : 49c3                     eor #$c3
17e8 : c9c3                     cmp #$c3    ;test result
                                trap_ne
17ea : d0fe            >        bne *         ;failed not equal (non zero)
                        
17ec : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17ed : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
17ef : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
17f2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
17f4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
17f6 : 48              >            pha         ;use stack to load status
17f7 : 28              >            plp
                        
17f8 : a50c                     lda zp1+1
17fa : 08                       php         ;test stores do not alter flags
17fb : 49c3                     eor #$c3
17fd : 28                       plp
17fe : 8d0402                   sta abst+1
1801 : 08                       php         ;flags after load/store sequence
1802 : 49c3                     eor #$c3
1804 : c982                     cmp #$82    ;test result
                                trap_ne
1806 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1808 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1809 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
180b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
180e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1810 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1812 : 48              >            pha         ;use stack to load status
1813 : 28              >            plp
                        
1814 : a50d                     lda zp1+2
1816 : 08                       php         ;test stores do not alter flags
1817 : 49c3                     eor #$c3
1819 : 28                       plp
181a : 8d0502                   sta abst+2
181d : 08                       php         ;flags after load/store sequence
181e : 49c3                     eor #$c3
1820 : c941                     cmp #$41    ;test result
                                trap_ne
1822 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1824 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1825 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1827 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
182a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
182c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
182e : 48              >            pha         ;use stack to load status
182f : 28              >            plp
                        
1830 : a50e                     lda zp1+3
1832 : 08                       php         ;test stores do not alter flags
1833 : 49c3                     eor #$c3
1835 : 28                       plp
1836 : 8d0602                   sta abst+3
1839 : 08                       php         ;flags after load/store sequence
183a : 49c3                     eor #$c3
183c : c900                     cmp #0      ;test result
                                trap_ne
183e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1840 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1841 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1843 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1846 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1848 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
184a : 48              >            pha         ;use stack to load status
184b : 28              >            plp
                        
184c : ad1802                   lda abs1  
184f : 08                       php         ;test stores do not alter flags
1850 : 49c3                     eor #$c3
1852 : 28                       plp
1853 : 8502                     sta zpt  
1855 : 08                       php         ;flags after load/store sequence
1856 : 49c3                     eor #$c3
1858 : c50b                     cmp zp1     ;test result
                                trap_ne
185a : d0fe            >        bne *         ;failed not equal (non zero)
                        
185c : 68                       pla         ;load status
                                eor_flag 0
185d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
185f : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1862 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1864 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1866 : 48              >            pha         ;use stack to load status
1867 : 28              >            plp
                        
1868 : ad1902                   lda abs1+1
186b : 08                       php         ;test stores do not alter flags
186c : 49c3                     eor #$c3
186e : 28                       plp
186f : 8503                     sta zpt+1
1871 : 08                       php         ;flags after load/store sequence
1872 : 49c3                     eor #$c3
1874 : c50c                     cmp zp1+1   ;test result
                                trap_ne
1876 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1878 : 68                       pla         ;load status
                                eor_flag 0
1879 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
187b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
187e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1880 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1882 : 48              >            pha         ;use stack to load status
1883 : 28              >            plp
                        
1884 : ad1a02                   lda abs1+2
1887 : 08                       php         ;test stores do not alter flags
1888 : 49c3                     eor #$c3
188a : 28                       plp
188b : 8504                     sta zpt+2
188d : 08                       php         ;flags after load/store sequence
188e : 49c3                     eor #$c3
1890 : c50d                     cmp zp1+2   ;test result
                                trap_ne
1892 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1894 : 68                       pla         ;load status
                                eor_flag 0
1895 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1897 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
189a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
189c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
189e : 48              >            pha         ;use stack to load status
189f : 28              >            plp
                        
18a0 : ad1b02                   lda abs1+3
18a3 : 08                       php         ;test stores do not alter flags
18a4 : 49c3                     eor #$c3
18a6 : 28                       plp
18a7 : 8505                     sta zpt+3
18a9 : 08                       php         ;flags after load/store sequence
18aa : 49c3                     eor #$c3
18ac : c50e                     cmp zp1+3   ;test result
                                trap_ne
18ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
18b0 : 68                       pla         ;load status
                                eor_flag 0
18b1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18b3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
18b6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18b8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18ba : 48              >            pha         ;use stack to load status
18bb : 28              >            plp
                        
18bc : ad1802                   lda abs1  
18bf : 08                       php         ;test stores do not alter flags
18c0 : 49c3                     eor #$c3
18c2 : 28                       plp
18c3 : 8502                     sta zpt  
18c5 : 08                       php         ;flags after load/store sequence
18c6 : 49c3                     eor #$c3
18c8 : c50b                     cmp zp1     ;test result
                                trap_ne
18ca : d0fe            >        bne *         ;failed not equal (non zero)
                        
18cc : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18cd : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18cf : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
18d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18d4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18d6 : 48              >            pha         ;use stack to load status
18d7 : 28              >            plp
                        
18d8 : ad1902                   lda abs1+1
18db : 08                       php         ;test stores do not alter flags
18dc : 49c3                     eor #$c3
18de : 28                       plp
18df : 8503                     sta zpt+1
18e1 : 08                       php         ;flags after load/store sequence
18e2 : 49c3                     eor #$c3
18e4 : c50c                     cmp zp1+1   ;test result
                                trap_ne
18e6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
18e8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18e9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
18eb : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
18ee : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18f0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
18f2 : 48              >            pha         ;use stack to load status
18f3 : 28              >            plp
                        
18f4 : ad1a02                   lda abs1+2
18f7 : 08                       php         ;test stores do not alter flags
18f8 : 49c3                     eor #$c3
18fa : 28                       plp
18fb : 8504                     sta zpt+2
18fd : 08                       php         ;flags after load/store sequence
18fe : 49c3                     eor #$c3
1900 : c50d                     cmp zp1+2   ;test result
                                trap_ne
1902 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1904 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1905 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1907 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
190a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
190c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
190e : 48              >            pha         ;use stack to load status
190f : 28              >            plp
                        
1910 : ad1b02                   lda abs1+3
1913 : 08                       php         ;test stores do not alter flags
1914 : 49c3                     eor #$c3
1916 : 28                       plp
1917 : 8505                     sta zpt+3
1919 : 08                       php         ;flags after load/store sequence
191a : 49c3                     eor #$c3
191c : c50e                     cmp zp1+3   ;test result
                                trap_ne
191e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1920 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1921 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1923 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1926 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1928 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
192a : 48              >            pha         ;use stack to load status
192b : 28              >            plp
                        
192c : a9c3                     lda #$c3
192e : 08                       php
192f : cd1802                   cmp abs1    ;test result
                                trap_ne
1932 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1934 : 68                       pla         ;load status
                                eor_flag 0
1935 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1937 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
193a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
193c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
193e : 48              >            pha         ;use stack to load status
193f : 28              >            plp
                        
1940 : a982                     lda #$82
1942 : 08                       php
1943 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
1946 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1948 : 68                       pla         ;load status
                                eor_flag 0
1949 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
194b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
194e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1950 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1952 : 48              >            pha         ;use stack to load status
1953 : 28              >            plp
                        
1954 : a941                     lda #$41
1956 : 08                       php
1957 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
195a : d0fe            >        bne *         ;failed not equal (non zero)
                        
195c : 68                       pla         ;load status
                                eor_flag 0
195d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
195f : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1962 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1964 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1966 : 48              >            pha         ;use stack to load status
1967 : 28              >            plp
                        
1968 : a900                     lda #0
196a : 08                       php
196b : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
196e : d0fe            >        bne *         ;failed not equal (non zero)
                        
1970 : 68                       pla         ;load status
                                eor_flag 0
1971 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1973 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1976 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1978 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
197a : 48              >            pha         ;use stack to load status
197b : 28              >            plp
                        
197c : a9c3                     lda #$c3  
197e : 08                       php
197f : cd1802                   cmp abs1    ;test result
                                trap_ne
1982 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1984 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1985 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1987 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
198a : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
198c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
198e : 48              >            pha         ;use stack to load status
198f : 28              >            plp
                        
1990 : a982                     lda #$82
1992 : 08                       php
1993 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
1996 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1998 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1999 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
199b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
199e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19a0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19a2 : 48              >            pha         ;use stack to load status
19a3 : 28              >            plp
                        
19a4 : a941                     lda #$41
19a6 : 08                       php
19a7 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
19aa : d0fe            >        bne *         ;failed not equal (non zero)
                        
19ac : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19ad : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19af : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
19b2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19b4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
19b6 : 48              >            pha         ;use stack to load status
19b7 : 28              >            plp
                        
19b8 : a900                     lda #0
19ba : 08                       php
19bb : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
19be : d0fe            >        bne *         ;failed not equal (non zero)
                        
19c0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19c1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19c3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
19c6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                        
19c8 : a200                     ldx #0
19ca : a502                     lda zpt  
19cc : 49c3                     eor #$c3
19ce : c50b                     cmp zp1  
                                trap_ne     ;store to zp data
19d0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
19d2 : 8602                     stx zpt     ;clear                
19d4 : ad0302                   lda abst  
19d7 : 49c3                     eor #$c3
19d9 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
19dc : d0fe            >        bne *         ;failed not equal (non zero)
                        
19de : 8e0302                   stx abst    ;clear                
19e1 : a503                     lda zpt+1
19e3 : 49c3                     eor #$c3
19e5 : c50c                     cmp zp1+1
                                trap_ne     ;store to zp data
19e7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
19e9 : 8603                     stx zpt+1   ;clear                
19eb : ad0402                   lda abst+1
19ee : 49c3                     eor #$c3
19f0 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
19f3 : d0fe            >        bne *         ;failed not equal (non zero)
                        
19f5 : 8e0402                   stx abst+1  ;clear                
19f8 : a504                     lda zpt+2
19fa : 49c3                     eor #$c3
19fc : c50d                     cmp zp1+2
                                trap_ne     ;store to zp data
19fe : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a00 : 8604                     stx zpt+2   ;clear                
1a02 : ad0502                   lda abst+2
1a05 : 49c3                     eor #$c3
1a07 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
1a0a : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a0c : 8e0502                   stx abst+2  ;clear                
1a0f : a505                     lda zpt+3
1a11 : 49c3                     eor #$c3
1a13 : c50e                     cmp zp1+3
                                trap_ne     ;store to zp data
1a15 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a17 : 8605                     stx zpt+3   ;clear                
1a19 : ad0602                   lda abst+3
1a1c : 49c3                     eor #$c3
1a1e : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
1a21 : d0fe            >        bne *         ;failed not equal (non zero)
                        
1a23 : 8e0602                   stx abst+3  ;clear                
                                next_test
1a26 : ad0002          >            lda test_case   ;previous test
1a29 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1a2b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1a2d : a919            >            lda #test_num   ;*** next tests' number
1a2f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1a32 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a34 : 48              >            pha         ;use stack to load status
1a35 : a9ff            >            lda #$ff     ;precharge accu
1a37 : 28              >            plp
                        
1a38 : 240e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1a3a : 08              >            php         ;save flags
1a3b : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1a3d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a3f : 68              >            pla         ;load status
1a40 : 48              >            pha
                       >            cmp_flag fz 
1a41 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a43 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a45 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1a46 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a48 : 48              >            pha         ;use stack to load status
1a49 : a901            >            lda #1     ;precharge accu
1a4b : 28              >            plp
                        
1a4c : 240d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1a4e : 08              >            php         ;save flags
1a4f : c901            >            cmp #1     ;test result
                       >            trap_ne
1a51 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a53 : 68              >            pla         ;load status
1a54 : 48              >            pha
                       >            cmp_flag fv
1a55 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a57 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a59 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1a5a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a5c : 48              >            pha         ;use stack to load status
1a5d : a901            >            lda #1     ;precharge accu
1a5f : 28              >            plp
                        
1a60 : 240c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1a62 : 08              >            php         ;save flags
1a63 : c901            >            cmp #1     ;test result
                       >            trap_ne
1a65 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a67 : 68              >            pla         ;load status
1a68 : 48              >            pha
                       >            cmp_flag fnz
1a69 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a6b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a6d : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1a6e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a70 : 48              >            pha         ;use stack to load status
1a71 : a901            >            lda #1     ;precharge accu
1a73 : 28              >            plp
                        
1a74 : 240b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1a76 : 08              >            php         ;save flags
1a77 : c901            >            cmp #1     ;test result
                       >            trap_ne
1a79 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a7b : 68              >            pla         ;load status
1a7c : 48              >            pha
                       >            cmp_flag fnv
1a7d : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a81 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1a82 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a84 : 48              >            pha         ;use stack to load status
1a85 : a9ff            >            lda #$ff     ;precharge accu
1a87 : 28              >            plp
                        
1a88 : 240e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1a8a : 08              >            php         ;save flags
1a8b : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1a8d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a8f : 68              >            pla         ;load status
1a90 : 48              >            pha
                       >            cmp_flag ~fnv 
1a91 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1a93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1a95 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1a96 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a98 : 48              >            pha         ;use stack to load status
1a99 : a901            >            lda #1     ;precharge accu
1a9b : 28              >            plp
                        
1a9c : 240d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1a9e : 08              >            php         ;save flags
1a9f : c901            >            cmp #1     ;test result
                       >            trap_ne
1aa1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1aa3 : 68              >            pla         ;load status
1aa4 : 48              >            pha
                       >            cmp_flag ~fnz
1aa5 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1aa7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1aa9 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1aaa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1aac : 48              >            pha         ;use stack to load status
1aad : a901            >            lda #1     ;precharge accu
1aaf : 28              >            plp
                        
1ab0 : 240c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1ab2 : 08              >            php         ;save flags
1ab3 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ab5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ab7 : 68              >            pla         ;load status
1ab8 : 48              >            pha
                       >            cmp_flag ~fv
1ab9 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1abb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1abd : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1abe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ac0 : 48              >            pha         ;use stack to load status
1ac1 : a901            >            lda #1     ;precharge accu
1ac3 : 28              >            plp
                        
1ac4 : 240b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1ac6 : 08              >            php         ;save flags
1ac7 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ac9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1acb : 68              >            pla         ;load status
1acc : 48              >            pha
                       >            cmp_flag ~fz
1acd : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1acf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ad1 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1ad2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ad4 : 48              >            pha         ;use stack to load status
1ad5 : a9ff            >            lda #$ff     ;precharge accu
1ad7 : 28              >            plp
                        
1ad8 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1adb : 08              >            php         ;save flags
1adc : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1ade : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ae0 : 68              >            pla         ;load status
1ae1 : 48              >            pha
                       >            cmp_flag fz 
1ae2 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ae4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ae6 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1ae7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ae9 : 48              >            pha         ;use stack to load status
1aea : a901            >            lda #1     ;precharge accu
1aec : 28              >            plp
                        
1aed : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1af0 : 08              >            php         ;save flags
1af1 : c901            >            cmp #1     ;test result
                       >            trap_ne
1af3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1af5 : 68              >            pla         ;load status
1af6 : 48              >            pha
                       >            cmp_flag fv
1af7 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1af9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1afb : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1afc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1afe : 48              >            pha         ;use stack to load status
1aff : a901            >            lda #1     ;precharge accu
1b01 : 28              >            plp
                        
1b02 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1b05 : 08              >            php         ;save flags
1b06 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b08 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b0a : 68              >            pla         ;load status
1b0b : 48              >            pha
                       >            cmp_flag fnz
1b0c : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b0e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b10 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b11 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b13 : 48              >            pha         ;use stack to load status
1b14 : a901            >            lda #1     ;precharge accu
1b16 : 28              >            plp
                        
1b17 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1b1a : 08              >            php         ;save flags
1b1b : c901            >            cmp #1     ;test result
                       >            trap_ne
1b1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b1f : 68              >            pla         ;load status
1b20 : 48              >            pha
                       >            cmp_flag fnv
1b21 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b23 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b25 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1b26 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b28 : 48              >            pha         ;use stack to load status
1b29 : a9ff            >            lda #$ff     ;precharge accu
1b2b : 28              >            plp
                        
1b2c : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1b2f : 08              >            php         ;save flags
1b30 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b32 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b34 : 68              >            pla         ;load status
1b35 : 48              >            pha
                       >            cmp_flag ~fnv 
1b36 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b38 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b3a : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b3b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b3d : 48              >            pha         ;use stack to load status
1b3e : a901            >            lda #1     ;precharge accu
1b40 : 28              >            plp
                        
1b41 : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1b44 : 08              >            php         ;save flags
1b45 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b47 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b49 : 68              >            pla         ;load status
1b4a : 48              >            pha
                       >            cmp_flag ~fnz
1b4b : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b4d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b4f : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b50 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b52 : 48              >            pha         ;use stack to load status
1b53 : a901            >            lda #1     ;precharge accu
1b55 : 28              >            plp
                        
1b56 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1b59 : 08              >            php         ;save flags
1b5a : c901            >            cmp #1     ;test result
                       >            trap_ne
1b5c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b5e : 68              >            pla         ;load status
1b5f : 48              >            pha
                       >            cmp_flag ~fv
1b60 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b62 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b64 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1b65 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b67 : 48              >            pha         ;use stack to load status
1b68 : a901            >            lda #1     ;precharge accu
1b6a : 28              >            plp
                        
1b6b : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1b6e : 08              >            php         ;save flags
1b6f : c901            >            cmp #1     ;test result
                       >            trap_ne
1b71 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b73 : 68              >            pla         ;load status
1b74 : 48              >            pha
                       >            cmp_flag ~fz
1b75 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b77 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b79 : 28              >            plp         ;restore status
                        
                                next_test
1b7a : ad0002          >            lda test_case   ;previous test
1b7d : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1b81 : a91a            >            lda #test_num   ;*** next tests' number
1b83 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1b86 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b88 : 48              >            pha         ;use stack to load status
1b89 : a280            >            ldx #$80     ;precharge index x
1b8b : 28              >            plp
                        
1b8c : e40f                     cpx zp7f
                                tst_stat fc
1b8e : 08              >            php         ;save status
1b8f : 68              >            pla         ;use stack to retrieve status
1b90 : 48              >            pha
                       >            cmp_flag fc
1b91 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1b95 : 28              >            plp         ;restore status
                        
1b96 : ca                       dex
1b97 : e40f                     cpx zp7f
                                tst_stat fzc
1b99 : 08              >            php         ;save status
1b9a : 68              >            pla         ;use stack to retrieve status
1b9b : 48              >            pha
                       >            cmp_flag fzc
1b9c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1b9e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ba0 : 28              >            plp         ;restore status
                        
1ba1 : ca                       dex
1ba2 : e40f                     cpx zp7f
                                tst_x $7e,fn
1ba4 : 08              >            php         ;save flags
1ba5 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1ba7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ba9 : 68              >            pla         ;load status
1baa : 48              >            pha
                       >            cmp_flag fn
1bab : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1baf : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1bb0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bb2 : 48              >            pha         ;use stack to load status
1bb3 : a280            >            ldx #$80     ;precharge index x
1bb5 : 28              >            plp
                        
1bb6 : e40f                     cpx zp7f
                                tst_stat ~fnz
1bb8 : 08              >            php         ;save status
1bb9 : 68              >            pla         ;use stack to retrieve status
1bba : 48              >            pha
                       >            cmp_flag ~fnz
1bbb : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bbd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bbf : 28              >            plp         ;restore status
                        
1bc0 : ca                       dex
1bc1 : e40f                     cpx zp7f
                                tst_stat ~fn
1bc3 : 08              >            php         ;save status
1bc4 : 68              >            pla         ;use stack to retrieve status
1bc5 : 48              >            pha
                       >            cmp_flag ~fn
1bc6 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bc8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bca : 28              >            plp         ;restore status
                        
1bcb : ca                       dex
1bcc : e40f                     cpx zp7f
                                tst_x $7e,~fzc
1bce : 08              >            php         ;save flags
1bcf : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1bd1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bd3 : 68              >            pla         ;load status
1bd4 : 48              >            pha
                       >            cmp_flag ~fzc
1bd5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bd7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bd9 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1bda : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bdc : 48              >            pha         ;use stack to load status
1bdd : a280            >            ldx #$80     ;precharge index x
1bdf : 28              >            plp
                        
1be0 : ec1c02                   cpx abs7f
                                tst_stat fc
1be3 : 08              >            php         ;save status
1be4 : 68              >            pla         ;use stack to retrieve status
1be5 : 48              >            pha
                       >            cmp_flag fc
1be6 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1be8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bea : 28              >            plp         ;restore status
                        
1beb : ca                       dex
1bec : ec1c02                   cpx abs7f
                                tst_stat fzc
1bef : 08              >            php         ;save status
1bf0 : 68              >            pla         ;use stack to retrieve status
1bf1 : 48              >            pha
                       >            cmp_flag fzc
1bf2 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bf4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1bf6 : 28              >            plp         ;restore status
                        
1bf7 : ca                       dex
1bf8 : ec1c02                   cpx abs7f
                                tst_x $7e,fn
1bfb : 08              >            php         ;save flags
1bfc : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1bfe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c00 : 68              >            pla         ;load status
1c01 : 48              >            pha
                       >            cmp_flag fn
1c02 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c04 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c06 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1c07 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c09 : 48              >            pha         ;use stack to load status
1c0a : a280            >            ldx #$80     ;precharge index x
1c0c : 28              >            plp
                        
1c0d : ec1c02                   cpx abs7f
                                tst_stat ~fnz
1c10 : 08              >            php         ;save status
1c11 : 68              >            pla         ;use stack to retrieve status
1c12 : 48              >            pha
                       >            cmp_flag ~fnz
1c13 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c15 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c17 : 28              >            plp         ;restore status
                        
1c18 : ca                       dex
1c19 : ec1c02                   cpx abs7f
                                tst_stat ~fn
1c1c : 08              >            php         ;save status
1c1d : 68              >            pla         ;use stack to retrieve status
1c1e : 48              >            pha
                       >            cmp_flag ~fn
1c1f : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c23 : 28              >            plp         ;restore status
                        
1c24 : ca                       dex
1c25 : ec1c02                   cpx abs7f
                                tst_x $7e,~fzc
1c28 : 08              >            php         ;save flags
1c29 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c2b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c2d : 68              >            pla         ;load status
1c2e : 48              >            pha
                       >            cmp_flag ~fzc
1c2f : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c33 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1c34 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c36 : 48              >            pha         ;use stack to load status
1c37 : a280            >            ldx #$80     ;precharge index x
1c39 : 28              >            plp
                        
1c3a : e07f                     cpx #$7f
                                tst_stat fc
1c3c : 08              >            php         ;save status
1c3d : 68              >            pla         ;use stack to retrieve status
1c3e : 48              >            pha
                       >            cmp_flag fc
1c3f : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c43 : 28              >            plp         ;restore status
                        
1c44 : ca                       dex
1c45 : e07f                     cpx #$7f
                                tst_stat fzc
1c47 : 08              >            php         ;save status
1c48 : 68              >            pla         ;use stack to retrieve status
1c49 : 48              >            pha
                       >            cmp_flag fzc
1c4a : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c4c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c4e : 28              >            plp         ;restore status
                        
1c4f : ca                       dex
1c50 : e07f                     cpx #$7f
                                tst_x $7e,fn
1c52 : 08              >            php         ;save flags
1c53 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c55 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c57 : 68              >            pla         ;load status
1c58 : 48              >            pha
                       >            cmp_flag fn
1c59 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c5b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c5d : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1c5e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c60 : 48              >            pha         ;use stack to load status
1c61 : a280            >            ldx #$80     ;precharge index x
1c63 : 28              >            plp
                        
1c64 : e07f                     cpx #$7f
                                tst_stat ~fnz
1c66 : 08              >            php         ;save status
1c67 : 68              >            pla         ;use stack to retrieve status
1c68 : 48              >            pha
                       >            cmp_flag ~fnz
1c69 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c6b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c6d : 28              >            plp         ;restore status
                        
1c6e : ca                       dex
1c6f : e07f                     cpx #$7f
                                tst_stat ~fn
1c71 : 08              >            php         ;save status
1c72 : 68              >            pla         ;use stack to retrieve status
1c73 : 48              >            pha
                       >            cmp_flag ~fn
1c74 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c76 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c78 : 28              >            plp         ;restore status
                        
1c79 : ca                       dex
1c7a : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1c7c : 08              >            php         ;save flags
1c7d : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1c7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c81 : 68              >            pla         ;load status
1c82 : 48              >            pha
                       >            cmp_flag ~fzc
1c83 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c85 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1c87 : 28              >            plp         ;restore status
                        
                                next_test
1c88 : ad0002          >            lda test_case   ;previous test
1c8b : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1c8d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1c8f : a91b            >            lda #test_num   ;*** next tests' number
1c91 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1c94 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c96 : 48              >            pha         ;use stack to load status
1c97 : a080            >            ldy #$80     ;precharge index y
1c99 : 28              >            plp
                        
1c9a : c40f                     cpy zp7f
                                tst_stat fc
1c9c : 08              >            php         ;save status
1c9d : 68              >            pla         ;use stack to retrieve status
1c9e : 48              >            pha
                       >            cmp_flag fc
1c9f : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ca1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ca3 : 28              >            plp         ;restore status
                        
1ca4 : 88                       dey
1ca5 : c40f                     cpy zp7f
                                tst_stat fzc
1ca7 : 08              >            php         ;save status
1ca8 : 68              >            pla         ;use stack to retrieve status
1ca9 : 48              >            pha
                       >            cmp_flag fzc
1caa : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cac : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cae : 28              >            plp         ;restore status
                        
1caf : 88                       dey
1cb0 : c40f                     cpy zp7f
                                tst_y $7e,fn
1cb2 : 08              >            php         ;save flags
1cb3 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1cb5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cb7 : 68              >            pla         ;load status
1cb8 : 48              >            pha
                       >            cmp_flag fn
1cb9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cbb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cbd : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1cbe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cc0 : 48              >            pha         ;use stack to load status
1cc1 : a080            >            ldy #$80     ;precharge index y
1cc3 : 28              >            plp
                        
1cc4 : c40f                     cpy zp7f
                                tst_stat ~fnz
1cc6 : 08              >            php         ;save status
1cc7 : 68              >            pla         ;use stack to retrieve status
1cc8 : 48              >            pha
                       >            cmp_flag ~fnz
1cc9 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ccb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ccd : 28              >            plp         ;restore status
                        
1cce : 88                       dey
1ccf : c40f                     cpy zp7f
                                tst_stat ~fn
1cd1 : 08              >            php         ;save status
1cd2 : 68              >            pla         ;use stack to retrieve status
1cd3 : 48              >            pha
                       >            cmp_flag ~fn
1cd4 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cd6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cd8 : 28              >            plp         ;restore status
                        
1cd9 : 88                       dey
1cda : c40f                     cpy zp7f
                                tst_y $7e,~fzc
1cdc : 08              >            php         ;save flags
1cdd : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1cdf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ce1 : 68              >            pla         ;load status
1ce2 : 48              >            pha
                       >            cmp_flag ~fzc
1ce3 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ce5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ce7 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1ce8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1cea : 48              >            pha         ;use stack to load status
1ceb : a080            >            ldy #$80     ;precharge index y
1ced : 28              >            plp
                        
1cee : cc1c02                   cpy abs7f
                                tst_stat fc
1cf1 : 08              >            php         ;save status
1cf2 : 68              >            pla         ;use stack to retrieve status
1cf3 : 48              >            pha
                       >            cmp_flag fc
1cf4 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cf6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1cf8 : 28              >            plp         ;restore status
                        
1cf9 : 88                       dey
1cfa : cc1c02                   cpy abs7f
                                tst_stat fzc
1cfd : 08              >            php         ;save status
1cfe : 68              >            pla         ;use stack to retrieve status
1cff : 48              >            pha
                       >            cmp_flag fzc
1d00 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d02 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d04 : 28              >            plp         ;restore status
                        
1d05 : 88                       dey
1d06 : cc1c02                   cpy abs7f
                                tst_y $7e,fn
1d09 : 08              >            php         ;save flags
1d0a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1d0c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d0e : 68              >            pla         ;load status
1d0f : 48              >            pha
                       >            cmp_flag fn
1d10 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d12 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d14 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1d15 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d17 : 48              >            pha         ;use stack to load status
1d18 : a080            >            ldy #$80     ;precharge index y
1d1a : 28              >            plp
                        
1d1b : cc1c02                   cpy abs7f
                                tst_stat ~fnz
1d1e : 08              >            php         ;save status
1d1f : 68              >            pla         ;use stack to retrieve status
1d20 : 48              >            pha
                       >            cmp_flag ~fnz
1d21 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d23 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d25 : 28              >            plp         ;restore status
                        
1d26 : 88                       dey
1d27 : cc1c02                   cpy abs7f
                                tst_stat ~fn
1d2a : 08              >            php         ;save status
1d2b : 68              >            pla         ;use stack to retrieve status
1d2c : 48              >            pha
                       >            cmp_flag ~fn
1d2d : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d2f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d31 : 28              >            plp         ;restore status
                        
1d32 : 88                       dey
1d33 : cc1c02                   cpy abs7f
                                tst_y $7e,~fzc
1d36 : 08              >            php         ;save flags
1d37 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1d39 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d3b : 68              >            pla         ;load status
1d3c : 48              >            pha
                       >            cmp_flag ~fzc
1d3d : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d3f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d41 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1d42 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d44 : 48              >            pha         ;use stack to load status
1d45 : a080            >            ldy #$80     ;precharge index y
1d47 : 28              >            plp
                        
1d48 : c07f                     cpy #$7f
                                tst_stat fc
1d4a : 08              >            php         ;save status
1d4b : 68              >            pla         ;use stack to retrieve status
1d4c : 48              >            pha
                       >            cmp_flag fc
1d4d : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d4f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d51 : 28              >            plp         ;restore status
                        
1d52 : 88                       dey
1d53 : c07f                     cpy #$7f
                                tst_stat fzc
1d55 : 08              >            php         ;save status
1d56 : 68              >            pla         ;use stack to retrieve status
1d57 : 48              >            pha
                       >            cmp_flag fzc
1d58 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d5a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d5c : 28              >            plp         ;restore status
                        
1d5d : 88                       dey
1d5e : c07f                     cpy #$7f
                                tst_y $7e,fn
1d60 : 08              >            php         ;save flags
1d61 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1d63 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d65 : 68              >            pla         ;load status
1d66 : 48              >            pha
                       >            cmp_flag fn
1d67 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d69 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d6b : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1d6c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d6e : 48              >            pha         ;use stack to load status
1d6f : a080            >            ldy #$80     ;precharge index y
1d71 : 28              >            plp
                        
1d72 : c07f                     cpy #$7f
                                tst_stat ~fnz
1d74 : 08              >            php         ;save status
1d75 : 68              >            pla         ;use stack to retrieve status
1d76 : 48              >            pha
                       >            cmp_flag ~fnz
1d77 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d79 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d7b : 28              >            plp         ;restore status
                        
1d7c : 88                       dey
1d7d : c07f                     cpy #$7f
                                tst_stat ~fn
1d7f : 08              >            php         ;save status
1d80 : 68              >            pla         ;use stack to retrieve status
1d81 : 48              >            pha
                       >            cmp_flag ~fn
1d82 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d84 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d86 : 28              >            plp         ;restore status
                        
1d87 : 88                       dey
1d88 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1d8a : 08              >            php         ;save flags
1d8b : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1d8d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d8f : 68              >            pla         ;load status
1d90 : 48              >            pha
                       >            cmp_flag ~fzc
1d91 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d93 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1d95 : 28              >            plp         ;restore status
                        
                                next_test
1d96 : ad0002          >            lda test_case   ;previous test
1d99 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1d9b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1d9d : a91c            >            lda #test_num   ;*** next tests' number
1d9f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1da2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1da4 : 48              >            pha         ;use stack to load status
1da5 : a980            >            lda #$80     ;precharge accu
1da7 : 28              >            plp
                        
1da8 : c50f                     cmp zp7f
                                tst_a $80,fc
1daa : 08              >            php         ;save flags
1dab : c980            >            cmp #$80     ;test result
                       >            trap_ne
1dad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1daf : 68              >            pla         ;load status
1db0 : 48              >            pha
                       >            cmp_flag fc
1db1 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1db3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1db5 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1db6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1db8 : 48              >            pha         ;use stack to load status
1db9 : a97f            >            lda #$7f     ;precharge accu
1dbb : 28              >            plp
                        
1dbc : c50f                     cmp zp7f
                                tst_a $7f,fzc
1dbe : 08              >            php         ;save flags
1dbf : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1dc1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1dc3 : 68              >            pla         ;load status
1dc4 : 48              >            pha
                       >            cmp_flag fzc
1dc5 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dc7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1dc9 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1dca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1dcc : 48              >            pha         ;use stack to load status
1dcd : a97e            >            lda #$7e     ;precharge accu
1dcf : 28              >            plp
                        
1dd0 : c50f                     cmp zp7f
                                tst_a $7e,fn
1dd2 : 08              >            php         ;save flags
1dd3 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1dd5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1dd7 : 68              >            pla         ;load status
1dd8 : 48              >            pha
                       >            cmp_flag fn
1dd9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ddb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ddd : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1dde : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1de0 : 48              >            pha         ;use stack to load status
1de1 : a980            >            lda #$80     ;precharge accu
1de3 : 28              >            plp
                        
1de4 : c50f                     cmp zp7f
                                tst_a $80,~fnz
1de6 : 08              >            php         ;save flags
1de7 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1de9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1deb : 68              >            pla         ;load status
1dec : 48              >            pha
                       >            cmp_flag ~fnz
1ded : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1def : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1df1 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1df2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1df4 : 48              >            pha         ;use stack to load status
1df5 : a97f            >            lda #$7f     ;precharge accu
1df7 : 28              >            plp
                        
1df8 : c50f                     cmp zp7f
                                tst_a $7f,~fn
1dfa : 08              >            php         ;save flags
1dfb : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1dfd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1dff : 68              >            pla         ;load status
1e00 : 48              >            pha
                       >            cmp_flag ~fn
1e01 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e03 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e05 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1e06 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e08 : 48              >            pha         ;use stack to load status
1e09 : a97e            >            lda #$7e     ;precharge accu
1e0b : 28              >            plp
                        
1e0c : c50f                     cmp zp7f
                                tst_a $7e,~fzc
1e0e : 08              >            php         ;save flags
1e0f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1e11 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e13 : 68              >            pla         ;load status
1e14 : 48              >            pha
                       >            cmp_flag ~fzc
1e15 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e17 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e19 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1e1a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e1c : 48              >            pha         ;use stack to load status
1e1d : a980            >            lda #$80     ;precharge accu
1e1f : 28              >            plp
                        
1e20 : cd1c02                   cmp abs7f
                                tst_a $80,fc
1e23 : 08              >            php         ;save flags
1e24 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1e26 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e28 : 68              >            pla         ;load status
1e29 : 48              >            pha
                       >            cmp_flag fc
1e2a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e2c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e2e : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1e2f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e31 : 48              >            pha         ;use stack to load status
1e32 : a97f            >            lda #$7f     ;precharge accu
1e34 : 28              >            plp
                        
1e35 : cd1c02                   cmp abs7f
                                tst_a $7f,fzc
1e38 : 08              >            php         ;save flags
1e39 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1e3b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e3d : 68              >            pla         ;load status
1e3e : 48              >            pha
                       >            cmp_flag fzc
1e3f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e43 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1e44 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e46 : 48              >            pha         ;use stack to load status
1e47 : a97e            >            lda #$7e     ;precharge accu
1e49 : 28              >            plp
                        
1e4a : cd1c02                   cmp abs7f
                                tst_a $7e,fn
1e4d : 08              >            php         ;save flags
1e4e : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1e50 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e52 : 68              >            pla         ;load status
1e53 : 48              >            pha
                       >            cmp_flag fn
1e54 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e56 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e58 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1e59 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e5b : 48              >            pha         ;use stack to load status
1e5c : a980            >            lda #$80     ;precharge accu
1e5e : 28              >            plp
                        
1e5f : cd1c02                   cmp abs7f
                                tst_a $80,~fnz
1e62 : 08              >            php         ;save flags
1e63 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1e65 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e67 : 68              >            pla         ;load status
1e68 : 48              >            pha
                       >            cmp_flag ~fnz
1e69 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e6b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e6d : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1e6e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e70 : 48              >            pha         ;use stack to load status
1e71 : a97f            >            lda #$7f     ;precharge accu
1e73 : 28              >            plp
                        
1e74 : cd1c02                   cmp abs7f
                                tst_a $7f,~fn
1e77 : 08              >            php         ;save flags
1e78 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1e7a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e7c : 68              >            pla         ;load status
1e7d : 48              >            pha
                       >            cmp_flag ~fn
1e7e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e80 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e82 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1e83 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e85 : 48              >            pha         ;use stack to load status
1e86 : a97e            >            lda #$7e     ;precharge accu
1e88 : 28              >            plp
                        
1e89 : cd1c02                   cmp abs7f
                                tst_a $7e,~fzc
1e8c : 08              >            php         ;save flags
1e8d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1e8f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e91 : 68              >            pla         ;load status
1e92 : 48              >            pha
                       >            cmp_flag ~fzc
1e93 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e95 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1e97 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1e98 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e9a : 48              >            pha         ;use stack to load status
1e9b : a980            >            lda #$80     ;precharge accu
1e9d : 28              >            plp
                        
1e9e : c97f                     cmp #$7f
                                tst_a $80,fc
1ea0 : 08              >            php         ;save flags
1ea1 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ea3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ea5 : 68              >            pla         ;load status
1ea6 : 48              >            pha
                       >            cmp_flag fc
1ea7 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ea9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1eab : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1eac : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1eae : 48              >            pha         ;use stack to load status
1eaf : a97f            >            lda #$7f     ;precharge accu
1eb1 : 28              >            plp
                        
1eb2 : c97f                     cmp #$7f
                                tst_a $7f,fzc
1eb4 : 08              >            php         ;save flags
1eb5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1eb7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1eb9 : 68              >            pla         ;load status
1eba : 48              >            pha
                       >            cmp_flag fzc
1ebb : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ebd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ebf : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1ec0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ec2 : 48              >            pha         ;use stack to load status
1ec3 : a97e            >            lda #$7e     ;precharge accu
1ec5 : 28              >            plp
                        
1ec6 : c97f                     cmp #$7f
                                tst_a $7e,fn
1ec8 : 08              >            php         ;save flags
1ec9 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1ecb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ecd : 68              >            pla         ;load status
1ece : 48              >            pha
                       >            cmp_flag fn
1ecf : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ed1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ed3 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1ed4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ed6 : 48              >            pha         ;use stack to load status
1ed7 : a980            >            lda #$80     ;precharge accu
1ed9 : 28              >            plp
                        
1eda : c97f                     cmp #$7f
                                tst_a $80,~fnz
1edc : 08              >            php         ;save flags
1edd : c980            >            cmp #$80     ;test result
                       >            trap_ne
1edf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ee1 : 68              >            pla         ;load status
1ee2 : 48              >            pha
                       >            cmp_flag ~fnz
1ee3 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ee5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ee7 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1ee8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1eea : 48              >            pha         ;use stack to load status
1eeb : a97f            >            lda #$7f     ;precharge accu
1eed : 28              >            plp
                        
1eee : c97f                     cmp #$7f
                                tst_a $7f,~fn
1ef0 : 08              >            php         ;save flags
1ef1 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1ef3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ef5 : 68              >            pla         ;load status
1ef6 : 48              >            pha
                       >            cmp_flag ~fn
1ef7 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ef9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1efb : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1efc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1efe : 48              >            pha         ;use stack to load status
1eff : a97e            >            lda #$7e     ;precharge accu
1f01 : 28              >            plp
                        
1f02 : c97f                     cmp #$7f
                                tst_a $7e,~fzc
1f04 : 08              >            php         ;save flags
1f05 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f07 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f09 : 68              >            pla         ;load status
1f0a : 48              >            pha
                       >            cmp_flag ~fzc
1f0b : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f0d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f0f : 28              >            plp         ;restore status
                        
                        
1f10 : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
1f12 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f14 : 48              >            pha         ;use stack to load status
1f15 : a980            >            lda #$80     ;precharge accu
1f17 : 28              >            plp
                        
1f18 : d50b                     cmp zp1,x
                                tst_a $80,fc
1f1a : 08              >            php         ;save flags
1f1b : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f1f : 68              >            pla         ;load status
1f20 : 48              >            pha
                       >            cmp_flag fc
1f21 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f23 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f25 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f26 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f28 : 48              >            pha         ;use stack to load status
1f29 : a97f            >            lda #$7f     ;precharge accu
1f2b : 28              >            plp
                        
1f2c : d50b                     cmp zp1,x
                                tst_a $7f,fzc
1f2e : 08              >            php         ;save flags
1f2f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f33 : 68              >            pla         ;load status
1f34 : 48              >            pha
                       >            cmp_flag fzc
1f35 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f37 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f39 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f3a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f3c : 48              >            pha         ;use stack to load status
1f3d : a97e            >            lda #$7e     ;precharge accu
1f3f : 28              >            plp
                        
1f40 : d50b                     cmp zp1,x
                                tst_a $7e,fn
1f42 : 08              >            php         ;save flags
1f43 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f45 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f47 : 68              >            pla         ;load status
1f48 : 48              >            pha
                       >            cmp_flag fn
1f49 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f4b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f4d : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f50 : 48              >            pha         ;use stack to load status
1f51 : a980            >            lda #$80     ;precharge accu
1f53 : 28              >            plp
                        
1f54 : d50b                     cmp zp1,x
                                tst_a $80,~fnz
1f56 : 08              >            php         ;save flags
1f57 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f5b : 68              >            pla         ;load status
1f5c : 48              >            pha
                       >            cmp_flag ~fnz
1f5d : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f5f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f61 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f62 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f64 : 48              >            pha         ;use stack to load status
1f65 : a97f            >            lda #$7f     ;precharge accu
1f67 : 28              >            plp
                        
1f68 : d50b                     cmp zp1,x
                                tst_a $7f,~fn
1f6a : 08              >            php         ;save flags
1f6b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f6d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f6f : 68              >            pla         ;load status
1f70 : 48              >            pha
                       >            cmp_flag ~fn
1f71 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f73 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f75 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f76 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f78 : 48              >            pha         ;use stack to load status
1f79 : a97e            >            lda #$7e     ;precharge accu
1f7b : 28              >            plp
                        
1f7c : d50b                     cmp zp1,x
                                tst_a $7e,~fzc
1f7e : 08              >            php         ;save flags
1f7f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f81 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f83 : 68              >            pla         ;load status
1f84 : 48              >            pha
                       >            cmp_flag ~fzc
1f85 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f87 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f89 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f8a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f8c : 48              >            pha         ;use stack to load status
1f8d : a980            >            lda #$80     ;precharge accu
1f8f : 28              >            plp
                        
1f90 : dd1802                   cmp abs1,x
                                tst_a $80,fc
1f93 : 08              >            php         ;save flags
1f94 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f96 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f98 : 68              >            pla         ;load status
1f99 : 48              >            pha
                       >            cmp_flag fc
1f9a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f9c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1f9e : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f9f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fa1 : 48              >            pha         ;use stack to load status
1fa2 : a97f            >            lda #$7f     ;precharge accu
1fa4 : 28              >            plp
                        
1fa5 : dd1802                   cmp abs1,x
                                tst_a $7f,fzc
1fa8 : 08              >            php         ;save flags
1fa9 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fab : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fad : 68              >            pla         ;load status
1fae : 48              >            pha
                       >            cmp_flag fzc
1faf : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fb1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fb3 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fb4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fb6 : 48              >            pha         ;use stack to load status
1fb7 : a97e            >            lda #$7e     ;precharge accu
1fb9 : 28              >            plp
                        
1fba : dd1802                   cmp abs1,x
                                tst_a $7e,fn
1fbd : 08              >            php         ;save flags
1fbe : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fc0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fc2 : 68              >            pla         ;load status
1fc3 : 48              >            pha
                       >            cmp_flag fn
1fc4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fc6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fc8 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1fc9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fcb : 48              >            pha         ;use stack to load status
1fcc : a980            >            lda #$80     ;precharge accu
1fce : 28              >            plp
                        
1fcf : dd1802                   cmp abs1,x
                                tst_a $80,~fnz
1fd2 : 08              >            php         ;save flags
1fd3 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fd5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fd7 : 68              >            pla         ;load status
1fd8 : 48              >            pha
                       >            cmp_flag ~fnz
1fd9 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fdb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fdd : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1fde : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fe0 : 48              >            pha         ;use stack to load status
1fe1 : a97f            >            lda #$7f     ;precharge accu
1fe3 : 28              >            plp
                        
1fe4 : dd1802                   cmp abs1,x
                                tst_a $7f,~fn
1fe7 : 08              >            php         ;save flags
1fe8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1fec : 68              >            pla         ;load status
1fed : 48              >            pha
                       >            cmp_flag ~fn
1fee : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ff0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
1ff2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1ff3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ff5 : 48              >            pha         ;use stack to load status
1ff6 : a97e            >            lda #$7e     ;precharge accu
1ff8 : 28              >            plp
                        
1ff9 : dd1802                   cmp abs1,x
                                tst_a $7e,~fzc
1ffc : 08              >            php         ;save flags
1ffd : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2001 : 68              >            pla         ;load status
2002 : 48              >            pha
                       >            cmp_flag ~fzc
2003 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2005 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2007 : 28              >            plp         ;restore status
                        
                        
2008 : a004                     ldy #4          ;with indexing by Y
200a : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
200c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
200e : 48              >            pha         ;use stack to load status
200f : a980            >            lda #$80     ;precharge accu
2011 : 28              >            plp
                        
2012 : d91802                   cmp abs1,y
                                tst_a $80,fc
2015 : 08              >            php         ;save flags
2016 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2018 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
201a : 68              >            pla         ;load status
201b : 48              >            pha
                       >            cmp_flag fc
201c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
201e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2020 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2021 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2023 : 48              >            pha         ;use stack to load status
2024 : a97f            >            lda #$7f     ;precharge accu
2026 : 28              >            plp
                        
2027 : d91802                   cmp abs1,y
                                tst_a $7f,fzc
202a : 08              >            php         ;save flags
202b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
202d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
202f : 68              >            pla         ;load status
2030 : 48              >            pha
                       >            cmp_flag fzc
2031 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2033 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2035 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2036 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2038 : 48              >            pha         ;use stack to load status
2039 : a97e            >            lda #$7e     ;precharge accu
203b : 28              >            plp
                        
203c : d91802                   cmp abs1,y
                                tst_a $7e,fn
203f : 08              >            php         ;save flags
2040 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2042 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2044 : 68              >            pla         ;load status
2045 : 48              >            pha
                       >            cmp_flag fn
2046 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2048 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
204a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
204b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
204d : 48              >            pha         ;use stack to load status
204e : a980            >            lda #$80     ;precharge accu
2050 : 28              >            plp
                        
2051 : d91802                   cmp abs1,y
                                tst_a $80,~fnz
2054 : 08              >            php         ;save flags
2055 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2057 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2059 : 68              >            pla         ;load status
205a : 48              >            pha
                       >            cmp_flag ~fnz
205b : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
205d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
205f : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2060 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2062 : 48              >            pha         ;use stack to load status
2063 : a97f            >            lda #$7f     ;precharge accu
2065 : 28              >            plp
                        
2066 : d91802                   cmp abs1,y
                                tst_a $7f,~fn
2069 : 08              >            php         ;save flags
206a : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
206c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
206e : 68              >            pla         ;load status
206f : 48              >            pha
                       >            cmp_flag ~fn
2070 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2072 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2074 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2075 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2077 : 48              >            pha         ;use stack to load status
2078 : a97e            >            lda #$7e     ;precharge accu
207a : 28              >            plp
                        
207b : d91802                   cmp abs1,y
                                tst_a $7e,~fzc
207e : 08              >            php         ;save flags
207f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2081 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2083 : 68              >            pla         ;load status
2084 : 48              >            pha
                       >            cmp_flag ~fzc
2085 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2087 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2089 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
208a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
208c : 48              >            pha         ;use stack to load status
208d : a980            >            lda #$80     ;precharge accu
208f : 28              >            plp
                        
2090 : c11c                     cmp (ind1,x)
                                tst_a $80,fc
2092 : 08              >            php         ;save flags
2093 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2095 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2097 : 68              >            pla         ;load status
2098 : 48              >            pha
                       >            cmp_flag fc
2099 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
209b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
209d : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
209e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20a0 : 48              >            pha         ;use stack to load status
20a1 : a97f            >            lda #$7f     ;precharge accu
20a3 : 28              >            plp
                        
20a4 : c11c                     cmp (ind1,x)
                                tst_a $7f,fzc
20a6 : 08              >            php         ;save flags
20a7 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20ab : 68              >            pla         ;load status
20ac : 48              >            pha
                       >            cmp_flag fzc
20ad : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20af : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20b1 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
20b2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20b4 : 48              >            pha         ;use stack to load status
20b5 : a97e            >            lda #$7e     ;precharge accu
20b7 : 28              >            plp
                        
20b8 : c11c                     cmp (ind1,x)
                                tst_a $7e,fn
20ba : 08              >            php         ;save flags
20bb : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20bd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20bf : 68              >            pla         ;load status
20c0 : 48              >            pha
                       >            cmp_flag fn
20c1 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20c3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20c5 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20c6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20c8 : 48              >            pha         ;use stack to load status
20c9 : a980            >            lda #$80     ;precharge accu
20cb : 28              >            plp
                        
20cc : c11c                     cmp (ind1,x)
                                tst_a $80,~fnz
20ce : 08              >            php         ;save flags
20cf : c980            >            cmp #$80     ;test result
                       >            trap_ne
20d1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20d3 : 68              >            pla         ;load status
20d4 : 48              >            pha
                       >            cmp_flag ~fnz
20d5 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20d7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20d9 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20da : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20dc : 48              >            pha         ;use stack to load status
20dd : a97f            >            lda #$7f     ;precharge accu
20df : 28              >            plp
                        
20e0 : c11c                     cmp (ind1,x)
                                tst_a $7f,~fn
20e2 : 08              >            php         ;save flags
20e3 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20e5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20e7 : 68              >            pla         ;load status
20e8 : 48              >            pha
                       >            cmp_flag ~fn
20e9 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20eb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20ed : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
20ee : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20f0 : 48              >            pha         ;use stack to load status
20f1 : a97e            >            lda #$7e     ;precharge accu
20f3 : 28              >            plp
                        
20f4 : c11c                     cmp (ind1,x)
                                tst_a $7e,~fzc
20f6 : 08              >            php         ;save flags
20f7 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20f9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
20fb : 68              >            pla         ;load status
20fc : 48              >            pha
                       >            cmp_flag ~fzc
20fd : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20ff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2101 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2102 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2104 : 48              >            pha         ;use stack to load status
2105 : a980            >            lda #$80     ;precharge accu
2107 : 28              >            plp
                        
2108 : d11c                     cmp (ind1),y
                                tst_a $80,fc
210a : 08              >            php         ;save flags
210b : c980            >            cmp #$80     ;test result
                       >            trap_ne
210d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
210f : 68              >            pla         ;load status
2110 : 48              >            pha
                       >            cmp_flag fc
2111 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2113 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2115 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2116 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2118 : 48              >            pha         ;use stack to load status
2119 : a97f            >            lda #$7f     ;precharge accu
211b : 28              >            plp
                        
211c : d11c                     cmp (ind1),y
                                tst_a $7f,fzc
211e : 08              >            php         ;save flags
211f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2121 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2123 : 68              >            pla         ;load status
2124 : 48              >            pha
                       >            cmp_flag fzc
2125 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2127 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2129 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
212a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
212c : 48              >            pha         ;use stack to load status
212d : a97e            >            lda #$7e     ;precharge accu
212f : 28              >            plp
                        
2130 : d11c                     cmp (ind1),y
                                tst_a $7e,fn
2132 : 08              >            php         ;save flags
2133 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2135 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2137 : 68              >            pla         ;load status
2138 : 48              >            pha
                       >            cmp_flag fn
2139 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
213b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
213d : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
213e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2140 : 48              >            pha         ;use stack to load status
2141 : a980            >            lda #$80     ;precharge accu
2143 : 28              >            plp
                        
2144 : d11c                     cmp (ind1),y
                                tst_a $80,~fnz
2146 : 08              >            php         ;save flags
2147 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2149 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
214b : 68              >            pla         ;load status
214c : 48              >            pha
                       >            cmp_flag ~fnz
214d : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
214f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2151 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2152 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2154 : 48              >            pha         ;use stack to load status
2155 : a97f            >            lda #$7f     ;precharge accu
2157 : 28              >            plp
                        
2158 : d11c                     cmp (ind1),y
                                tst_a $7f,~fn
215a : 08              >            php         ;save flags
215b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
215d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
215f : 68              >            pla         ;load status
2160 : 48              >            pha
                       >            cmp_flag ~fn
2161 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2163 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2165 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2166 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2168 : 48              >            pha         ;use stack to load status
2169 : a97e            >            lda #$7e     ;precharge accu
216b : 28              >            plp
                        
216c : d11c                     cmp (ind1),y
                                tst_a $7e,~fzc
216e : 08              >            php         ;save flags
216f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2171 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2173 : 68              >            pla         ;load status
2174 : 48              >            pha
                       >            cmp_flag ~fzc
2175 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2177 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2179 : 28              >            plp         ;restore status
                        
                                next_test
217a : ad0002          >            lda test_case   ;previous test
217d : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
217f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
2181 : a91d            >            lda #test_num   ;*** next tests' number
2183 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
2186 : a205                     ldx #5
2188 :                  tasl
                                set_ax zps,0
                       >            load_flag 0
2188 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
218a : 48              >            pha         ;use stack to load status
218b : b509            >            lda zps,x    ;precharge accu
218d : 28              >            plp
                        
218e : 0a                       asl a
                                tst_ax rASL,fASL,0
218f : 08              >            php         ;save flags
2190 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2193 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2195 : 68              >            pla         ;load status
                       >            eor_flag 0
2196 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2198 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
219b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
219d : ca                       dex
219e : 10e8                     bpl tasl
21a0 : a205                     ldx #5
21a2 :                  tasl1
                                set_ax zps,$ff
                       >            load_flag $ff
21a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21a4 : 48              >            pha         ;use stack to load status
21a5 : b509            >            lda zps,x    ;precharge accu
21a7 : 28              >            plp
                        
21a8 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
21a9 : 08              >            php         ;save flags
21aa : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
21ad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
21af : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
21b0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
21b2 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
21b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
21b7 : ca                       dex
21b8 : 10e8                     bpl tasl1
                        
21ba : a205                     ldx #5
21bc :                  tlsr
                                set_ax zps,0
                       >            load_flag 0
21bc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21be : 48              >            pha         ;use stack to load status
21bf : b509            >            lda zps,x    ;precharge accu
21c1 : 28              >            plp
                        
21c2 : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
21c3 : 08              >            php         ;save flags
21c4 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
21c7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
21c9 : 68              >            pla         ;load status
                       >            eor_flag 0
21ca : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
21cc : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
21cf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
21d1 : ca                       dex
21d2 : 10e8                     bpl tlsr
21d4 : a205                     ldx #5
21d6 :                  tlsr1
                                set_ax zps,$ff
                       >            load_flag $ff
21d6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21d8 : 48              >            pha         ;use stack to load status
21d9 : b509            >            lda zps,x    ;precharge accu
21db : 28              >            plp
                        
21dc : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
21dd : 08              >            php         ;save flags
21de : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
21e1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
21e3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
21e4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
21e6 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
21e9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
21eb : ca                       dex
21ec : 10e8                     bpl tlsr1
                        
21ee : a205                     ldx #5
21f0 :                  trol
                                set_ax zps,0
                       >            load_flag 0
21f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21f2 : 48              >            pha         ;use stack to load status
21f3 : b509            >            lda zps,x    ;precharge accu
21f5 : 28              >            plp
                        
21f6 : 2a                       rol a
                                tst_ax rROL,fROL,0
21f7 : 08              >            php         ;save flags
21f8 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
21fb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
21fd : 68              >            pla         ;load status
                       >            eor_flag 0
21fe : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2200 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2203 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2205 : ca                       dex
2206 : 10e8                     bpl trol
2208 : a205                     ldx #5
220a :                  trol1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
220a : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
220c : 48              >            pha         ;use stack to load status
220d : b509            >            lda zps,x    ;precharge accu
220f : 28              >            plp
                        
2210 : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
2211 : 08              >            php         ;save flags
2212 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2215 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2217 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2218 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
221a : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
221d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
221f : ca                       dex
2220 : 10e8                     bpl trol1
                        
2222 : a205                     ldx #5
2224 :                  trolc
                                set_ax zps,fc
                       >            load_flag fc
2224 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2226 : 48              >            pha         ;use stack to load status
2227 : b509            >            lda zps,x    ;precharge accu
2229 : 28              >            plp
                        
222a : 2a                       rol a
                                tst_ax rROLc,fROLc,0
222b : 08              >            php         ;save flags
222c : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
222f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2231 : 68              >            pla         ;load status
                       >            eor_flag 0
2232 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2234 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2237 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2239 : ca                       dex
223a : 10e8                     bpl trolc
223c : a205                     ldx #5
223e :                  trolc1
                                set_ax zps,$ff
                       >            load_flag $ff
223e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2240 : 48              >            pha         ;use stack to load status
2241 : b509            >            lda zps,x    ;precharge accu
2243 : 28              >            plp
                        
2244 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
2245 : 08              >            php         ;save flags
2246 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2249 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
224b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
224c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
224e : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2251 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2253 : ca                       dex
2254 : 10e8                     bpl trolc1
                        
2256 : a205                     ldx #5
2258 :                  tror
                                set_ax zps,0
                       >            load_flag 0
2258 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
225a : 48              >            pha         ;use stack to load status
225b : b509            >            lda zps,x    ;precharge accu
225d : 28              >            plp
                        
225e : 6a                       ror a
                                tst_ax rROR,fROR,0
225f : 08              >            php         ;save flags
2260 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2263 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2265 : 68              >            pla         ;load status
                       >            eor_flag 0
2266 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2268 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
226b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
226d : ca                       dex
226e : 10e8                     bpl tror
2270 : a205                     ldx #5
2272 :                  tror1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
2272 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2274 : 48              >            pha         ;use stack to load status
2275 : b509            >            lda zps,x    ;precharge accu
2277 : 28              >            plp
                        
2278 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
2279 : 08              >            php         ;save flags
227a : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
227d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
227f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2280 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2282 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
2285 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2287 : ca                       dex
2288 : 10e8                     bpl tror1
                        
228a : a205                     ldx #5
228c :                  trorc
                                set_ax zps,fc
                       >            load_flag fc
228c : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
228e : 48              >            pha         ;use stack to load status
228f : b509            >            lda zps,x    ;precharge accu
2291 : 28              >            plp
                        
2292 : 6a                       ror a
                                tst_ax rRORc,fRORc,0
2293 : 08              >            php         ;save flags
2294 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2297 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2299 : 68              >            pla         ;load status
                       >            eor_flag 0
229a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
229c : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
229f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
22a1 : ca                       dex
22a2 : 10e8                     bpl trorc
22a4 : a205                     ldx #5
22a6 :                  trorc1
                                set_ax zps,$ff
                       >            load_flag $ff
22a6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22a8 : 48              >            pha         ;use stack to load status
22a9 : b509            >            lda zps,x    ;precharge accu
22ab : 28              >            plp
                        
22ac : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
22ad : 08              >            php         ;save flags
22ae : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
22b1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
22b3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22b4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
22b6 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
22b9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
22bb : ca                       dex
22bc : 10e8                     bpl trorc1
                                next_test
22be : ad0002          >            lda test_case   ;previous test
22c1 : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
22c3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
22c5 : a91e            >            lda #test_num   ;*** next tests' number
22c7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
22ca : a205                     ldx #5
22cc :                  tasl2
                                set_z zps,0
                       >            load_flag 0
22cc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22ce : 48              >            pha         ;use stack to load status
22cf : b509            >            lda zps,x    ;load to zeropage
22d1 : 8502            >            sta zpt
22d3 : 28              >            plp
                        
22d4 : 0602                     asl zpt
                                tst_z rASL,fASL,0
22d6 : 08              >            php         ;save flags
22d7 : a502            >            lda zpt
22d9 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
22dc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
22de : 68              >            pla         ;load status
                       >            eor_flag 0
22df : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22e1 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
22e4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
22e6 : ca                       dex
22e7 : 10e3                     bpl tasl2
22e9 : a205                     ldx #5
22eb :                  tasl3
                                set_z zps,$ff
                       >            load_flag $ff
22eb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22ed : 48              >            pha         ;use stack to load status
22ee : b509            >            lda zps,x    ;load to zeropage
22f0 : 8502            >            sta zpt
22f2 : 28              >            plp
                        
22f3 : 0602                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
22f5 : 08              >            php         ;save flags
22f6 : a502            >            lda zpt
22f8 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
22fb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
22fd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22fe : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2300 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2303 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2305 : ca                       dex
2306 : 10e3                     bpl tasl3
                        
2308 : a205                     ldx #5
230a :                  tlsr2
                                set_z zps,0
                       >            load_flag 0
230a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
230c : 48              >            pha         ;use stack to load status
230d : b509            >            lda zps,x    ;load to zeropage
230f : 8502            >            sta zpt
2311 : 28              >            plp
                        
2312 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,0
2314 : 08              >            php         ;save flags
2315 : a502            >            lda zpt
2317 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
231a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
231c : 68              >            pla         ;load status
                       >            eor_flag 0
231d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
231f : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2322 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2324 : ca                       dex
2325 : 10e3                     bpl tlsr2
2327 : a205                     ldx #5
2329 :                  tlsr3
                                set_z zps,$ff
                       >            load_flag $ff
2329 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
232b : 48              >            pha         ;use stack to load status
232c : b509            >            lda zps,x    ;load to zeropage
232e : 8502            >            sta zpt
2330 : 28              >            plp
                        
2331 : 4602                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
2333 : 08              >            php         ;save flags
2334 : a502            >            lda zpt
2336 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2339 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
233b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
233c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
233e : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2341 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2343 : ca                       dex
2344 : 10e3                     bpl tlsr3
                        
2346 : a205                     ldx #5
2348 :                  trol2
                                set_z zps,0
                       >            load_flag 0
2348 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
234a : 48              >            pha         ;use stack to load status
234b : b509            >            lda zps,x    ;load to zeropage
234d : 8502            >            sta zpt
234f : 28              >            plp
                        
2350 : 2602                     rol zpt
                                tst_z rROL,fROL,0
2352 : 08              >            php         ;save flags
2353 : a502            >            lda zpt
2355 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2358 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
235a : 68              >            pla         ;load status
                       >            eor_flag 0
235b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
235d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2360 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2362 : ca                       dex
2363 : 10e3                     bpl trol2
2365 : a205                     ldx #5
2367 :                  trol3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
2367 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2369 : 48              >            pha         ;use stack to load status
236a : b509            >            lda zps,x    ;load to zeropage
236c : 8502            >            sta zpt
236e : 28              >            plp
                        
236f : 2602                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
2371 : 08              >            php         ;save flags
2372 : a502            >            lda zpt
2374 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2377 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2379 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
237a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
237c : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
237f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2381 : ca                       dex
2382 : 10e3                     bpl trol3
                        
2384 : a205                     ldx #5
2386 :                  trolc2
                                set_z zps,fc
                       >            load_flag fc
2386 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2388 : 48              >            pha         ;use stack to load status
2389 : b509            >            lda zps,x    ;load to zeropage
238b : 8502            >            sta zpt
238d : 28              >            plp
                        
238e : 2602                     rol zpt
                                tst_z rROLc,fROLc,0
2390 : 08              >            php         ;save flags
2391 : a502            >            lda zpt
2393 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2396 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2398 : 68              >            pla         ;load status
                       >            eor_flag 0
2399 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
239b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
239e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
23a0 : ca                       dex
23a1 : 10e3                     bpl trolc2
23a3 : a205                     ldx #5
23a5 :                  trolc3
                                set_z zps,$ff
                       >            load_flag $ff
23a5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23a7 : 48              >            pha         ;use stack to load status
23a8 : b509            >            lda zps,x    ;load to zeropage
23aa : 8502            >            sta zpt
23ac : 28              >            plp
                        
23ad : 2602                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
23af : 08              >            php         ;save flags
23b0 : a502            >            lda zpt
23b2 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
23b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
23b7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23b8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23ba : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
23bd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
23bf : ca                       dex
23c0 : 10e3                     bpl trolc3
                        
23c2 : a205                     ldx #5
23c4 :                  tror2
                                set_z zps,0
                       >            load_flag 0
23c4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23c6 : 48              >            pha         ;use stack to load status
23c7 : b509            >            lda zps,x    ;load to zeropage
23c9 : 8502            >            sta zpt
23cb : 28              >            plp
                        
23cc : 6602                     ror zpt
                                tst_z rROR,fROR,0
23ce : 08              >            php         ;save flags
23cf : a502            >            lda zpt
23d1 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
23d4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
23d6 : 68              >            pla         ;load status
                       >            eor_flag 0
23d7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23d9 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
23dc : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
23de : ca                       dex
23df : 10e3                     bpl tror2
23e1 : a205                     ldx #5
23e3 :                  tror3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
23e3 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
23e5 : 48              >            pha         ;use stack to load status
23e6 : b509            >            lda zps,x    ;load to zeropage
23e8 : 8502            >            sta zpt
23ea : 28              >            plp
                        
23eb : 6602                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
23ed : 08              >            php         ;save flags
23ee : a502            >            lda zpt
23f0 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
23f3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
23f5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23f6 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23f8 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
23fb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
23fd : ca                       dex
23fe : 10e3                     bpl tror3
                        
2400 : a205                     ldx #5
2402 :                  trorc2
                                set_z zps,fc
                       >            load_flag fc
2402 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2404 : 48              >            pha         ;use stack to load status
2405 : b509            >            lda zps,x    ;load to zeropage
2407 : 8502            >            sta zpt
2409 : 28              >            plp
                        
240a : 6602                     ror zpt
                                tst_z rRORc,fRORc,0
240c : 08              >            php         ;save flags
240d : a502            >            lda zpt
240f : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2412 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2414 : 68              >            pla         ;load status
                       >            eor_flag 0
2415 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2417 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
241a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
241c : ca                       dex
241d : 10e3                     bpl trorc2
241f : a205                     ldx #5
2421 :                  trorc3
                                set_z zps,$ff
                       >            load_flag $ff
2421 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2423 : 48              >            pha         ;use stack to load status
2424 : b509            >            lda zps,x    ;load to zeropage
2426 : 8502            >            sta zpt
2428 : 28              >            plp
                        
2429 : 6602                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
242b : 08              >            php         ;save flags
242c : a502            >            lda zpt
242e : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2431 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2433 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2434 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2436 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2439 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
243b : ca                       dex
243c : 10e3                     bpl trorc3
                                next_test
243e : ad0002          >            lda test_case   ;previous test
2441 : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2443 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
2445 : a91f            >            lda #test_num   ;*** next tests' number
2447 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
244a : a205                     ldx #5
244c :                  tasl4
                                set_abs zps,0
                       >            load_flag 0
244c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
244e : 48              >            pha         ;use stack to load status
244f : b509            >            lda zps,x    ;load to memory
2451 : 8d0302          >            sta abst
2454 : 28              >            plp
                        
2455 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
2458 : 08              >            php         ;save flags
2459 : ad0302          >            lda abst
245c : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
245f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2461 : 68              >            pla         ;load status
                       >            eor_flag 0
2462 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2464 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2467 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2469 : ca                       dex
246a : 10e0                     bpl tasl4
246c : a205                     ldx #5
246e :                  tasl5
                                set_abs zps,$ff
                       >            load_flag $ff
246e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2470 : 48              >            pha         ;use stack to load status
2471 : b509            >            lda zps,x    ;load to memory
2473 : 8d0302          >            sta abst
2476 : 28              >            plp
                        
2477 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
247a : 08              >            php         ;save flags
247b : ad0302          >            lda abst
247e : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2481 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2483 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2484 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2486 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2489 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
248b : ca                       dex
248c : 10e0                     bpl tasl5
                        
248e : a205                     ldx #5
2490 :                  tlsr4
                                set_abs zps,0
                       >            load_flag 0
2490 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2492 : 48              >            pha         ;use stack to load status
2493 : b509            >            lda zps,x    ;load to memory
2495 : 8d0302          >            sta abst
2498 : 28              >            plp
                        
2499 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
249c : 08              >            php         ;save flags
249d : ad0302          >            lda abst
24a0 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
24a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
24a5 : 68              >            pla         ;load status
                       >            eor_flag 0
24a6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24a8 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
24ab : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
24ad : ca                       dex
24ae : 10e0                     bpl tlsr4
24b0 : a205                     ldx #5
24b2 :                  tlsr5
                                set_abs zps,$ff
                       >            load_flag $ff
24b2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
24b4 : 48              >            pha         ;use stack to load status
24b5 : b509            >            lda zps,x    ;load to memory
24b7 : 8d0302          >            sta abst
24ba : 28              >            plp
                        
24bb : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
24be : 08              >            php         ;save flags
24bf : ad0302          >            lda abst
24c2 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
24c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
24c7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24c8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24ca : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
24cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
24cf : ca                       dex
24d0 : 10e0                     bpl tlsr5
                        
24d2 : a205                     ldx #5
24d4 :                  trol4
                                set_abs zps,0
                       >            load_flag 0
24d4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24d6 : 48              >            pha         ;use stack to load status
24d7 : b509            >            lda zps,x    ;load to memory
24d9 : 8d0302          >            sta abst
24dc : 28              >            plp
                        
24dd : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
24e0 : 08              >            php         ;save flags
24e1 : ad0302          >            lda abst
24e4 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
24e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
24e9 : 68              >            pla         ;load status
                       >            eor_flag 0
24ea : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24ec : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
24ef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
24f1 : ca                       dex
24f2 : 10e0                     bpl trol4
24f4 : a205                     ldx #5
24f6 :                  trol5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
24f6 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
24f8 : 48              >            pha         ;use stack to load status
24f9 : b509            >            lda zps,x    ;load to memory
24fb : 8d0302          >            sta abst
24fe : 28              >            plp
                        
24ff : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
2502 : 08              >            php         ;save flags
2503 : ad0302          >            lda abst
2506 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2509 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
250b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
250c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
250e : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2511 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2513 : ca                       dex
2514 : 10e0                     bpl trol5
                        
2516 : a205                     ldx #5
2518 :                  trolc4
                                set_abs zps,fc
                       >            load_flag fc
2518 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
251a : 48              >            pha         ;use stack to load status
251b : b509            >            lda zps,x    ;load to memory
251d : 8d0302          >            sta abst
2520 : 28              >            plp
                        
2521 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
2524 : 08              >            php         ;save flags
2525 : ad0302          >            lda abst
2528 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
252b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
252d : 68              >            pla         ;load status
                       >            eor_flag 0
252e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2530 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2533 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2535 : ca                       dex
2536 : 10e0                     bpl trolc4
2538 : a205                     ldx #5
253a :                  trolc5
                                set_abs zps,$ff
                       >            load_flag $ff
253a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
253c : 48              >            pha         ;use stack to load status
253d : b509            >            lda zps,x    ;load to memory
253f : 8d0302          >            sta abst
2542 : 28              >            plp
                        
2543 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
2546 : 08              >            php         ;save flags
2547 : ad0302          >            lda abst
254a : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
254d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
254f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2550 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2552 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2555 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2557 : ca                       dex
2558 : 10e0                     bpl trolc5
                        
255a : a205                     ldx #5
255c :                  tror4
                                set_abs zps,0
                       >            load_flag 0
255c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
255e : 48              >            pha         ;use stack to load status
255f : b509            >            lda zps,x    ;load to memory
2561 : 8d0302          >            sta abst
2564 : 28              >            plp
                        
2565 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2568 : 08              >            php         ;save flags
2569 : ad0302          >            lda abst
256c : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
256f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2571 : 68              >            pla         ;load status
                       >            eor_flag 0
2572 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2574 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2577 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2579 : ca                       dex
257a : 10e0                     bpl tror4
257c : a205                     ldx #5
257e :                  tror5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
257e : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2580 : 48              >            pha         ;use stack to load status
2581 : b509            >            lda zps,x    ;load to memory
2583 : 8d0302          >            sta abst
2586 : 28              >            plp
                        
2587 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
258a : 08              >            php         ;save flags
258b : ad0302          >            lda abst
258e : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2591 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2593 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2594 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2596 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2599 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
259b : ca                       dex
259c : 10e0                     bpl tror5
                        
259e : a205                     ldx #5
25a0 :                  trorc4
                                set_abs zps,fc
                       >            load_flag fc
25a0 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
25a2 : 48              >            pha         ;use stack to load status
25a3 : b509            >            lda zps,x    ;load to memory
25a5 : 8d0302          >            sta abst
25a8 : 28              >            plp
                        
25a9 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
25ac : 08              >            php         ;save flags
25ad : ad0302          >            lda abst
25b0 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
25b3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
25b5 : 68              >            pla         ;load status
                       >            eor_flag 0
25b6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25b8 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
25bb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
25bd : ca                       dex
25be : 10e0                     bpl trorc4
25c0 : a205                     ldx #5
25c2 :                  trorc5
                                set_abs zps,$ff
                       >            load_flag $ff
25c2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
25c4 : 48              >            pha         ;use stack to load status
25c5 : b509            >            lda zps,x    ;load to memory
25c7 : 8d0302          >            sta abst
25ca : 28              >            plp
                        
25cb : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
25ce : 08              >            php         ;save flags
25cf : ad0302          >            lda abst
25d2 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
25d5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
25d7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25d8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25da : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
25dd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
25df : ca                       dex
25e0 : 10e0                     bpl trorc5
                                next_test
25e2 : ad0002          >            lda test_case   ;previous test
25e5 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
25e7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
25e9 : a920            >            lda #test_num   ;*** next tests' number
25eb : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
25ee : a205                     ldx #5
25f0 :                  tasl6
                                set_zx zps,0
                       >            load_flag 0
25f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25f2 : 48              >            pha         ;use stack to load status
25f3 : b509            >            lda zps,x    ;load to indexed zeropage
25f5 : 9502            >            sta zpt,x
25f7 : 28              >            plp
                        
25f8 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,0
25fa : 08              >            php         ;save flags
25fb : b502            >            lda zpt,x
25fd : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2600 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2602 : 68              >            pla         ;load status
                       >            eor_flag 0
2603 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2605 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2608 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
260a : ca                       dex
260b : 10e3                     bpl tasl6
260d : a205                     ldx #5
260f :                  tasl7
                                set_zx zps,$ff
                       >            load_flag $ff
260f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2611 : 48              >            pha         ;use stack to load status
2612 : b509            >            lda zps,x    ;load to indexed zeropage
2614 : 9502            >            sta zpt,x
2616 : 28              >            plp
                        
2617 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2619 : 08              >            php         ;save flags
261a : b502            >            lda zpt,x
261c : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
261f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2621 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2622 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2624 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2627 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2629 : ca                       dex
262a : 10e3                     bpl tasl7
                        
262c : a205                     ldx #5
262e :                  tlsr6
                                set_zx zps,0
                       >            load_flag 0
262e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2630 : 48              >            pha         ;use stack to load status
2631 : b509            >            lda zps,x    ;load to indexed zeropage
2633 : 9502            >            sta zpt,x
2635 : 28              >            plp
                        
2636 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2638 : 08              >            php         ;save flags
2639 : b502            >            lda zpt,x
263b : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
263e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2640 : 68              >            pla         ;load status
                       >            eor_flag 0
2641 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2643 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2646 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2648 : ca                       dex
2649 : 10e3                     bpl tlsr6
264b : a205                     ldx #5
264d :                  tlsr7
                                set_zx zps,$ff
                       >            load_flag $ff
264d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
264f : 48              >            pha         ;use stack to load status
2650 : b509            >            lda zps,x    ;load to indexed zeropage
2652 : 9502            >            sta zpt,x
2654 : 28              >            plp
                        
2655 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
2657 : 08              >            php         ;save flags
2658 : b502            >            lda zpt,x
265a : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
265d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
265f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2660 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2662 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2665 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2667 : ca                       dex
2668 : 10e3                     bpl tlsr7
                        
266a : a205                     ldx #5
266c :                  trol6
                                set_zx zps,0
                       >            load_flag 0
266c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
266e : 48              >            pha         ;use stack to load status
266f : b509            >            lda zps,x    ;load to indexed zeropage
2671 : 9502            >            sta zpt,x
2673 : 28              >            plp
                        
2674 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,0
2676 : 08              >            php         ;save flags
2677 : b502            >            lda zpt,x
2679 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
267c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
267e : 68              >            pla         ;load status
                       >            eor_flag 0
267f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2681 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2684 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2686 : ca                       dex
2687 : 10e3                     bpl trol6
2689 : a205                     ldx #5
268b :                  trol7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
268b : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
268d : 48              >            pha         ;use stack to load status
268e : b509            >            lda zps,x    ;load to indexed zeropage
2690 : 9502            >            sta zpt,x
2692 : 28              >            plp
                        
2693 : 3602                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
2695 : 08              >            php         ;save flags
2696 : b502            >            lda zpt,x
2698 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
269b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
269d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
269e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26a0 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
26a3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
26a5 : ca                       dex
26a6 : 10e3                     bpl trol7
                        
26a8 : a205                     ldx #5
26aa :                  trolc6
                                set_zx zps,fc
                       >            load_flag fc
26aa : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
26ac : 48              >            pha         ;use stack to load status
26ad : b509            >            lda zps,x    ;load to indexed zeropage
26af : 9502            >            sta zpt,x
26b1 : 28              >            plp
                        
26b2 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,0
26b4 : 08              >            php         ;save flags
26b5 : b502            >            lda zpt,x
26b7 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
26ba : d0fe            >        bne *         ;failed not equal (non zero)
                       >
26bc : 68              >            pla         ;load status
                       >            eor_flag 0
26bd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26bf : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
26c2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
26c4 : ca                       dex
26c5 : 10e3                     bpl trolc6
26c7 : a205                     ldx #5
26c9 :                  trolc7
                                set_zx zps,$ff
                       >            load_flag $ff
26c9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26cb : 48              >            pha         ;use stack to load status
26cc : b509            >            lda zps,x    ;load to indexed zeropage
26ce : 9502            >            sta zpt,x
26d0 : 28              >            plp
                        
26d1 : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
26d3 : 08              >            php         ;save flags
26d4 : b502            >            lda zpt,x
26d6 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
26d9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
26db : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26dc : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26de : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
26e1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
26e3 : ca                       dex
26e4 : 10e3                     bpl trolc7
                        
26e6 : a205                     ldx #5
26e8 :                  tror6
                                set_zx zps,0
                       >            load_flag 0
26e8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26ea : 48              >            pha         ;use stack to load status
26eb : b509            >            lda zps,x    ;load to indexed zeropage
26ed : 9502            >            sta zpt,x
26ef : 28              >            plp
                        
26f0 : 7602                     ror zpt,x
                                tst_zx rROR,fROR,0
26f2 : 08              >            php         ;save flags
26f3 : b502            >            lda zpt,x
26f5 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
26f8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
26fa : 68              >            pla         ;load status
                       >            eor_flag 0
26fb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26fd : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2700 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2702 : ca                       dex
2703 : 10e3                     bpl tror6
2705 : a205                     ldx #5
2707 :                  tror7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
2707 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2709 : 48              >            pha         ;use stack to load status
270a : b509            >            lda zps,x    ;load to indexed zeropage
270c : 9502            >            sta zpt,x
270e : 28              >            plp
                        
270f : 7602                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
2711 : 08              >            php         ;save flags
2712 : b502            >            lda zpt,x
2714 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2717 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2719 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
271a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
271c : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
271f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2721 : ca                       dex
2722 : 10e3                     bpl tror7
                        
2724 : a205                     ldx #5
2726 :                  trorc6
                                set_zx zps,fc
                       >            load_flag fc
2726 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2728 : 48              >            pha         ;use stack to load status
2729 : b509            >            lda zps,x    ;load to indexed zeropage
272b : 9502            >            sta zpt,x
272d : 28              >            plp
                        
272e : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,0
2730 : 08              >            php         ;save flags
2731 : b502            >            lda zpt,x
2733 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2736 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2738 : 68              >            pla         ;load status
                       >            eor_flag 0
2739 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
273b : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
273e : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2740 : ca                       dex
2741 : 10e3                     bpl trorc6
2743 : a205                     ldx #5
2745 :                  trorc7
                                set_zx zps,$ff
                       >            load_flag $ff
2745 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2747 : 48              >            pha         ;use stack to load status
2748 : b509            >            lda zps,x    ;load to indexed zeropage
274a : 9502            >            sta zpt,x
274c : 28              >            plp
                        
274d : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
274f : 08              >            php         ;save flags
2750 : b502            >            lda zpt,x
2752 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2755 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2757 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2758 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
275a : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
275d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
275f : ca                       dex
2760 : 10e3                     bpl trorc7
                                next_test
2762 : ad0002          >            lda test_case   ;previous test
2765 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2767 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2769 : a921            >            lda #test_num   ;*** next tests' number
276b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
276e : a205                     ldx #5
2770 :                  tasl8
                                set_absx zps,0
                       >            load_flag 0
2770 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2772 : 48              >            pha         ;use stack to load status
2773 : b509            >            lda zps,x    ;load to indexed memory
2775 : 9d0302          >            sta abst,x
2778 : 28              >            plp
                        
2779 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
277c : 08              >            php         ;save flags
277d : bd0302          >            lda abst,x
2780 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2783 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2785 : 68              >            pla         ;load status
                       >            eor_flag 0
2786 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2788 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
278b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
278d : ca                       dex
278e : 10e0                     bpl tasl8
2790 : a205                     ldx #5
2792 :                  tasl9
                                set_absx zps,$ff
                       >            load_flag $ff
2792 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2794 : 48              >            pha         ;use stack to load status
2795 : b509            >            lda zps,x    ;load to indexed memory
2797 : 9d0302          >            sta abst,x
279a : 28              >            plp
                        
279b : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
279e : 08              >            php         ;save flags
279f : bd0302          >            lda abst,x
27a2 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
27a5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
27a7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27a8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27aa : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
27ad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
27af : ca                       dex
27b0 : 10e0                     bpl tasl9
                        
27b2 : a205                     ldx #5
27b4 :                  tlsr8
                                set_absx zps,0
                       >            load_flag 0
27b4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27b6 : 48              >            pha         ;use stack to load status
27b7 : b509            >            lda zps,x    ;load to indexed memory
27b9 : 9d0302          >            sta abst,x
27bc : 28              >            plp
                        
27bd : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
27c0 : 08              >            php         ;save flags
27c1 : bd0302          >            lda abst,x
27c4 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
27c7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
27c9 : 68              >            pla         ;load status
                       >            eor_flag 0
27ca : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27cc : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
27cf : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
27d1 : ca                       dex
27d2 : 10e0                     bpl tlsr8
27d4 : a205                     ldx #5
27d6 :                  tlsr9
                                set_absx zps,$ff
                       >            load_flag $ff
27d6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27d8 : 48              >            pha         ;use stack to load status
27d9 : b509            >            lda zps,x    ;load to indexed memory
27db : 9d0302          >            sta abst,x
27de : 28              >            plp
                        
27df : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
27e2 : 08              >            php         ;save flags
27e3 : bd0302          >            lda abst,x
27e6 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
27e9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
27eb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27ec : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27ee : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
27f1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
27f3 : ca                       dex
27f4 : 10e0                     bpl tlsr9
                        
27f6 : a205                     ldx #5
27f8 :                  trol8
                                set_absx zps,0
                       >            load_flag 0
27f8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27fa : 48              >            pha         ;use stack to load status
27fb : b509            >            lda zps,x    ;load to indexed memory
27fd : 9d0302          >            sta abst,x
2800 : 28              >            plp
                        
2801 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
2804 : 08              >            php         ;save flags
2805 : bd0302          >            lda abst,x
2808 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
280b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
280d : 68              >            pla         ;load status
                       >            eor_flag 0
280e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2810 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2813 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2815 : ca                       dex
2816 : 10e0                     bpl trol8
2818 : a205                     ldx #5
281a :                  trol9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
281a : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
281c : 48              >            pha         ;use stack to load status
281d : b509            >            lda zps,x    ;load to indexed memory
281f : 9d0302          >            sta abst,x
2822 : 28              >            plp
                        
2823 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2826 : 08              >            php         ;save flags
2827 : bd0302          >            lda abst,x
282a : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
282d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
282f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2830 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2832 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2835 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2837 : ca                       dex
2838 : 10e0                     bpl trol9
                        
283a : a205                     ldx #5
283c :                  trolc8
                                set_absx zps,fc
                       >            load_flag fc
283c : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
283e : 48              >            pha         ;use stack to load status
283f : b509            >            lda zps,x    ;load to indexed memory
2841 : 9d0302          >            sta abst,x
2844 : 28              >            plp
                        
2845 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2848 : 08              >            php         ;save flags
2849 : bd0302          >            lda abst,x
284c : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
284f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2851 : 68              >            pla         ;load status
                       >            eor_flag 0
2852 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2854 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2857 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2859 : ca                       dex
285a : 10e0                     bpl trolc8
285c : a205                     ldx #5
285e :                  trolc9
                                set_absx zps,$ff
                       >            load_flag $ff
285e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2860 : 48              >            pha         ;use stack to load status
2861 : b509            >            lda zps,x    ;load to indexed memory
2863 : 9d0302          >            sta abst,x
2866 : 28              >            plp
                        
2867 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
286a : 08              >            php         ;save flags
286b : bd0302          >            lda abst,x
286e : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2871 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2873 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2874 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2876 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2879 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
287b : ca                       dex
287c : 10e0                     bpl trolc9
                        
287e : a205                     ldx #5
2880 :                  tror8
                                set_absx zps,0
                       >            load_flag 0
2880 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2882 : 48              >            pha         ;use stack to load status
2883 : b509            >            lda zps,x    ;load to indexed memory
2885 : 9d0302          >            sta abst,x
2888 : 28              >            plp
                        
2889 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
288c : 08              >            php         ;save flags
288d : bd0302          >            lda abst,x
2890 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2893 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2895 : 68              >            pla         ;load status
                       >            eor_flag 0
2896 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2898 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
289b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
289d : ca                       dex
289e : 10e0                     bpl tror8
28a0 : a205                     ldx #5
28a2 :                  tror9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
28a2 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
28a4 : 48              >            pha         ;use stack to load status
28a5 : b509            >            lda zps,x    ;load to indexed memory
28a7 : 9d0302          >            sta abst,x
28aa : 28              >            plp
                        
28ab : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
28ae : 08              >            php         ;save flags
28af : bd0302          >            lda abst,x
28b2 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
28b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
28b7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28b8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28ba : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
28bd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
28bf : ca                       dex
28c0 : 10e0                     bpl tror9
                        
28c2 : a205                     ldx #5
28c4 :                  trorc8
                                set_absx zps,fc
                       >            load_flag fc
28c4 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
28c6 : 48              >            pha         ;use stack to load status
28c7 : b509            >            lda zps,x    ;load to indexed memory
28c9 : 9d0302          >            sta abst,x
28cc : 28              >            plp
                        
28cd : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
28d0 : 08              >            php         ;save flags
28d1 : bd0302          >            lda abst,x
28d4 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
28d7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
28d9 : 68              >            pla         ;load status
                       >            eor_flag 0
28da : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28dc : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
28df : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
28e1 : ca                       dex
28e2 : 10e0                     bpl trorc8
28e4 : a205                     ldx #5
28e6 :                  trorc9
                                set_absx zps,$ff
                       >            load_flag $ff
28e6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28e8 : 48              >            pha         ;use stack to load status
28e9 : b509            >            lda zps,x    ;load to indexed memory
28eb : 9d0302          >            sta abst,x
28ee : 28              >            plp
                        
28ef : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
28f2 : 08              >            php         ;save flags
28f3 : bd0302          >            lda abst,x
28f6 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
28f9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
28fb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28fc : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28fe : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2901 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2903 : ca                       dex
2904 : 10e0                     bpl trorc9
                                next_test
2906 : ad0002          >            lda test_case   ;previous test
2909 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
290b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
290d : a922            >            lda #test_num   ;*** next tests' number
290f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2912 : a200                     ldx #0
2914 : a97e                     lda #$7e
2916 : 8502                     sta zpt
2918 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2918 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
291a : 48              >            pha         ;use stack to load status
291b : 28              >            plp
                        
291c : e602                     inc zpt
                                tst_z rINC,fINC,0
291e : 08              >            php         ;save flags
291f : a502            >            lda zpt
2921 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2924 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2926 : 68              >            pla         ;load status
                       >            eor_flag 0
2927 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2929 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
292c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
292e : e8                       inx
292f : e002                     cpx #2
2931 : d004                     bne tinc1
2933 : a9fe                     lda #$fe
2935 : 8502                     sta zpt
2937 : e005             tinc1   cpx #5
2939 : d0dd                     bne tinc
293b : ca                       dex
293c : e602                     inc zpt
293e :                  tdec    
                                set_stat 0
                       >            load_flag 0
293e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2940 : 48              >            pha         ;use stack to load status
2941 : 28              >            plp
                        
2942 : c602                     dec zpt
                                tst_z rINC,fINC,0
2944 : 08              >            php         ;save flags
2945 : a502            >            lda zpt
2947 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
294a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
294c : 68              >            pla         ;load status
                       >            eor_flag 0
294d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
294f : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2952 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2954 : ca                       dex
2955 : 300a                     bmi tdec1
2957 : e001                     cpx #1
2959 : d0e3                     bne tdec
295b : a981                     lda #$81
295d : 8502                     sta zpt
295f : d0dd                     bne tdec
2961 :                  tdec1
2961 : a200                     ldx #0
2963 : a97e                     lda #$7e
2965 : 8502                     sta zpt
2967 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2967 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2969 : 48              >            pha         ;use stack to load status
296a : 28              >            plp
                        
296b : e602                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
296d : 08              >            php         ;save flags
296e : a502            >            lda zpt
2970 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2973 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2975 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2976 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2978 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
297b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
297d : e8                       inx
297e : e002                     cpx #2
2980 : d004                     bne tinc11
2982 : a9fe                     lda #$fe
2984 : 8502                     sta zpt
2986 : e005             tinc11  cpx #5
2988 : d0dd                     bne tinc10
298a : ca                       dex
298b : e602                     inc zpt
298d :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
298d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
298f : 48              >            pha         ;use stack to load status
2990 : 28              >            plp
                        
2991 : c602                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2993 : 08              >            php         ;save flags
2994 : a502            >            lda zpt
2996 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2999 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
299b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
299c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
299e : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
29a1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
29a3 : ca                       dex
29a4 : 300a                     bmi tdec11
29a6 : e001                     cpx #1
29a8 : d0e3                     bne tdec10
29aa : a981                     lda #$81
29ac : 8502                     sta zpt
29ae : d0dd                     bne tdec10
29b0 :                  tdec11
                                next_test
29b0 : ad0002          >            lda test_case   ;previous test
29b3 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
29b5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
29b7 : a923            >            lda #test_num   ;*** next tests' number
29b9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
29bc : a200                     ldx #0
29be : a97e                     lda #$7e
29c0 : 8d0302                   sta abst
29c3 :                  tinc2    
                                set_stat 0
                       >            load_flag 0
29c3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
29c5 : 48              >            pha         ;use stack to load status
29c6 : 28              >            plp
                        
29c7 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
29ca : 08              >            php         ;save flags
29cb : ad0302          >            lda abst
29ce : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
29d1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
29d3 : 68              >            pla         ;load status
                       >            eor_flag 0
29d4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29d6 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
29d9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
29db : e8                       inx
29dc : e002                     cpx #2
29de : d005                     bne tinc3
29e0 : a9fe                     lda #$fe
29e2 : 8d0302                   sta abst
29e5 : e005             tinc3   cpx #5
29e7 : d0da                     bne tinc2
29e9 : ca                       dex
29ea : ee0302                   inc abst
29ed :                  tdec2    
                                set_stat 0
                       >            load_flag 0
29ed : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
29ef : 48              >            pha         ;use stack to load status
29f0 : 28              >            plp
                        
29f1 : ce0302                   dec abst
                                tst_abs rINC,fINC,0
29f4 : 08              >            php         ;save flags
29f5 : ad0302          >            lda abst
29f8 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
29fb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
29fd : 68              >            pla         ;load status
                       >            eor_flag 0
29fe : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a00 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a03 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2a05 : ca                       dex
2a06 : 300b                     bmi tdec3
2a08 : e001                     cpx #1
2a0a : d0e1                     bne tdec2
2a0c : a981                     lda #$81
2a0e : 8d0302                   sta abst
2a11 : d0da                     bne tdec2
2a13 :                  tdec3
2a13 : a200                     ldx #0
2a15 : a97e                     lda #$7e
2a17 : 8d0302                   sta abst
2a1a :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2a1a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a1c : 48              >            pha         ;use stack to load status
2a1d : 28              >            plp
                        
2a1e : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2a21 : 08              >            php         ;save flags
2a22 : ad0302          >            lda abst
2a25 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a28 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2a2a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a2b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a2d : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a30 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2a32 : e8                       inx
2a33 : e002                     cpx #2
2a35 : d005                     bne tinc13
2a37 : a9fe                     lda #$fe
2a39 : 8d0302                   sta abst
2a3c : e005             tinc13   cpx #5
2a3e : d0da                     bne tinc12
2a40 : ca                       dex
2a41 : ee0302                   inc abst
2a44 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2a44 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a46 : 48              >            pha         ;use stack to load status
2a47 : 28              >            plp
                        
2a48 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2a4b : 08              >            php         ;save flags
2a4c : ad0302          >            lda abst
2a4f : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a52 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2a54 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a55 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2a57 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a5a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2a5c : ca                       dex
2a5d : 300b                     bmi tdec13
2a5f : e001                     cpx #1
2a61 : d0e1                     bne tdec12
2a63 : a981                     lda #$81
2a65 : 8d0302                   sta abst
2a68 : d0da                     bne tdec12
2a6a :                  tdec13
                                next_test
2a6a : ad0002          >            lda test_case   ;previous test
2a6d : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2a6f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2a71 : a924            >            lda #test_num   ;*** next tests' number
2a73 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2a76 : a200                     ldx #0
2a78 : a97e                     lda #$7e
2a7a : 9502             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2a7c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a7e : 48              >            pha         ;use stack to load status
2a7f : 28              >            plp
                        
2a80 : f602                     inc zpt,x
                                tst_zx rINC,fINC,0
2a82 : 08              >            php         ;save flags
2a83 : b502            >            lda zpt,x
2a85 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a88 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2a8a : 68              >            pla         ;load status
                       >            eor_flag 0
2a8b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a8d : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a90 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2a92 : b502                     lda zpt,x
2a94 : e8                       inx
2a95 : e002                     cpx #2
2a97 : d002                     bne tinc5
2a99 : a9fe                     lda #$fe
2a9b : e005             tinc5   cpx #5
2a9d : d0db                     bne tinc4
2a9f : ca                       dex
2aa0 : a902                     lda #2
2aa2 : 9502             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2aa4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2aa6 : 48              >            pha         ;use stack to load status
2aa7 : 28              >            plp
                        
2aa8 : d602                     dec zpt,x
                                tst_zx rINC,fINC,0
2aaa : 08              >            php         ;save flags
2aab : b502            >            lda zpt,x
2aad : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ab0 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2ab2 : 68              >            pla         ;load status
                       >            eor_flag 0
2ab3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ab5 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ab8 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2aba : b502                     lda zpt,x
2abc : ca                       dex
2abd : 3008                     bmi tdec5
2abf : e001                     cpx #1
2ac1 : d0df                     bne tdec4
2ac3 : a981                     lda #$81
2ac5 : d0db                     bne tdec4
2ac7 :                  tdec5
2ac7 : a200                     ldx #0
2ac9 : a97e                     lda #$7e
2acb : 9502             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2acd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2acf : 48              >            pha         ;use stack to load status
2ad0 : 28              >            plp
                        
2ad1 : f602                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2ad3 : 08              >            php         ;save flags
2ad4 : b502            >            lda zpt,x
2ad6 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ad9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2adb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2adc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ade : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ae1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ae3 : b502                     lda zpt,x
2ae5 : e8                       inx
2ae6 : e002                     cpx #2
2ae8 : d002                     bne tinc15
2aea : a9fe                     lda #$fe
2aec : e005             tinc15  cpx #5
2aee : d0db                     bne tinc14
2af0 : ca                       dex
2af1 : a902                     lda #2
2af3 : 9502             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2af5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2af7 : 48              >            pha         ;use stack to load status
2af8 : 28              >            plp
                        
2af9 : d602                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2afb : 08              >            php         ;save flags
2afc : b502            >            lda zpt,x
2afe : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b01 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2b03 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b04 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b06 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b09 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2b0b : b502                     lda zpt,x
2b0d : ca                       dex
2b0e : 3008                     bmi tdec15
2b10 : e001                     cpx #1
2b12 : d0df                     bne tdec14
2b14 : a981                     lda #$81
2b16 : d0db                     bne tdec14
2b18 :                  tdec15
                                next_test
2b18 : ad0002          >            lda test_case   ;previous test
2b1b : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b1d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2b1f : a925            >            lda #test_num   ;*** next tests' number
2b21 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2b24 : a200                     ldx #0
2b26 : a97e                     lda #$7e
2b28 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2b2b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b2d : 48              >            pha         ;use stack to load status
2b2e : 28              >            plp
                        
2b2f : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2b32 : 08              >            php         ;save flags
2b33 : bd0302          >            lda abst,x
2b36 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b39 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2b3b : 68              >            pla         ;load status
                       >            eor_flag 0
2b3c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b3e : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2b43 : bd0302                   lda abst,x
2b46 : e8                       inx
2b47 : e002                     cpx #2
2b49 : d002                     bne tinc7
2b4b : a9fe                     lda #$fe
2b4d : e005             tinc7   cpx #5
2b4f : d0d7                     bne tinc6
2b51 : ca                       dex
2b52 : a902                     lda #2
2b54 : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2b57 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b59 : 48              >            pha         ;use stack to load status
2b5a : 28              >            plp
                        
2b5b : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2b5e : 08              >            php         ;save flags
2b5f : bd0302          >            lda abst,x
2b62 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b65 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2b67 : 68              >            pla         ;load status
                       >            eor_flag 0
2b68 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b6a : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b6d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2b6f : bd0302                   lda abst,x
2b72 : ca                       dex
2b73 : 3008                     bmi tdec7
2b75 : e001                     cpx #1
2b77 : d0db                     bne tdec6
2b79 : a981                     lda #$81
2b7b : d0d7                     bne tdec6
2b7d :                  tdec7
2b7d : a200                     ldx #0
2b7f : a97e                     lda #$7e
2b81 : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2b84 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b86 : 48              >            pha         ;use stack to load status
2b87 : 28              >            plp
                        
2b88 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2b8b : 08              >            php         ;save flags
2b8c : bd0302          >            lda abst,x
2b8f : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b92 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2b94 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b95 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b97 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b9a : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2b9c : bd0302                   lda abst,x
2b9f : e8                       inx
2ba0 : e002                     cpx #2
2ba2 : d002                     bne tinc17
2ba4 : a9fe                     lda #$fe
2ba6 : e005             tinc17  cpx #5
2ba8 : d0d7                     bne tinc16
2baa : ca                       dex
2bab : a902                     lda #2
2bad : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2bb0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2bb2 : 48              >            pha         ;use stack to load status
2bb3 : 28              >            plp
                        
2bb4 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2bb7 : 08              >            php         ;save flags
2bb8 : bd0302          >            lda abst,x
2bbb : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2bbe : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2bc0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bc1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bc3 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bc6 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2bc8 : bd0302                   lda abst,x
2bcb : ca                       dex
2bcc : 3008                     bmi tdec17
2bce : e001                     cpx #1
2bd0 : d0db                     bne tdec16
2bd2 : a981                     lda #$81
2bd4 : d0d7                     bne tdec16
2bd6 :                  tdec17
                                next_test
2bd6 : ad0002          >            lda test_case   ;previous test
2bd9 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2bdb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2bdd : a926            >            lda #test_num   ;*** next tests' number
2bdf : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2be2 : a203                     ldx #3          ;immediate
2be4 : b514             tand    lda zpAN,x
2be6 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2be9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2beb : 48              >            pha         ;use stack to load status
2bec : bd6b02          >            lda absANa,x    ;precharge accu
2bef : 28              >            plp
                        
2bf0 : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2bf3 : 08              >            php         ;save flags
2bf4 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2bf7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2bf9 : 68              >            pla         ;load status
                       >            eor_flag 0
2bfa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2bfc : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2bff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c01 : ca                       dex
2c02 : 10e0                     bpl tand
2c04 : a203                     ldx #3
2c06 : b514             tand1   lda zpAN,x
2c08 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2c0b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c0d : 48              >            pha         ;use stack to load status
2c0e : bd6b02          >            lda absANa,x    ;precharge accu
2c11 : 28              >            plp
                        
2c12 : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2c15 : 08              >            php         ;save flags
2c16 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c19 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c1b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c1c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c1e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2c21 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c23 : ca                       dex
2c24 : 10e0                     bpl tand1
                            
2c26 : a203                     ldx #3      ;zp
2c28 : b514             tand2   lda zpAN,x
2c2a : 8502                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2c2c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c2e : 48              >            pha         ;use stack to load status
2c2f : bd6b02          >            lda absANa,x    ;precharge accu
2c32 : 28              >            plp
                        
2c33 : 2502                     and zpt
                                tst_ax  absrlo,absflo,0
2c35 : 08              >            php         ;save flags
2c36 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c39 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c3b : 68              >            pla         ;load status
                       >            eor_flag 0
2c3c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c3e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2c41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c43 : ca                       dex
2c44 : 10e2                     bpl tand2
2c46 : a203                     ldx #3
2c48 : b514             tand3   lda zpAN,x
2c4a : 8502                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2c4c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c4e : 48              >            pha         ;use stack to load status
2c4f : bd6b02          >            lda absANa,x    ;precharge accu
2c52 : 28              >            plp
                        
2c53 : 2502                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2c55 : 08              >            php         ;save flags
2c56 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c5b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c5c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c5e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2c61 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c63 : ca                       dex
2c64 : 10e2                     bpl tand3
                        
2c66 : a203                     ldx #3      ;abs
2c68 : b514             tand4   lda zpAN,x
2c6a : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2c6d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c6f : 48              >            pha         ;use stack to load status
2c70 : bd6b02          >            lda absANa,x    ;precharge accu
2c73 : 28              >            plp
                        
2c74 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2c77 : 08              >            php         ;save flags
2c78 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c7b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c7d : 68              >            pla         ;load status
                       >            eor_flag 0
2c7e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c80 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2c83 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2c85 : ca                       dex
2c86 : 10e0                     bpl tand4
2c88 : a203                     ldx #3
2c8a : b514             tand5   lda zpAN,x
2c8c : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2c8f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c91 : 48              >            pha         ;use stack to load status
2c92 : bd6b02          >            lda absANa,x    ;precharge accu
2c95 : 28              >            plp
                        
2c96 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2c99 : 08              >            php         ;save flags
2c9a : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2c9d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2c9f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ca0 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ca2 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ca5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ca7 : ca                       dex
2ca8 : 1002                     bpl tand6
                        
2caa : a203                     ldx #3      ;zp,x
2cac :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2cac : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cae : 48              >            pha         ;use stack to load status
2caf : bd6b02          >            lda absANa,x    ;precharge accu
2cb2 : 28              >            plp
                        
2cb3 : 3514                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2cb5 : 08              >            php         ;save flags
2cb6 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2cb9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2cbb : 68              >            pla         ;load status
                       >            eor_flag 0
2cbc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2cbe : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2cc1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2cc3 : ca                       dex
2cc4 : 10e6                     bpl tand6
2cc6 : a203                     ldx #3
2cc8 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2cc8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cca : 48              >            pha         ;use stack to load status
2ccb : bd6b02          >            lda absANa,x    ;precharge accu
2cce : 28              >            plp
                        
2ccf : 3514                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2cd1 : 08              >            php         ;save flags
2cd2 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2cd5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2cd7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cd8 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2cda : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2cdd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2cdf : ca                       dex
2ce0 : 10e6                     bpl tand7
                        
2ce2 : a203                     ldx #3      ;abs,x
2ce4 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2ce4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ce6 : 48              >            pha         ;use stack to load status
2ce7 : bd6b02          >            lda absANa,x    ;precharge accu
2cea : 28              >            plp
                        
2ceb : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2cee : 08              >            php         ;save flags
2cef : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2cf2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2cf4 : 68              >            pla         ;load status
                       >            eor_flag 0
2cf5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2cf7 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2cfa : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2cfc : ca                       dex
2cfd : 10e5                     bpl tand8
2cff : a203                     ldx #3
2d01 :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d01 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d03 : 48              >            pha         ;use stack to load status
2d04 : bd6b02          >            lda absANa,x    ;precharge accu
2d07 : 28              >            plp
                        
2d08 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2d0b : 08              >            php         ;save flags
2d0c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d0f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d11 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d12 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d14 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d17 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d19 : ca                       dex
2d1a : 10e5                     bpl tand9
                        
2d1c : a003                     ldy #3      ;abs,y
2d1e :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2d1e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d20 : 48              >            pha         ;use stack to load status
2d21 : b96b02          >            lda absANa,y    ;precharge accu
2d24 : 28              >            plp
                        
2d25 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2d28 : 08              >            php         ;save flags
2d29 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2d2c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d2e : 68              >            pla         ;load status
                       >            eor_flag 0
2d2f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d31 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2d34 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d36 : 88                       dey
2d37 : 10e5                     bpl tand10
2d39 : a003                     ldy #3
2d3b :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2d3b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d3d : 48              >            pha         ;use stack to load status
2d3e : b96b02          >            lda absANa,y    ;precharge accu
2d41 : 28              >            plp
                        
2d42 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2d45 : 08              >            php         ;save flags
2d46 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2d49 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d4b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d4c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d4e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2d51 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d53 : 88                       dey
2d54 : 10e5                     bpl tand11
                        
2d56 : a206                     ldx #6      ;(zp,x)
2d58 : a003                     ldy #3
2d5a :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2d5a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d5c : 48              >            pha         ;use stack to load status
2d5d : b96b02          >            lda absANa,y    ;precharge accu
2d60 : 28              >            plp
                        
2d61 : 2132                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2d63 : 08              >            php         ;save flags
2d64 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2d67 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d69 : 68              >            pla         ;load status
                       >            eor_flag 0
2d6a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d6c : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2d6f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d71 : ca                       dex
2d72 : ca                       dex
2d73 : 88                       dey
2d74 : 10e4                     bpl tand12
2d76 : a206                     ldx #6
2d78 : a003                     ldy #3
2d7a :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2d7a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d7c : 48              >            pha         ;use stack to load status
2d7d : b96b02          >            lda absANa,y    ;precharge accu
2d80 : 28              >            plp
                        
2d81 : 2132                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2d83 : 08              >            php         ;save flags
2d84 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2d87 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2d89 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d8a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d8c : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2d8f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2d91 : ca                       dex
2d92 : ca                       dex
2d93 : 88                       dey
2d94 : 10e4                     bpl tand13
                        
2d96 : a003                     ldy #3      ;(zp),y
2d98 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2d98 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d9a : 48              >            pha         ;use stack to load status
2d9b : b96b02          >            lda absANa,y    ;precharge accu
2d9e : 28              >            plp
                        
2d9f : 3132                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2da1 : 08              >            php         ;save flags
2da2 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2da5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2da7 : 68              >            pla         ;load status
                       >            eor_flag 0
2da8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2daa : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2dad : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2daf : 88                       dey
2db0 : 10e6                     bpl tand14
2db2 : a003                     ldy #3
2db4 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2db4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2db6 : 48              >            pha         ;use stack to load status
2db7 : b96b02          >            lda absANa,y    ;precharge accu
2dba : 28              >            plp
                        
2dbb : 3132                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2dbd : 08              >            php         ;save flags
2dbe : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2dc1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2dc3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dc4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2dc6 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2dc9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2dcb : 88                       dey
2dcc : 10e6                     bpl tand15
                                next_test
2dce : ad0002          >            lda test_case   ;previous test
2dd1 : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2dd3 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2dd5 : a927            >            lda #test_num   ;*** next tests' number
2dd7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2dda : a203                     ldx #3          ;immediate - self modifying code
2ddc : b518             teor    lda zpEO,x
2dde : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
2de1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2de3 : 48              >            pha         ;use stack to load status
2de4 : bd6f02          >            lda absEOa,x    ;precharge accu
2de7 : 28              >            plp
                        
2de8 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
2deb : 08              >            php         ;save flags
2dec : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2def : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2df1 : 68              >            pla         ;load status
                       >            eor_flag 0
2df2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2df4 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2df7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2df9 : ca                       dex
2dfa : 10e0                     bpl teor
2dfc : a203                     ldx #3
2dfe : b518             teor1   lda zpEO,x
2e00 : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2e03 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e05 : 48              >            pha         ;use stack to load status
2e06 : bd6f02          >            lda absEOa,x    ;precharge accu
2e09 : 28              >            plp
                        
2e0a : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2e0d : 08              >            php         ;save flags
2e0e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e11 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e13 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e14 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e16 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e19 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e1b : ca                       dex
2e1c : 10e0                     bpl teor1
                            
2e1e : a203                     ldx #3      ;zp
2e20 : b518             teor2    lda zpEO,x
2e22 : 8502                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2e24 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e26 : 48              >            pha         ;use stack to load status
2e27 : bd6f02          >            lda absEOa,x    ;precharge accu
2e2a : 28              >            plp
                        
2e2b : 4502                     eor zpt
                                tst_ax  absrlo,absflo,0
2e2d : 08              >            php         ;save flags
2e2e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e31 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e33 : 68              >            pla         ;load status
                       >            eor_flag 0
2e34 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e36 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e39 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e3b : ca                       dex
2e3c : 10e2                     bpl teor2
2e3e : a203                     ldx #3
2e40 : b518             teor3   lda zpEO,x
2e42 : 8502                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2e44 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e46 : 48              >            pha         ;use stack to load status
2e47 : bd6f02          >            lda absEOa,x    ;precharge accu
2e4a : 28              >            plp
                        
2e4b : 4502                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2e4d : 08              >            php         ;save flags
2e4e : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e51 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e53 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e54 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e56 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e59 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e5b : ca                       dex
2e5c : 10e2                     bpl teor3
                        
2e5e : a203                     ldx #3      ;abs
2e60 : b518             teor4   lda zpEO,x
2e62 : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2e65 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e67 : 48              >            pha         ;use stack to load status
2e68 : bd6f02          >            lda absEOa,x    ;precharge accu
2e6b : 28              >            plp
                        
2e6c : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2e6f : 08              >            php         ;save flags
2e70 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e73 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e75 : 68              >            pla         ;load status
                       >            eor_flag 0
2e76 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e78 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e7b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e7d : ca                       dex
2e7e : 10e0                     bpl teor4
2e80 : a203                     ldx #3
2e82 : b518             teor5   lda zpEO,x
2e84 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2e87 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e89 : 48              >            pha         ;use stack to load status
2e8a : bd6f02          >            lda absEOa,x    ;precharge accu
2e8d : 28              >            plp
                        
2e8e : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2e91 : 08              >            php         ;save flags
2e92 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e95 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2e97 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e98 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e9a : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e9d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2e9f : ca                       dex
2ea0 : 1002                     bpl teor6
                        
2ea2 : a203                     ldx #3      ;zp,x
2ea4 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
2ea4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ea6 : 48              >            pha         ;use stack to load status
2ea7 : bd6f02          >            lda absEOa,x    ;precharge accu
2eaa : 28              >            plp
                        
2eab : 5518                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
2ead : 08              >            php         ;save flags
2eae : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2eb1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2eb3 : 68              >            pla         ;load status
                       >            eor_flag 0
2eb4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2eb6 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2eb9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ebb : ca                       dex
2ebc : 10e6                     bpl teor6
2ebe : a203                     ldx #3
2ec0 :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2ec0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ec2 : 48              >            pha         ;use stack to load status
2ec3 : bd6f02          >            lda absEOa,x    ;precharge accu
2ec6 : 28              >            plp
                        
2ec7 : 5518                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2ec9 : 08              >            php         ;save flags
2eca : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ecd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2ecf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ed0 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ed2 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ed5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ed7 : ca                       dex
2ed8 : 10e6                     bpl teor7
                        
2eda : a203                     ldx #3      ;abs,x
2edc :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
2edc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ede : 48              >            pha         ;use stack to load status
2edf : bd6f02          >            lda absEOa,x    ;precharge accu
2ee2 : 28              >            plp
                        
2ee3 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
2ee6 : 08              >            php         ;save flags
2ee7 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2eea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2eec : 68              >            pla         ;load status
                       >            eor_flag 0
2eed : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2eef : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ef2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ef4 : ca                       dex
2ef5 : 10e5                     bpl teor8
2ef7 : a203                     ldx #3
2ef9 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2ef9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2efb : 48              >            pha         ;use stack to load status
2efc : bd6f02          >            lda absEOa,x    ;precharge accu
2eff : 28              >            plp
                        
2f00 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2f03 : 08              >            php         ;save flags
2f04 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f07 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f09 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f0a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f0c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f0f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f11 : ca                       dex
2f12 : 10e5                     bpl teor9
                        
2f14 : a003                     ldy #3      ;abs,y
2f16 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
2f16 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f18 : 48              >            pha         ;use stack to load status
2f19 : b96f02          >            lda absEOa,y    ;precharge accu
2f1c : 28              >            plp
                        
2f1d : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
2f20 : 08              >            php         ;save flags
2f21 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f24 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f26 : 68              >            pla         ;load status
                       >            eor_flag 0
2f27 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f29 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f2c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f2e : 88                       dey
2f2f : 10e5                     bpl teor10
2f31 : a003                     ldy #3
2f33 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
2f33 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f35 : 48              >            pha         ;use stack to load status
2f36 : b96f02          >            lda absEOa,y    ;precharge accu
2f39 : 28              >            plp
                        
2f3a : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
2f3d : 08              >            php         ;save flags
2f3e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f41 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f43 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f44 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f46 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f49 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f4b : 88                       dey
2f4c : 10e5                     bpl teor11
                        
2f4e : a206                     ldx #6      ;(zp,x)
2f50 : a003                     ldy #3
2f52 :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
2f52 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f54 : 48              >            pha         ;use stack to load status
2f55 : b96f02          >            lda absEOa,y    ;precharge accu
2f58 : 28              >            plp
                        
2f59 : 413a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
2f5b : 08              >            php         ;save flags
2f5c : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f5f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f61 : 68              >            pla         ;load status
                       >            eor_flag 0
2f62 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f64 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f67 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f69 : ca                       dex
2f6a : ca                       dex
2f6b : 88                       dey
2f6c : 10e4                     bpl teor12
2f6e : a206                     ldx #6
2f70 : a003                     ldy #3
2f72 :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
2f72 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f74 : 48              >            pha         ;use stack to load status
2f75 : b96f02          >            lda absEOa,y    ;precharge accu
2f78 : 28              >            plp
                        
2f79 : 413a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2f7b : 08              >            php         ;save flags
2f7c : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f7f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f81 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f82 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f84 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f87 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2f89 : ca                       dex
2f8a : ca                       dex
2f8b : 88                       dey
2f8c : 10e4                     bpl teor13
                        
2f8e : a003                     ldy #3      ;(zp),y
2f90 :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
2f90 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f92 : 48              >            pha         ;use stack to load status
2f93 : b96f02          >            lda absEOa,y    ;precharge accu
2f96 : 28              >            plp
                        
2f97 : 513a                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
2f99 : 08              >            php         ;save flags
2f9a : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f9d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2f9f : 68              >            pla         ;load status
                       >            eor_flag 0
2fa0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fa2 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2fa5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2fa7 : 88                       dey
2fa8 : 10e6                     bpl teor14
2faa : a003                     ldy #3
2fac :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
2fac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fae : 48              >            pha         ;use stack to load status
2faf : b96f02          >            lda absEOa,y    ;precharge accu
2fb2 : 28              >            plp
                        
2fb3 : 513a                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
2fb5 : 08              >            php         ;save flags
2fb6 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2fb9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2fbb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fbc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fbe : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2fc1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2fc3 : 88                       dey
2fc4 : 10e6                     bpl teor15
                                next_test
2fc6 : ad0002          >            lda test_case   ;previous test
2fc9 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2fcb : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
2fcd : a928            >            lda #test_num   ;*** next tests' number
2fcf : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
2fd2 : a203                     ldx #3          ;immediate - self modifying code
2fd4 : b510             tora    lda zpOR,x
2fd6 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
2fd9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fdb : 48              >            pha         ;use stack to load status
2fdc : bd6702          >            lda absORa,x    ;precharge accu
2fdf : 28              >            plp
                        
2fe0 : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
2fe3 : 08              >            php         ;save flags
2fe4 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fe7 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
2fe9 : 68              >            pla         ;load status
                       >            eor_flag 0
2fea : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fec : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fef : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
2ff1 : ca                       dex
2ff2 : 10e0                     bpl tora
2ff4 : a203                     ldx #3
2ff6 : b510             tora1   lda zpOR,x
2ff8 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
2ffb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ffd : 48              >            pha         ;use stack to load status
2ffe : bd6702          >            lda absORa,x    ;precharge accu
3001 : 28              >            plp
                        
3002 : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3005 : 08              >            php         ;save flags
3006 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3009 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
300b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
300c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
300e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3011 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3013 : ca                       dex
3014 : 10e0                     bpl tora1
                            
3016 : a203                     ldx #3      ;zp
3018 : b510             tora2   lda zpOR,x
301a : 8502                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
301c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
301e : 48              >            pha         ;use stack to load status
301f : bd6702          >            lda absORa,x    ;precharge accu
3022 : 28              >            plp
                        
3023 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,0
3025 : 08              >            php         ;save flags
3026 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3029 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
302b : 68              >            pla         ;load status
                       >            eor_flag 0
302c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
302e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3031 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3033 : ca                       dex
3034 : 10e2                     bpl tora2
3036 : a203                     ldx #3
3038 : b510             tora3   lda zpOR,x
303a : 8502                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
303c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
303e : 48              >            pha         ;use stack to load status
303f : bd6702          >            lda absORa,x    ;precharge accu
3042 : 28              >            plp
                        
3043 : 0502                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
3045 : 08              >            php         ;save flags
3046 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3049 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
304b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
304c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
304e : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3051 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3053 : ca                       dex
3054 : 10e2                     bpl tora3
                        
3056 : a203                     ldx #3      ;abs
3058 : b510             tora4   lda zpOR,x
305a : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
305d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
305f : 48              >            pha         ;use stack to load status
3060 : bd6702          >            lda absORa,x    ;precharge accu
3063 : 28              >            plp
                        
3064 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
3067 : 08              >            php         ;save flags
3068 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
306b : d0fe            >        bne *         ;failed not equal (non zero)
                       >
306d : 68              >            pla         ;load status
                       >            eor_flag 0
306e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3070 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3073 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3075 : ca                       dex
3076 : 10e0                     bpl tora4
3078 : a203                     ldx #3
307a : b510             tora5   lda zpOR,x
307c : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
307f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3081 : 48              >            pha         ;use stack to load status
3082 : bd6702          >            lda absORa,x    ;precharge accu
3085 : 28              >            plp
                        
3086 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
3089 : 08              >            php         ;save flags
308a : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
308d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
308f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3090 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3092 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3095 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3097 : ca                       dex
3098 : 1002                     bpl tora6
                        
309a : a203                     ldx #3      ;zp,x
309c :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
309c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
309e : 48              >            pha         ;use stack to load status
309f : bd6702          >            lda absORa,x    ;precharge accu
30a2 : 28              >            plp
                        
30a3 : 1510                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
30a5 : 08              >            php         ;save flags
30a6 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30a9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
30ab : 68              >            pla         ;load status
                       >            eor_flag 0
30ac : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30ae : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30b1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
30b3 : ca                       dex
30b4 : 10e6                     bpl tora6
30b6 : a203                     ldx #3
30b8 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
30b8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30ba : 48              >            pha         ;use stack to load status
30bb : bd6702          >            lda absORa,x    ;precharge accu
30be : 28              >            plp
                        
30bf : 1510                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
30c1 : 08              >            php         ;save flags
30c2 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30c5 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
30c7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30c8 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30ca : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30cd : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
30cf : ca                       dex
30d0 : 10e6                     bpl tora7
                        
30d2 : a203                     ldx #3      ;abs,x
30d4 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
30d4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30d6 : 48              >            pha         ;use stack to load status
30d7 : bd6702          >            lda absORa,x    ;precharge accu
30da : 28              >            plp
                        
30db : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
30de : 08              >            php         ;save flags
30df : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30e2 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
30e4 : 68              >            pla         ;load status
                       >            eor_flag 0
30e5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30e7 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30ea : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
30ec : ca                       dex
30ed : 10e5                     bpl tora8
30ef : a203                     ldx #3
30f1 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
30f1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30f3 : 48              >            pha         ;use stack to load status
30f4 : bd6702          >            lda absORa,x    ;precharge accu
30f7 : 28              >            plp
                        
30f8 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
30fb : 08              >            php         ;save flags
30fc : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30ff : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3101 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3102 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3104 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3107 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3109 : ca                       dex
310a : 10e5                     bpl tora9
                        
310c : a003                     ldy #3      ;abs,y
310e :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
310e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3110 : 48              >            pha         ;use stack to load status
3111 : b96702          >            lda absORa,y    ;precharge accu
3114 : 28              >            plp
                        
3115 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
3118 : 08              >            php         ;save flags
3119 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
311c : d0fe            >        bne *         ;failed not equal (non zero)
                       >
311e : 68              >            pla         ;load status
                       >            eor_flag 0
311f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3121 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3124 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3126 : 88                       dey
3127 : 10e5                     bpl tora10
3129 : a003                     ldy #3
312b :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
312b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
312d : 48              >            pha         ;use stack to load status
312e : b96702          >            lda absORa,y    ;precharge accu
3131 : 28              >            plp
                        
3132 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
3135 : 08              >            php         ;save flags
3136 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3139 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
313b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
313c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
313e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3141 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3143 : 88                       dey
3144 : 10e5                     bpl tora11
                        
3146 : a206                     ldx #6      ;(zp,x)
3148 : a003                     ldy #3
314a :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
314a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
314c : 48              >            pha         ;use stack to load status
314d : b96702          >            lda absORa,y    ;precharge accu
3150 : 28              >            plp
                        
3151 : 0142                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
3153 : 08              >            php         ;save flags
3154 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3157 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3159 : 68              >            pla         ;load status
                       >            eor_flag 0
315a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
315c : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
315f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3161 : ca                       dex
3162 : ca                       dex
3163 : 88                       dey
3164 : 10e4                     bpl tora12
3166 : a206                     ldx #6
3168 : a003                     ldy #3
316a :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
316a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
316c : 48              >            pha         ;use stack to load status
316d : b96702          >            lda absORa,y    ;precharge accu
3170 : 28              >            plp
                        
3171 : 0142                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3173 : 08              >            php         ;save flags
3174 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3177 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3179 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
317a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
317c : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
317f : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
3181 : ca                       dex
3182 : ca                       dex
3183 : 88                       dey
3184 : 10e4                     bpl tora13
                        
3186 : a003                     ldy #3      ;(zp),y
3188 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
3188 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
318a : 48              >            pha         ;use stack to load status
318b : b96702          >            lda absORa,y    ;precharge accu
318e : 28              >            plp
                        
318f : 1142                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
3191 : 08              >            php         ;save flags
3192 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3195 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
3197 : 68              >            pla         ;load status
                       >            eor_flag 0
3198 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
319a : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
319d : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
319f : 88                       dey
31a0 : 10e6                     bpl tora14
31a2 : a003                     ldy #3
31a4 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
31a4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31a6 : 48              >            pha         ;use stack to load status
31a7 : b96702          >            lda absORa,y    ;precharge accu
31aa : 28              >            plp
                        
31ab : 1142                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
31ad : 08              >            php         ;save flags
31ae : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
31b1 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
31b3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31b4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31b6 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
31b9 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
                        
31bb : 88                       dey
31bc : 10e6                     bpl tora15
                            if I_flag = 3
31be : 58                       cli
                            endif                
                                next_test
31bf : ad0002          >            lda test_case   ;previous test
31c2 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
31c4 : d0fe            >        bne *         ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
31c6 : a929            >            lda #test_num   ;*** next tests' number
31c8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
31cb : d8                       cld
31cc : a204                     ldx #ad2        ;for indexed test
31ce : a0ff                     ldy #$ff        ;max range
31d0 : a900                     lda #0          ;start with adding zeroes & no carry
31d2 : 8502                     sta adfc        ;carry in - for diag
31d4 : 8503                     sta ad1         ;operand 1 - accumulator
31d6 : 8504                     sta ad2         ;operand 2 - memory or immediate
31d8 : 8d0302                   sta ada2        ;non zp
31db : 8505                     sta adrl        ;expected result bits 0-7
31dd : 8506                     sta adrh        ;expected result bit 8 (carry out)
31df : a9ff                     lda #$ff        ;complemented operand 2 for subtract
31e1 : 8508                     sta sb2
31e3 : 8d0402                   sta sba2        ;non zp
31e6 : a902                     lda #2          ;expected Z-flag
31e8 : 8507                     sta adrf
31ea : 18               tadd    clc             ;test with carry clear
31eb : 203632                   jsr chkadd
31ee : e602                     inc adfc        ;now with carry
31f0 : e605                     inc adrl        ;result +1
31f2 : 08                       php             ;save N & Z from low result
31f3 : 08                       php
31f4 : 68                       pla             ;accu holds expected flags
31f5 : 2982                     and #$82        ;mask N & Z
31f7 : 28                       plp
31f8 : d002                     bne tadd1
31fa : e606                     inc adrh        ;result bit 8 - carry
31fc : 0506             tadd1   ora adrh        ;merge C to expected flags
31fe : 8507                     sta adrf        ;save expected flags except overflow
3200 : 38                       sec             ;test with carry set
3201 : 203632                   jsr chkadd
3204 : c602                     dec adfc        ;same for operand +1 but no carry
3206 : e603                     inc ad1
3208 : d0e0                     bne tadd        ;iterate op1
320a : a900                     lda #0          ;preset result to op2 when op1 = 0
320c : 8506                     sta adrh
320e : ee0302                   inc ada2
3211 : e604                     inc ad2
3213 : 08                       php             ;save NZ as operand 2 becomes the new result
3214 : 68                       pla
3215 : 2982                     and #$82        ;mask N00000Z0
3217 : 8507                     sta adrf        ;no need to check carry as we are adding to 0
3219 : c608                     dec sb2         ;complement subtract operand 2
321b : ce0402                   dec sba2
321e : a504                     lda ad2         
3220 : 8505                     sta adrl
3222 : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
3224 : ad0002                   lda test_case
3227 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
3229 : d0fe            >        bne *         ;failed not equal (non zero)
                        
322b : a9f0                     lda #$f0        ;mark opcode testing complete
322d : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
3230 : 4c3032          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
3233 : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3236 : a507             chkadd  lda adrf        ;add V-flag if overflow
3238 : 2983                     and #$83        ;keep N-----ZC / clear V
323a : 48                       pha
323b : a503                     lda ad1         ;test sign unequal between operands
323d : 4504                     eor ad2
323f : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
3241 : a503                     lda ad1         ;test sign equal between operands and result
3243 : 4505                     eor adrl
3245 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
3247 : 68                       pla
3248 : 0940                     ora #$40        ;set V
324a : 48                       pha
324b : 68               ckad1   pla
324c : 8507                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
324e : 08                       php             ;save carry for subtract
324f : a503                     lda ad1
3251 : 6504                     adc ad2         ;perform add
3253 : 08                       php          
3254 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3256 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3258 : 68                       pla             ;check flags
3259 : 29c3                     and #$c3        ;mask NV----ZC
325b : c507                     cmp adrf
                                trap_ne         ;bad flags
325d : d0fe            >        bne *         ;failed not equal (non zero)
                        
325f : 28                       plp
3260 : 08                       php             ;save carry for next add
3261 : a503                     lda ad1
3263 : e508                     sbc sb2         ;perform subtract
3265 : 08                       php          
3266 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3268 : d0fe            >        bne *         ;failed not equal (non zero)
                        
326a : 68                       pla             ;check flags
326b : 29c3                     and #$c3        ;mask NV----ZC
326d : c507                     cmp adrf
                                trap_ne         ;bad flags
326f : d0fe            >        bne *         ;failed not equal (non zero)
                        
3271 : 28                       plp
                        ; binary ADC / SBC abs
3272 : 08                       php             ;save carry for subtract
3273 : a503                     lda ad1
3275 : 6d0302                   adc ada2        ;perform add
3278 : 08                       php          
3279 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
327b : d0fe            >        bne *         ;failed not equal (non zero)
                        
327d : 68                       pla             ;check flags
327e : 29c3                     and #$c3        ;mask NV----ZC
3280 : c507                     cmp adrf
                                trap_ne         ;bad flags
3282 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3284 : 28                       plp
3285 : 08                       php             ;save carry for next add
3286 : a503                     lda ad1
3288 : ed0402                   sbc sba2        ;perform subtract
328b : 08                       php          
328c : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
328e : d0fe            >        bne *         ;failed not equal (non zero)
                        
3290 : 68                       pla             ;check flags
3291 : 29c3                     and #$c3        ;mask NV----ZC
3293 : c507                     cmp adrf
                                trap_ne         ;bad flags
3295 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3297 : 28                       plp
                        ; binary ADC / SBC #
3298 : 08                       php             ;save carry for subtract
3299 : a504                     lda ad2
329b : 8d1302                   sta ex_adci+1   ;set ADC # operand
329e : a503                     lda ad1
32a0 : 201202                   jsr ex_adci     ;execute ADC # in RAM
32a3 : 08                       php          
32a4 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32a6 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32a8 : 68                       pla             ;check flags
32a9 : 29c3                     and #$c3        ;mask NV----ZC
32ab : c507                     cmp adrf
                                trap_ne         ;bad flags
32ad : d0fe            >        bne *         ;failed not equal (non zero)
                        
32af : 28                       plp
32b0 : 08                       php             ;save carry for next add
32b1 : a508                     lda sb2
32b3 : 8d1602                   sta ex_sbci+1   ;set SBC # operand
32b6 : a503                     lda ad1
32b8 : 201502                   jsr ex_sbci     ;execute SBC # in RAM
32bb : 08                       php          
32bc : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32be : d0fe            >        bne *         ;failed not equal (non zero)
                        
32c0 : 68                       pla             ;check flags
32c1 : 29c3                     and #$c3        ;mask NV----ZC
32c3 : c507                     cmp adrf
                                trap_ne         ;bad flags
32c5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32c7 : 28                       plp
                        ; binary ADC / SBC zp,x
32c8 : 08                       php             ;save carry for subtract
32c9 : a503                     lda ad1
32cb : 7500                     adc 0,x         ;perform add
32cd : 08                       php          
32ce : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32d0 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32d2 : 68                       pla             ;check flags
32d3 : 29c3                     and #$c3        ;mask NV----ZC
32d5 : c507                     cmp adrf
                                trap_ne         ;bad flags
32d7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32d9 : 28                       plp
32da : 08                       php             ;save carry for next add
32db : a503                     lda ad1
32dd : f504                     sbc sb2-ad2,x   ;perform subtract
32df : 08                       php          
32e0 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32e2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32e4 : 68                       pla             ;check flags
32e5 : 29c3                     and #$c3        ;mask NV----ZC
32e7 : c507                     cmp adrf
                                trap_ne         ;bad flags
32e9 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32eb : 28                       plp
                        ; binary ADC / SBC abs,x
32ec : 08                       php             ;save carry for subtract
32ed : a503                     lda ad1
32ef : 7dff01                   adc ada2-ad2,x  ;perform add
32f2 : 08                       php          
32f3 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
32f5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
32f7 : 68                       pla             ;check flags
32f8 : 29c3                     and #$c3        ;mask NV----ZC
32fa : c507                     cmp adrf
                                trap_ne         ;bad flags
32fc : d0fe            >        bne *         ;failed not equal (non zero)
                        
32fe : 28                       plp
32ff : 08                       php             ;save carry for next add
3300 : a503                     lda ad1
3302 : fd0002                   sbc sba2-ad2,x  ;perform subtract
3305 : 08                       php          
3306 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3308 : d0fe            >        bne *         ;failed not equal (non zero)
                        
330a : 68                       pla             ;check flags
330b : 29c3                     and #$c3        ;mask NV----ZC
330d : c507                     cmp adrf
                                trap_ne         ;bad flags
330f : d0fe            >        bne *         ;failed not equal (non zero)
                        
3311 : 28                       plp
                        ; binary ADC / SBC abs,y
3312 : 08                       php             ;save carry for subtract
3313 : a503                     lda ad1
3315 : 790401                   adc ada2-$ff,y  ;perform add
3318 : 08                       php          
3319 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
331b : d0fe            >        bne *         ;failed not equal (non zero)
                        
331d : 68                       pla             ;check flags
331e : 29c3                     and #$c3        ;mask NV----ZC
3320 : c507                     cmp adrf
                                trap_ne         ;bad flags
3322 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3324 : 28                       plp
3325 : 08                       php             ;save carry for next add
3326 : a503                     lda ad1
3328 : f90501                   sbc sba2-$ff,y  ;perform subtract
332b : 08                       php          
332c : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
332e : d0fe            >        bne *         ;failed not equal (non zero)
                        
3330 : 68                       pla             ;check flags
3331 : 29c3                     and #$c3        ;mask NV----ZC
3333 : c507                     cmp adrf
                                trap_ne         ;bad flags
3335 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3337 : 28                       plp
                        ; binary ADC / SBC (zp,x)
3338 : 08                       php             ;save carry for subtract
3339 : a503                     lda ad1
333b : 6146                     adc (lo adi2-ad2,x) ;perform add
333d : 08                       php          
333e : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3340 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3342 : 68                       pla             ;check flags
3343 : 29c3                     and #$c3        ;mask NV----ZC
3345 : c507                     cmp adrf
                                trap_ne         ;bad flags
3347 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3349 : 28                       plp
334a : 08                       php             ;save carry for next add
334b : a503                     lda ad1
334d : e148                     sbc (lo sbi2-ad2,x) ;perform subtract
334f : 08                       php          
3350 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3352 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3354 : 68                       pla             ;check flags
3355 : 29c3                     and #$c3        ;mask NV----ZC
3357 : c507                     cmp adrf
                                trap_ne         ;bad flags
3359 : d0fe            >        bne *         ;failed not equal (non zero)
                        
335b : 28                       plp
                        ; binary ADC / SBC (abs),y
335c : 08                       php             ;save carry for subtract
335d : a503                     lda ad1
335f : 714e                     adc (adiy2),y   ;perform add
3361 : 08                       php          
3362 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3364 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3366 : 68                       pla             ;check flags
3367 : 29c3                     and #$c3        ;mask NV----ZC
3369 : c507                     cmp adrf
                                trap_ne         ;bad flags
336b : d0fe            >        bne *         ;failed not equal (non zero)
                        
336d : 28                       plp
336e : 08                       php             ;save carry for next add
336f : a503                     lda ad1
3371 : f150                     sbc (sbiy2),y   ;perform subtract
3373 : 08                       php          
3374 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3376 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3378 : 68                       pla             ;check flags
3379 : 29c3                     and #$c3        ;mask NV----ZC
337b : c507                     cmp adrf
                                trap_ne         ;bad flags
337d : d0fe            >        bne *         ;failed not equal (non zero)
                        
337f : 28                       plp
3380 : 60                       rts
                        
                        ; target for the jump absolute test
3381 : 88                       dey
3382 : 88                       dey
3383 :                  test_far
3383 : 08                       php             ;either SP or Y count will fail, if we do not hit
3384 : 88                       dey
3385 : 88                       dey
3386 : 88                       dey
3387 : 28                       plp
                                trap_cs         ;flags loaded?
3388 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
338a : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
338c : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
338e : f0fe            >        beq *           ;failed equal (zero)
                        
3390 : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
3392 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3394 : e041                     cpx #'A'
                                trap_ne        
3396 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3398 : c04f                     cpy #('R'-3)
                                trap_ne
339a : d0fe            >        bne *         ;failed not equal (non zero)
                        
339c : 48                       pha             ;save a,x
339d : 8a                       txa
339e : 48                       pha
339f : ba                       tsx
33a0 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
33a2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
33a4 : 68                       pla             ;restore x
33a5 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
33a6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
33a8 : 48              >            pha         ;use stack to load status
33a9 : 28              >            plp
                        
33aa : 68                       pla             ;restore a
33ab : e8                       inx             ;return registers with modifications
33ac : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
33ae : 4cd207                   jmp far_ret
                                
                        ; target for the jump indirect test
33b1 : 00                       align
33b2 : bb33             ptr_tst_ind dw test_ind
33b4 : 2708             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
33b6 : 4cb633          >        jmp *           ;failed anyway
                        
33b9 : 88                       dey
33ba : 88                       dey
33bb :                  test_ind
33bb : 08                       php             ;either SP or Y count will fail, if we do not hit
33bc : 88                       dey
33bd : 88                       dey
33be : 88                       dey
33bf : 28                       plp
                                trap_cs         ;flags loaded?
33c0 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
33c2 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
33c4 : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
33c6 : f0fe            >        beq *           ;failed equal (zero)
                        
33c8 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
33ca : d0fe            >        bne *         ;failed not equal (non zero)
                        
33cc : e04e                     cpx #'N'
                                trap_ne        
33ce : d0fe            >        bne *         ;failed not equal (non zero)
                        
33d0 : c041                     cpy #('D'-3)
                                trap_ne
33d2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
33d4 : 48                       pha             ;save a,x
33d5 : 8a                       txa
33d6 : 48                       pha
33d7 : ba                       tsx
33d8 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
33da : d0fe            >        bne *         ;failed not equal (non zero)
                        
33dc : 68                       pla             ;restore x
33dd : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
33de : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
33e0 : 48              >            pha         ;use stack to load status
33e1 : 28              >            plp
                        
33e2 : 68                       pla             ;restore a
33e3 : e8                       inx             ;return registers with modifications
33e4 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
33e6 : 6cb433                   jmp (ptr_ind_ret)
                                trap            ;runover protection
33e9 : 4ce933          >        jmp *           ;failed anyway
                        
33ec : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
33ef : 88                       dey
33f0 : 88                       dey
33f1 :                  test_jsr
33f1 : 08                       php             ;either SP or Y count will fail, if we do not hit
33f2 : 88                       dey
33f3 : 88                       dey
33f4 : 88                       dey
33f5 : 28                       plp
                                trap_cs         ;flags loaded?
33f6 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
33f8 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
33fa : 30fe            >        bmi *         ;failed minus (bit 7 set)
                        
                                trap_eq 
33fc : f0fe            >        beq *           ;failed equal (zero)
                        
33fe : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
3400 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3402 : e053                     cpx #'S'
                                trap_ne        
3404 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3406 : c04f                     cpy #('R'-3)
                                trap_ne
3408 : d0fe            >        bne *         ;failed not equal (non zero)
                        
340a : 48                       pha             ;save a,x
340b : 8a                       txa
340c : 48                       pha       
340d : ba                       tsx             ;sp -4? (return addr,a,x)
340e : e0fb                     cpx #$fb
                                trap_ne
3410 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3412 : adff01                   lda $1ff        ;propper return on stack
3415 : c908                     cmp #hi(jsr_ret)
                                trap_ne
3417 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3419 : adfe01                   lda $1fe
341c : c95d                     cmp #lo(jsr_ret)
                                trap_ne
341e : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
3420 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3422 : 48              >            pha         ;use stack to load status
3423 : 28              >            plp
                        
3424 : 68                       pla             ;pull x,a
3425 : aa                       tax
3426 : 68                       pla
3427 : e8                       inx             ;return registers with modifications
3428 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
342a : 60                       rts
                                trap            ;runover protection
342b : 4c2b34          >        jmp *           ;failed anyway
                        
342e : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
3431 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
3431 : 4c3134          >        jmp *           ;failed anyway
                        
3434 : 4c0004                   jmp start       ;catastrophic error - cannot continue
3437 :                  res_trap
                                trap            ;unexpected RESET
3437 : 4c3734          >        jmp *           ;failed anyway
                        
343a : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
343d : 88                       dey
343e : 88                       dey
343f :                  irq_trap                ;BRK test or unextpected BRK or IRQ
343f : 08                       php             ;either SP or Y count will fail, if we do not hit
3440 : 88                       dey
3441 : 88                       dey
3442 : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
3443 : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
3445 : f042                     beq break2
3447 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
3449 : d0fe            >        bne *         ;failed not equal (non zero)
                        
344b : e052                     cpx #'R'
                                trap_ne        
344d : d0fe            >        bne *         ;failed not equal (non zero)
                        
344f : c048                     cpy #'K'-3
                                trap_ne
3451 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3453 : 8500                     sta irq_a       ;save registers during break test
3455 : 8601                     stx irq_x
3457 : ba                       tsx             ;test break on stack
3458 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
345b : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
345d : d0fe            >        bne *         ;failed not equal (non zero)
                        
345f : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
3460 : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
3462 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3464 : ba                       tsx
3465 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
3467 : d0fe            >        bne *         ;failed not equal (non zero)
                        
3469 : adff01                   lda $1ff        ;propper return on stack
346c : c908                     cmp #hi(brk_ret0)
                                trap_ne
346e : d0fe            >        bne *         ;failed not equal (non zero)
                        
3470 : adfe01                   lda $1fe
3473 : c994                     cmp #lo(brk_ret0)
                                trap_ne
3475 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                load_flag $ff
3477 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
3479 : 48                       pha
347a : a601                     ldx irq_x
347c : e8                       inx             ;return registers with modifications
347d : a500                     lda irq_a
347f : 49aa                     eor #$aa
3481 : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
3482 : 40                       rti
                                trap            ;runover protection
3483 : 4c8334          >        jmp *           ;failed anyway
                        
3486 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
3489 :                  break2                  ;BRK pass 2        
3489 : e0ad                     cpx #$ff-'R'
                                trap_ne        
348b : d0fe            >        bne *         ;failed not equal (non zero)
                        
348d : c0b1                     cpy #$ff-'K'-3
                                trap_ne
348f : d0fe            >        bne *         ;failed not equal (non zero)
                        
3491 : 8500                     sta irq_a       ;save registers during break test
3493 : 8601                     stx irq_x
3495 : ba                       tsx             ;test break on stack
3496 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
3499 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
349b : d0fe            >        bne *         ;failed not equal (non zero)
                        
349d : 68                       pla
349e : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
34a0 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
34a2 : d0fe            >        bne *         ;failed not equal (non zero)
                        
34a4 : ba                       tsx
34a5 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
34a7 : d0fe            >        bne *         ;failed not equal (non zero)
                        
34a9 : adff01                   lda $1ff        ;propper return on stack
34ac : c908                     cmp #hi(brk_ret1)
                                trap_ne
34ae : d0fe            >        bne *         ;failed not equal (non zero)
                        
34b0 : adfe01                   lda $1fe
34b3 : c9ba                     cmp #lo(brk_ret1)
                                trap_ne
34b5 : d0fe            >        bne *         ;failed not equal (non zero)
                        
                                load_flag intdis
34b7 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
34b9 : 48                       pha      
34ba : a601                     ldx irq_x
34bc : e8                       inx             ;return registers with modifications
34bd : a500                     lda irq_a
34bf : 49aa                     eor #$aa
34c1 : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
34c2 : 40                       rti
                                trap            ;runover protection
34c3 : 4cc334          >        jmp *           ;failed anyway
                        
34c6 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zps_    db  $80,1           ;additional shift pattern to test zero result & flag
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
                        rASL_                               ;expected result ASL & ROL -carry
                        rROL_   db  0,2,$86,$04,$82,0
                        rROLc_  db  1,3,$87,$05,$83,1       ;expected result ROL +carry
                        rLSR_                               ;expected result LSR & ROR -carry
                        rROR_   db  $40,0,$61,$41,$20,0
                        rRORc_  db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                               ;expected flags for shifts
                        fROL_   db  fzc,0,fnc,fc,fn,fz      ;no carry in
                        fROLc_  db  fc,0,fnc,fc,fn,0        ;carry in 
                        fLSR_
                        fROR_   db  0,fzc,fc,0,fc,fz        ;no carry in
                        fRORc_  db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80           ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80         ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0             ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff         ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
fffa =                          org $fffa       ;vectors
fffa : 3134                     dw  nmi_trap
fffc : 3734                     dw  res_trap
fffe : 3f34                     dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0000 through $ffff.
Total size 65536 bytes.
Program start address is at $0400 (1024).
